// OmniLisp Standard Library (Prelude)
// Common functions for list manipulation, I/O, and utilities
//
// Design principles:
// 1. PARALLEL BY DEFAULT: @map, @filter use HVM4's parallel evaluation
//    - For effectful functions, use @map_seq, @filter_seq (sequential)
//    - Use @smart_map, @smart_filter for auto-detection via (effect-free? fn)
// 2. Type dispatch: Functions dispatch on input type
//    - List (#CON/#NIL) → eager, returns List
//    - Iterator (#Iter/#Rang) → lazy, returns Iterator
//    - Array (#Arr) → eager, returns Array
//    - Dict (#Dict) → eager, returns Dict
// This enables gradual/flowing laziness through pipelines.

// =============================================================================
// Sequence Conversion Helpers
// =============================================================================

// Convert any sequence to list (materializes lazy sequences)
@to_list = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. xs
    #Arr: λ&len. λ&data. data
    #Iter: λ&state. λ&next_fn. @iter_to_list(xs)
    #Rang: λ&s. λ&e. λ&st. @iter_to_list(xs)
  }(xs)

// Materialize iterator to list
@iter_to_list = λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. #CON{v, @iter_to_list(rest)}
    #None: #NIL
  }(stepped))(@iter_next(iter))

// List length (O(n) for lists)
@list_length = λ&xs.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t. (1 + @list_length(t))
  }(xs)

// =============================================================================
// Polymorphic Sequence Operations (dispatch on List vs Iterator)
// =============================================================================

// Map a function over a sequence (PARALLEL by default)
// List → List, Array → Array, Dict → Dict (values), Iterator → Iterator
// NOTE: For effectful functions (IO, state), use @map_seq instead!
@map = λ&f. λ&xs.
  λ{
    // Eager: list - PARALLEL: head and tail computed simultaneously
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&mapped_h. (λ&mapped_t.
        #CON{mapped_h, mapped_t}
      )(@map(f)(t)))(f(h))
    // Eager: array
    #Arr: λ&len. λ&data.
      #Arr{len, @map(f)(data)}
    // Eager: dict (maps over values, preserves keys)
    #Dict: λ&entries.
      #Dict{@map(λ&pair.
        λ{#CON: λ&k. λ&rest.
          λ{#CON: λ&v. λ&u.
            #CON{k, #CON{f(v), #NIL}}
          }(rest)
        }(pair)
      )(entries)}
    // Lazy: iterator
    #Iter: λ&state. λ&next_fn.
      #Iter{xs, λ&i.
        λ{
          #Some: λ&v. λ&rest. #Some{f(v), @map(f)(rest)}
          #None: #None{}
        }(@iter_next(i))
      }
    #Rang: λ&s. λ&e. λ&st.
      #Iter{xs, λ&i.
        λ{
          #Some: λ&v. λ&rest. #Some{f(v), @map(f)(rest)}
          #None: #None{}
        }(@iter_next(i))
      }
  }(xs)

// Filter a sequence by predicate (PARALLEL by default)
// List → List, Array → Array, Dict → Dict (by value), Iterator → Iterator
// NOTE: For effectful predicates (IO, state), use @filter_seq instead!
@filter = λ&p. λ&xs.
  λ{
    // Eager: list - PARALLEL: predicate and recursive filter run simultaneously
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&pred_result. (λ&filtered_t.
        λ{
          #True: #CON{h, filtered_t}
          _: λ&u_. filtered_t
        }(pred_result)
      )(@filter(p)(t)))(p(h))
    // Eager: array (filter then rebuild)
    #Arr: λ&len. λ&data.
      @list_to_arr(@filter(p)(data))
    // Eager: dict (filter by value predicate)
    #Dict: λ&entries.
      #Dict{@filter(λ&pair.
        λ{#CON: λ&u. λ&rest.
          λ{#CON: λ&v. λ&u. p(v)}(rest)
        }(pair)
      )(entries)}
    // Lazy: iterator
    #Iter: λ&state. λ&next_fn.
      #Iter{xs, @filter_iter_next(p)}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{xs, @filter_iter_next(p)}
  }(xs)

@filter_iter_next = λ&p. λ&i.
  λ{
    #Some: λ&v. λ&rest.
      λ{
        #True: #Some{v, @filter(p)(rest)}
        _: λ&u_. @filter_iter_next(p)(rest)
      }(p(v))
    #None: #None{}
  }(@iter_next(i))

// Left fold - works on List, Array, Dict (values), Iterator
@foldl = λ&f. λ&acc. λ&xs.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t. @foldl(f)(f(acc)(h))(t)
    #Arr: λ&len. λ&data. @foldl(f)(acc)(data)
    #Dict: λ&entries.
      @foldl(λ&a. λ&pair.
        λ{#CON: λ&u. λ&rest.
          λ{#CON: λ&v. λ&u. f(a)(v)}(rest)
        }(pair)
      )(acc)(entries)
    #Iter: λ&state. λ&next_fn.
      @foldl_iter(f)(acc)(xs)
    #Rang: λ&s. λ&e. λ&st.
      @foldl_iter(f)(acc)(xs)
  }(xs)

// Helper for folding over iterators
@foldl_iter = λ&f. λ&acc. λ&i.
  λ{
    #Some: λ&v. λ&rest. @foldl_iter(f)(f(acc)(v))(rest)
    #None: acc
  }(@iter_next(i))

// =============================================================================
// Sequential Versions (for effectful functions)
// These use lazy evaluation (λ instead of λ&) to ensure sequential execution
// Use these when f has side effects (IO, mutation, effects)
// =============================================================================

// Sequential map - forces left-to-right evaluation
// Use when f has side effects
@map_seq = λ&f. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λh. λt.
      // Force h evaluation before t (sequential)
      (λ&hres. #CON{hres, @map_seq(f)(t)})(f(h))
    #Arr: λlen. λdata.
      #Arr{len, @map_seq(f)(data)}
    #Dict: λentries.
      #Dict{@map_seq(λpair.
        λ{#CON: λk. λrest.
          λ{#CON: λv. λu.
            #CON{k, #CON{f(v), #NIL}}
          }(rest)
        }(pair)
      )(entries)}
    // For iterators, we consume sequentially
    #Iter: λstate. λnext_fn.
      @map_seq_iter(f)(xs)
    #Rang: λs. λe. λst.
      @map_seq_iter(f)(xs)
  }(xs)

@map_seq_iter = λ&f. λi.
  λ{
    #Some: λv. λrest.
      (λ&hres. #CON{hres, @map_seq_iter(f)(rest)})(f(v))
    #None: #NIL
  }(@iter_next(i))

// Sequential filter - forces left-to-right predicate evaluation
// Use when p has side effects
@filter_seq = λ&p. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      // Force predicate evaluation before proceeding
      (λ&pres.
        λ{
          #True: #CON{h, @filter_seq(p)(t)}
          _: λu_. @filter_seq(p)(t)
        }(pres)
      )(p(h))
    #Arr: λlen. λdata.
      @list_to_arr(@filter_seq(p)(data))
    #Dict: λentries.
      #Dict{@filter_seq(λpair.
        λ{#CON: λu. λrest.
          λ{#CON: λv. λu. p(v)}(rest)
        }(pair)
      )(entries)}
    #Iter: λstate. λnext_fn.
      @filter_seq_iter(p)(xs)
    #Rang: λs. λe. λst.
      @filter_seq_iter(p)(xs)
  }(xs)

@filter_seq_iter = λ&p. λi.
  λ{
    #Some: λ&v. λ&rest.
      (λ&pres.
        λ{
          #True: #CON{v, @filter_seq_iter(p)(rest)}
          _: λu_. @filter_seq_iter(p)(rest)
        }(pres)
      )(p(v))
    #None: #NIL
  }(@iter_next(i))

// Sequential foldl (note: foldl is inherently sequential by design,
// but this version ensures strict ordering of f applications)
@foldl_seq = λ&f. λ&acc. λ&xs.
  λ{
    #NIL: acc
    #CON: λh. λt.
      // Force accumulator update before recursion
      (λ&new_acc. @foldl_seq(f)(new_acc)(t))(f(acc)(h))
    #Arr: λlen. λdata. @foldl_seq(f)(acc)(data)
    #Dict: λentries.
      @foldl_seq(λa. λpair.
        λ{#CON: λu. λrest.
          λ{#CON: λv. λu. f(a)(v)}(rest)
        }(pair)
      )(acc)(entries)
    #Iter: λstate. λnext_fn.
      @foldl_seq_iter(f)(acc)(xs)
    #Rang: λs. λe. λst.
      @foldl_seq_iter(f)(acc)(xs)
  }(xs)

@foldl_seq_iter = λ&f. λ&acc. λi.
  λ{
    #Some: λv. λrest.
      (λ&new_acc. @foldl_seq_iter(f)(new_acc)(rest))(f(acc)(v))
    #None: acc
  }(@iter_next(i))

// =============================================================================
// Smart Dispatch Versions (auto-detect effect-free-ness)
// These check if the function has effects and dispatch accordingly
// =============================================================================

// Smart map - checks effect-free? and dispatches to parallel or sequential
@smart_map = λ&f. λ&xs.
  λ{
    #True: @map(f)(xs)       // effect-free → parallel
    _:     λu. @map_seq(f)(xs)   // effectful → sequential
  }(#Effr{f})

// Smart filter - checks effect-free? and dispatches to parallel or sequential
@smart_filter = λ&p. λ&xs.
  λ{
    #True: @filter(p)(xs)       // effect-free → parallel
    _:     λu. @filter_seq(p)(xs)   // effectful → sequential
  }(#Effr{p})

// Smart foldl - checks effect-free? and dispatches to parallel or sequential
@smart_foldl = λ&f. λ&acc. λ&xs.
  λ{
    #True: @foldl(f)(acc)(xs)       // effect-free → parallel
    _:     λu. @foldl_seq(f)(acc)(xs)   // effectful → sequential
  }(#Effr{f})

// Right fold - works on List, Array, Dict (values)
@foldr = λ&f. λ&acc. λ&xs.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t. f(h)(@foldr(f)(acc)(t))
    #Arr: λ&len. λ&data. @foldr(f)(acc)(data)
    #Dict: λ&entries.
      @foldr(λ&pair. λ&a.
        λ{#CON: λ&u. λ&rest.
          λ{#CON: λ&v. λ&u. f(v)(a)}(rest)
        }(pair)
      )(acc)(entries)
  }(xs)

// Length of a sequence - List, Array, Dict
@length = λ&xs.
  λ{
    #NIL: #Cst{0}
    #CON: λ&h. λ&t. @foldl(λ&acc. λu. #Cst{(λ{#Cst: λ&n. n}(acc) + 1)})(#Cst{0})(xs)
    #Arr: λ&len. λ&data. len
    #Dict: λ&entries. @length(entries)
  }(xs)

// Reverse a sequence - List → List, Array → Array
@reverse = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. @foldl(λ&acc. λ&h. #CON{h, acc})(#NIL)(xs)
    #Arr: λ&len. λ&data. #Arr{len, @reverse(data)}
  }(xs)

// Append two lists
@append = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @append(t)(ys)}
  }(xs)

// Concatenate a list of lists
@concat = λ&xss.
  @foldr(@append)(#NIL)(xss)

// Take first n elements
// List → List, Array → Array, Iterator → Iterator
@take = λ&n. λ&xs.
  λ{
    // Eager: list
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        0: #NIL
        _: λ&u_. #CON{h, @take(#Cst{(λ{#Cst: λ&m. m}(n) - 1)})(t)}
      }(λ{#Cst: λ&m. m}(n))
    // Eager: array
    #Arr: λ&len. λ&data.
      @list_to_arr(@take(n)(data))
    // Lazy: iterator
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{n, xs}, @take_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{n, xs}, @take_iter_next}
  }(xs)

@take_iter_next = λ&state.
  λ{#CON: λ&count. λ&i.
    λ{#Cst: λ&c.
      λ{
        0: #None{}
        _: λ&u_. λ{
          #Some: λ&v. λ&rest.
            #Some{v, #CON{#Cst{(c - 1)}, rest}}
          #None: #None{}
        }(@iter_next(i))
      }(c)
    }(count)
  }(state)

// Drop first n elements
// List → List, Array → Array, Iterator → Iterator
@drop = λ&n. λ&xs.
  λ{
    // Eager: list
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        0: xs
        _: λ&u_. @drop(#Cst{(λ{#Cst: λ&m. m}(n) - 1)})(t)
      }(λ{#Cst: λ&m. m}(n))
    // Eager: array
    #Arr: λ&len. λ&data.
      @list_to_arr(@drop(n)(data))
    // Lazy: iterator
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{n, xs}, @drop_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{n, xs}, @drop_iter_next}
  }(xs)

@drop_iter_next = λ&state.
  λ{#CON: λ&count. λ&i.
    λ{#Cst: λ&c.
      λ{
        0: λ{
          #Some: λ&v. λ&rest.
            #Some{v, #CON{#Cst{0}, rest}}
          #None: #None{}
        }(@iter_next(i))
        _: λ&u_. λ{
          #Some: λ&uu. λ&rest.
            @drop_iter_next(#CON{#Cst{(c - 1)}, rest})
          #None: #None{}
        }(@iter_next(i))
      }(c)
    }(count)
  }(state)

// Get element at index
// Get nth element (0-indexed)
// Polymorphic: List (O(n)), Array (O(1)), Iterator (O(n))
@nth = λ&n. λ&xs.
  (λ&idx.
    λ{
      // Array - O(1) direct access
      #Arr: λ&len. λ&data.
        λ{1: #Noth{}; _: @nth_list(idx)(data)}((idx >= len))
      // List - O(n) traversal
      #NIL: #Noth{}
      #CON: λ&h. λ&t. @nth_list(idx)(xs)
      // Iterator - materialize and access
      #Iter: λ&state. λ&next_fn. @nth_iter(idx)(xs)
      #Rang: λ&s. λ&e. λ&st.
        (λ&val. λ{1: #Noth{}; _: val}((val >= e)))((s + (idx * st)))
    }(xs)
  )(λ{#Cst: λ&m. m; _: λ&u_. n}(n))

// Helper: nth for lists
@nth_list = λ&n. λ&xs.
  λ{
    0: λ{#NIL: #Noth{}; #CON: λ&h. λ&t. h}(xs)
    _: λ{#NIL: #Noth{}; #CON: λ&h. λ&t. @nth_list((n - 1))(t)}(xs)
  }(n)

// Helper: nth over iterator
@nth_iter = λ&n. λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{0: v; _: @nth_iter((n - 1))(rest)}(n)
    #None: #Noth{}
  }(stepped))(@iter_next(iter))

// Head of list
@head = λ&xs.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t. h
  }(xs)

// Tail of list
@tail = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. t
  }(xs)

// Last element
@last = λ&xs.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      λ{
        #NIL: h
        _: λ&u_. @last(t)
      }(t)
  }(xs)

// Init (all but last)
@init = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #NIL: #NIL
        _: λ&u_. #CON{h, @init(t)}
      }(t)
  }(xs)

// Check if list is empty
@null_p = λ&xs.
  λ{
    #NIL: #True{}
    _: λ&u_. #Fals{}
  }(xs)

// Check if element is in list
@elem_p = λ&x. λ&xs.
  λ{
    #NIL: #Fals{}
    #CON: λ&h. λ&t.
      λ{
        1: #True{}
        _: λ&u_. @elem_p(x)(t)
      }(@omni_values_equal(x)(h))
  }(xs)

// Zip two sequences
// List → List, Array → Array, Iterator → Iterator
@zip = λ&xs. λ&ys.
  λ{
    // Eager: list
    #NIL: #NIL
    #CON: λ&xh. λ&xt.
      λ{
        #NIL: #NIL
        #CON: λ&yh. λ&yt.
          #CON{#CON{xh, #CON{yh, #NIL}}, @zip(xt)(yt)}
        #Arr: λ&len. λ&data.
          @zip(xs)(data)
      }(ys)
    // Eager: array - zip underlying data, rebuild array
    #Arr: λ&len1. λ&data1.
      λ{
        #Arr: λ&len2. λ&data2.
          @list_to_arr(@zip(data1)(data2))
        _: λ&u_. @zip(data1)(ys)
      }(ys)
    // Lazy: iterator
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{xs, ys}, @zip_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{xs, ys}, @zip_iter_next}
  }(xs)

@zip_iter_next = λ&state.
  λ{#CON: λ&i1. λ&i2.
    λ{
      #Some: λ&v1. λ&rest1.
        λ{
          #Some: λ&v2. λ&rest2.
            #Some{#CON{v1, #CON{v2, #NIL}}, #CON{rest1, rest2}}
          #None: #None{}
        }(@iter_next(i2))
      #None: #None{}
    }(@iter_next(i1))
  }(state)

// Zip with function
// List → List (eager), Iterator → Iterator (lazy)
@zipWith = λ&f. λ&xs. λ&ys.
  @map(λ&pair.
    λ{#CON: λ&a. λ&rest.
      λ{#CON: λ&b. λ&u. f(a)(b)}(rest)
    }(pair)
  )(@zip(xs)(ys))

// Flatten (one level)
@flatten = @concat

// =============================================================================
// Lazy Iterators (default for sequences)
// =============================================================================

// Range [start..end) with step - LAZY by default
// Returns #Rang iterator, use (collect ...) to realize
@range = λ&start. λ&end.
  #Rang{start, end, #Cst{1}}

// Range with explicit step
@range_step = λ&start. λ&end. λ&step.
  #Rang{start, end, step}

// Eager range (when you need a list immediately)
@range_eager = λ&start. λ&end.
  !!&s = (λ{#Cst: λ&n. n})(start);
  !!&e = (λ{#Cst: λ&n. n})(end);
  λ{
    1: #NIL
    _: λ&u_. #CON{#Cst{s}, @range_eager(#Cst{(s + 1)})(#Cst{e})}
  }((s >= e))

// Iterate: generate infinite sequence by applying f repeatedly
// (iterate inc 0) → 0, 1, 2, 3, ...
@iterate = λ&f. λ&seed.
  #Iter{seed, λ&s. #Some{s, f(s)}}

// Repeat value infinitely
@repeat = λ&x.
  #Iter{x, λ&v. #Some{v, v}}

// Repeat value n times (finite, eager)
@repeat_n = λ&n. λ&x.
  λ{
    0: #NIL
    _: λ&u_. #CON{x, @repeat_n((n - 1))(x)}
  }(λ{#Cst: λ&m. m}(n))

// Cycle through a list infinitely
@cycle = λ&xs.
  #Iter{#CON{xs, xs}, @cycle_next}

@cycle_next = λ&state.
  λ{#CON: λ&orig. λ&curr.
    λ{
      #NIL: @cycle_next(#CON{orig, orig})
      #CON: λ&h. λ&t. #Some{h, #CON{orig, t}}
    }(curr)
  }(state)

// =============================================================================
// Iterator Protocol
// =============================================================================

// Advance iterator: returns #Some{value, rest} or #None{}
@iter_next = λ&iter.
  λ{
    // Range iterator
    #Rang: λ&start. λ&end. λ&step.
      !!&s = (λ{#Cst: λ&n. n})(start);
      !!&e = (λ{#Cst: λ&n. n})(end);
      !!&st = (λ{#Cst: λ&n. n})(step);
      λ{
        1: #None{}
        _: λ&u_. #Some{start, #Rang{#Cst{(s + st)}, end, step}}
      }((st > 0) * (s >= e) + (st < 0) * (s <= e))
    // General iterator
    #Iter: λ&state. λ&next_fn.
      next_fn(state)
    // List-as-iterator
    #CON: λ&h. λ&t. #Some{h, t}
    #NIL: #None{}
    _: λ&u_. #None{}
  }(iter)

// Check if done
@done_p = λ&iter.
  λ{
    #Some: λ&u. λ&u. #Fals{}
    #None: #True{}
  }(@iter_next(iter))

// =============================================================================
// Realization (Iterator → Collection)
// =============================================================================

// Collect: realize sequence into list
@collect = λ&seq.
  λ{
    // Already a list - return as-is
    #NIL: #NIL
    #CON: λ&h. λ&t. seq
    // Array - extract data list
    #Arr: λ&len. λ&data. data
    // Dict - convert to list of pairs
    #Dict: λ&entries. entries
    // Iterator - realize it
    _: λ&u_. @collect_helper(seq)(#NIL)
  }(seq)

@collect_helper = λ&iter. λ&acc.
  λ{
    #Some: λ&v. λ&rest.
      @collect_helper(rest)(#CON{v, acc})
    #None: @reverse(acc)
  }(@iter_next(iter))

// Collect into array
@collect_array = λ&seq.
  λ{
    // Already an array - return as-is
    #Arr: λ&len. λ&data. seq
    // List - convert to array
    #NIL: #Arr{#Cst{0}, #NIL}
    #CON: λ&h. λ&t. @list_to_arr(seq)
    // Dict - keys as array
    #Dict: λ&entries. @list_to_arr(@map(@head)(entries))
    // Iterator - collect then convert
    _: λ&u_. @list_to_arr(@collect(seq))
  }(seq)

// Collect into dict (from sequence of pairs)
@collect_dict = λ&seq.
  λ{
    // Already a dict - return as-is
    #Dict: λ&entries. seq
    // List of pairs - convert to dict
    #NIL: #Dict{#NIL}
    #CON: λ&h. λ&t. #Dict{seq}
    // Iterator - collect pairs then wrap
    _: λ&u_. #Dict{@collect(seq)}
  }(seq)

// Into: collect into target collection type
// (into [] seq) → array
// (into '() seq) → list
// (into #{} seq) → dict
@into = λ&target. λ&seq.
  λ{
    #Arr: λ&len. λ&data.
      @collect_array(@chain(target)(seq))
    #Dict: λ&entries.
      @collect_dict(@chain(entries)(seq))
    #NIL: @collect(seq)
    #CON: λ&h. λ&t.
      @append(target)(@collect(seq))
  }(target)

// =============================================================================
// Array Operations
// =============================================================================

// Array length
@arr_len = λ&arr.
  λ{#Arr: λ&len. λ&u. len}(arr)

// Array set (functional update, returns new array) - unique operation
@arr_set = λ&arr. λ&idx. λ&val.
  λ{#Arr: λ&len. λ&data.
    #Arr{len, @list_set(data)(idx)(val)}
  }(arr)

@list_set = λ&xs. λ&idx. λ&val.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{#Cst: λ&i.
        λ{
          0: #CON{val, t}
          _: λ&u_. #CON{h, @list_set(t)(#Cst{(i - 1)})(val)}
        }(i)
      }(idx)
  }(xs)

// List to array conversion
@list_to_arr = λ&xs.
  #Arr{@length(xs), xs}

// =============================================================================
// Dict Operations
// =============================================================================

// Dict get
@dict_get = λ&dict. λ&key.
  λ{#Dict: λ&entries.
    @alist_get(entries)(key)
  }(dict)

// Rebind rest/key before inner switch to fix de Bruijn levels
@alist_get = λ&entries. λ&key.
  λ{
    #NIL: #Noth{}
    #CON: λ&pair. λ&rest.
      !&rest2 = rest;
      !&key2 = key;
      λ{#CON: λ&k. λ&v_rest.
        λ{
          1: λ{#CON: λ&v. λ&u. v}(v_rest)
          0: @alist_get(rest2)(key2)
        }(@omni_values_equal(k)(key2))
      }(pair)
  }(entries)

// Dict set (functional update)
@dict_set = λ&dict. λ&key. λ&val.
  λ{#Dict: λ&entries.
    #Dict{@alist_set(entries)(key)(val)}
  }(dict)

// Rebind rest/key/val/pair before inner switch to fix de Bruijn levels
@alist_set = λ&entries. λ&key. λ&val.
  λ{
    #NIL: #CON{#CON{key, #CON{val, #NIL}}, #NIL}
    #CON: λ&pair. λ&rest.
      !&rest2 = rest;
      !&key2 = key;
      !&val2 = val;
      !&pair2 = pair;
      λ{#CON: λ&k. λ&v_rest.
        λ{
          1: #CON{#CON{key2, #CON{val2, #NIL}}, rest2}
          0: #CON{pair2, @alist_set(rest2)(key2)(val2)}
        }(@omni_values_equal(k)(key2))
      }(pair)
  }(entries)

// Dict remove
@dict_remove = λ&dict. λ&key.
  λ{#Dict: λ&entries.
    #Dict{@alist_remove(entries)(key)}
  }(dict)

// Rebind rest/key/pair before inner switch to fix de Bruijn levels
@alist_remove = λ&entries. λ&key.
  λ{
    #NIL: #NIL
    #CON: λ&pair. λ&rest.
      !&rest2 = rest;
      !&key2 = key;
      !&pair2 = pair;
      λ{#CON: λ&k. λ&u.
        λ{
          1: rest2
          0: #CON{pair2, @alist_remove(rest2)(key2)}
        }(@omni_values_equal(k)(key2))
      }(pair)
  }(entries)

// Dict has key?
@dict_has_p = λ&dict. λ&key.
  λ{
    #Noth: #Fals{}
    _: λ&u_. #True{}
  }(@dict_get(dict)(key))

// Dict keys
@dict_keys = λ&dict.
  λ{#Dict: λ&entries.
    @map(@head)(entries)
  }(dict)

// Dict values
@dict_values = λ&dict.
  λ{#Dict: λ&entries.
    @map(λ&pair. λ{#CON: λ&u. λ&rest. λ{#CON: λ&v. λ&u. v}(rest)}(pair))(entries)
  }(dict)

// Dict entries (as list of pairs)
@dict_entries = λ&dict.
  λ{#Dict: λ&entries. entries}(dict)

// Dict size
@dict_size = λ&dict.
  λ{#Dict: λ&entries. @length(entries)}(dict)

// Dict map values
@dict_map = λ&f. λ&dict.
  λ{#Dict: λ&entries.
    #Dict{@map(λ&pair.
      λ{#CON: λ&k. λ&rest.
        λ{#CON: λ&v. λ&u.
          #CON{k, #CON{f(v), #NIL}}
        }(rest)
      }(pair)
    )(entries)}
  }(dict)

// Dict filter
@dict_filter = λ&p. λ&dict.
  λ{#Dict: λ&entries.
    #Dict{@filter(λ&pair.
      λ{#CON: λ&k. λ&rest.
        λ{#CON: λ&v. λ&u. p(k)(v)}(rest)
      }(pair)
    )(entries)}
  }(dict)

// Dict merge (right takes precedence)
@dict_merge = λ&d1. λ&d2.
  λ{#Dict: λ&e1.
    λ{#Dict: λ&e2.
      #Dict{@foldl(λ&acc. λ&pair.
        λ{#CON: λ&k. λ&rest.
          λ{#CON: λ&v. λ&u.
            @alist_set(acc)(k)(v)
          }(rest)
        }(pair)
      )(e1)(e2)}
    }(d2)
  }(d1)

// Dict as iterator (yields pairs)
@dict_iter = λ&dict.
  λ{#Dict: λ&entries. entries}(dict)

// =============================================================================
// Higher-Order Functions
// =============================================================================

// Identity
@id = λ&x. x

// Constant function
@const = λ&x. λu. x

// Function composition
@compose = λ&f. λ&g. λ&x. f(g(x))

// Flip arguments
@flip = λ&f. λ&x. λ&y. f(y)(x)

// Apply function
@apply = λ&f. λ&x. f(x)

// Curry a function (for pairs)
@curry = λ&f. λ&x. λ&y. f(#CON{x, #CON{y, #NIL}})

// Uncurry a function
@uncurry = λ&f. λ&pair.
  λ{#CON: λ&x. λ&rest.
    λ{#CON: λ&y. λ&u. f(x)(y)}(rest)
  }(pair)

// Partial application - bind first n arguments
@partial = λ&f. λ&first_arg.
  λ&x. f(first_arg)(x)

// Partial application with 2 fixed args
@partial2 = λ&f. λ&a1. λ&a2.
  λ&x. f(a1)(a2)(x)

// Partial application with 3 fixed args
@partial3 = λ&f. λ&a1. λ&a2. λ&a3.
  λ&x. f(a1)(a2)(a3)(x)

// =============================================================================
// Numeric Functions
// =============================================================================

// Absolute value
@abs = λ&n.
  !!&v = (λ{#Cst: λ&m. m})(n);
  λ{
    1: #Cst{(0 - v)}
    _: λ&u_. n
  }((v < 0))

// Sign
@sign = λ&n.
  !!&v = (λ{#Cst: λ&m. m})(n);
  λ{
    1: #Cst{(0 - 1)}
    _: λ&u_. λ{
      1: #Cst{1}
      _: λ&u_. #Cst{0}
    }((v > 0))
  }((v < 0))

// Minimum
@min = λ&a. λ&b.
  !!&av = (λ{#Cst: λ&n. n})(a);
  !!&bv = (λ{#Cst: λ&n. n})(b);
  λ{
    1: a
    _: λ&u_. b
  }((av < bv))

// Maximum
@max = λ&a. λ&b.
  !!&av = (λ{#Cst: λ&n. n})(a);
  !!&bv = (λ{#Cst: λ&n. n})(b);
  λ{
    1: a
    _: λ&u_. b
  }((av > bv))

// Sum of list
@sum = λ&xs.
  @foldl(λ&acc. λ&n.
    !!&a = (λ{#Cst: λ&m. m})(acc);
    !!&b = (λ{#Cst: λ&m. m})(n);
    #Cst{(a + b)}
  )(#Cst{0})(xs)

// Product of list
@product = λ&xs.
  @foldl(λ&acc. λ&n.
    !!&a = (λ{#Cst: λ&m. m})(acc);
    !!&b = (λ{#Cst: λ&m. m})(n);
    #Cst{(a * b)}
  )(#Cst{1})(xs)

// =============================================================================
// Boolean Functions
// =============================================================================

// All elements satisfy predicate
@all_p = λ&p. λ&xs.
  λ{
    #NIL: #True{}
    #CON: λ&h. λ&t.
      λ{
        #True: @all_p(p)(t)
        _: λ&u_. #Fals{}
      }(p(h))
  }(xs)

// Any element satisfies predicate
@any_p = λ&p. λ&xs.
  λ{
    #NIL: #Fals{}
    #CON: λ&h. λ&t.
      λ{
        #True: #True{}
        _: λ&u_. @any_p(p)(t)
      }(p(h))
  }(xs)

// None satisfy predicate
@none_p = λ&p. λ&xs.
  @omni_not(@any_p(p)(xs))

// =============================================================================
// Maybe/Option Operations
// =============================================================================

// Is value Nothing?
@nothing_p = λ&x.
  λ{
    #Noth: #True{}
    _: λ&u_. #Fals{}
  }(x)

// Map over Maybe
@maybe_map = λ&f. λ&m.
  λ{
    #Noth: #Noth{}
    _: λ&u_. f(m)
  }(m)

// Default for Nothing
@maybe_or = λ&default. λ&m.
  λ{
    #Noth: default
    _: λ&u_. m
  }(m)

// =============================================================================
// String Operations
// =============================================================================

// String length
@str_length = λ&s.
  @length(s)

// String concatenation
@str_concat = λ&a. λ&b.
  @append(a)(b)

// Character to string
@char_to_str = λ&c.
  #CON{c, #NIL}

// =============================================================================
// I/O Operations (via FFI)
// =============================================================================

// Print string
@print = λ&s. #FFI{#puts, #CON{s, #NIL}}

// Print newline
@newline = λu. #FFI{#putc, #CON{#Cst{10}, #NIL}}

// Print string with newline
@println = λ&s.
  !!&u = @print(s);
  @newline(#NIL)

// Print integer
@print_int = λ&n.
  // Convert int to string then print
  #FFI{#prti, #CON{n, #NIL}}

// Read character
@read_char = λu. #FFI{#getc, #NIL}

// =============================================================================
// Type Predicates
// =============================================================================

@int_p = λ&v.
  λ{
    #Cst: λ&u. #True{}
    _: λ&u_. #Fals{}
  }(v)

@float_p = λ&v.
  λ{
    #Fix: λ&u. λ&u. λ&u. #True{}
    _: λ&u_. #Fals{}
  }(v)

@char_p = λ&v.
  λ{
    #CHR: λ&u. #True{}
    _: λ&u_. #Fals{}
  }(v)

@symbol_p = λ&v.
  λ{
    #Sym: λ&u. #True{}
    _: λ&u_. #Fals{}
  }(v)

@list_p = λ&v.
  λ{
    #CON: λ&u. λ&u. #True{}
    #NIL: #True{}
    _: λ&u_. #Fals{}
  }(v)

@function_p = λ&v.
  λ{
    #Clo: λ&u. λ&u. #True{}
    #CloR: λ&u. λ&u. #True{}
    _: λ&u_. #Fals{}
  }(v)

@handle_p = λ&v.
  λ{
    #Hndl: λ&u. λ&u. #True{}
    _: λ&u_. #Fals{}
  }(v)

@bool_p = λ&v.
  λ{
    #True: #True{}
    #Fals: #True{}
    _: λ&u_. #Fals{}
  }(v)

// =============================================================================
// Error Handling
// =============================================================================

// Create error
@error = λ&msg.
  #Err{msg}

// Check if error
@error_p = λ&v.
  λ{
    #Err: λ&u. #True{}
    _: λ&u_. #Fals{}
  }(v)

// =============================================================================
// Comparison
// =============================================================================

// Compare two values (-1, 0, 1)
@compare = λ&a. λ&b.
  !!&av = (λ{#Cst: λ&n. n})(a);
  !!&bv = (λ{#Cst: λ&n. n})(b);
  λ{
    1: #Cst{(0 - 1)}
    _: λ&u_. λ{
      1: #Cst{1}
      _: λ&u_. #Cst{0}
    }((av > bv))
  }((av < bv))

// Equal?
@eq_p = λ&a. λ&b.
  λ{
    1: #True{}
    _: λ&u_. #Fals{}
  }(@omni_values_equal(a)(b))

// Not equal?
@neq_p = λ&a. λ&b.
  @omni_not(@eq_p(a)(b))

// Less than?
@lt_p = λ&a. λ&b. @omni_lt(a)(b)

// Greater than?
@gt_p = λ&a. λ&b. @omni_gt(a)(b)

// Less than or equal?
@le_p = λ&a. λ&b.
  @omni_or(@omni_lt(a)(b))(@omni_eql(a)(b))

// Greater than or equal?
@ge_p = λ&a. λ&b.
  @omni_or(@omni_gt(a)(b))(@omni_eql(a)(b))

// =============================================================================
// Additional Collection Functions
// =============================================================================

// Find first element matching predicate
// Polymorphic: List, Array, Iterator, Range
@find = λ&p. λ&xs.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t. λ{#True: h; _: λ&u_. @find(p)(t)}(p(h))
    #Arr: λ&len. λ&data. @find(p)(data)
    #Iter: λ&state. λ&next_fn. @find_iter(p)(xs)
    #Rang: λ&s. λ&e. λ&st. @find_iter(p)(xs)
  }(xs)

// Helper: find over iterator
@find_iter = λ&p. λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{#True: v; _: λ&u_. @find_iter(p)(rest)}(p(v))
    #None: #Noth{}
  }(stepped))(@iter_next(iter))

// Find index of first element matching predicate
// Polymorphic: List, Array, Iterator, Range
@find_index = λ&p. λ&xs.
  λ{
    #Arr: λ&len. λ&data. @find_index_list(p)(data)(0)
    #Iter: λ&state. λ&next_fn. @find_index_iter(p)(xs)(0)
    #Rang: λ&s. λ&e. λ&st. @find_index_iter(p)(xs)(0)
    _: λ&u_. @find_index_list(p)(xs)(0)
  }(xs)

@find_index_list = λ&p. λ&xs. λ&idx.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t. λ{#True: #Cst{idx}; _: λ&u_. @find_index_list(p)(t)((idx + 1))}(p(h))
  }(xs)

// Helper: find_index over iterator
@find_index_iter = λ&p. λ&iter. λ&idx.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{#True: #Cst{idx}; _: λ&u_. @find_index_iter(p)(rest)((idx + 1))}(p(v))
    #None: #Noth{}
  }(stepped))(@iter_next(iter))

// Partition sequence by predicate: returns (matching, not-matching)
// Polymorphic: List, Array, Iterator, Range
@partition = λ&p. λ&xs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&result.
        λ{#CON: λ&yes. λ&rest.
          λ{#CON: λ&no. λ&u_.
            #CON{#Arr{@list_length(yes), yes}, #CON{#Arr{@list_length(no), no}, #NIL}}
          }(rest)
        }(result)
      )(@partition_list(p)(data))
    _: λ&u_. @partition_list(p)(@to_list(xs))
  }(xs)

@partition_list = λ&p. λ&xs.
  @partition_helper(p)(xs)(#NIL)(#NIL)

@partition_helper = λ&p. λ&xs. λ&yes. λ&no.
  λ{
    #NIL: #CON{@reverse(yes), #CON{@reverse(no), #NIL}}
    #CON: λ&h. λ&t.
      λ{
        #True: @partition_helper(p)(t)(#CON{h, yes})(no)
        _: λ&u_. @partition_helper(p)(t)(yes)(#CON{h, no})
      }(p(h))
  }(xs)

// Take while predicate holds
@take_while = λ&p. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #True: #CON{h, @take_while(p)(t)}
        _: λ&u_. #NIL
      }(p(h))
  }(xs)

// Drop while predicate holds
@drop_while = λ&p. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #True: @drop_while(p)(t)
        _: λ&u_. xs
      }(p(h))
  }(xs)

// Split at position n: returns (take n, drop n)
@split_at = λ&n. λ&xs.
  #CON{@take(n)(xs), #CON{@drop(n)(xs), #NIL}}

// Span: split at first element not satisfying predicate
@span = λ&p. λ&xs.
  #CON{@take_while(p)(xs), #CON{@drop_while(p)(xs), #NIL}}

// Break: split at first element satisfying predicate
@break = λ&p. λ&xs.
  @span(λ&x. @omni_not(p(x)))(xs)

// Group consecutive equal elements
@group = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&spanned.
        λ{
          #CON: λ&same. λ&rest.
            λ{
              #CON: λ&remaining. λ&u.
                #CON{#CON{h, same}, @group(remaining)}
            }(rest)
        }(spanned)
      )(@span(λ&x. λ{1: #True{}; _: λ&u_. #Fals{}}(@omni_values_equal(x)(h)))(t))
  }(xs)

// Group by key function
@group_by = λ&f. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&key. (λ&spanned.
        λ{
          #CON: λ&same. λ&rest.
            λ{
              #CON: λ&remaining. λ&u.
                #CON{#CON{h, same}, @group_by(f)(remaining)}
            }(rest)
        }(spanned)
      )(@span(λ&x. λ{1: #True{}; _: λ&u_. #Fals{}}(@omni_values_equal(f(x))(key)))(t)))(f(h))
  }(xs)

// Intersperse element between sequence elements
// Polymorphic: List, Array, Iterator, Range
@intersperse = λ&sep. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. λ{#NIL: #CON{h, #NIL}; _: λ&u_. #CON{h, #CON{sep, @intersperse(sep)(t)}}}(t)
    #Arr: λ&len. λ&data.
      (λ&result. #Arr{@list_length(result), result})(@intersperse(sep)(data))
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{xs, #CON{sep, #CON{0, #NIL}}}, @intersperse_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{xs, #CON{sep, #CON{0, #NIL}}}, @intersperse_iter_next}
  }(xs)

// Helper: intersperse iterator
@intersperse_iter_next = λ&state.
  λ{#CON: λ&iter. λ&rest.
    λ{#CON: λ&sep. λ&flag_cell.
      λ{#CON: λ&need_sep. λ&u_.
        λ{
          0: (λ&stepped. λ{
              #Some: λ&v. λ&r. #Some{v, #CON{r, #CON{sep, #CON{1, #NIL}}}}
              #None: #None{}
            }(stepped))(@iter_next(iter))
          _: (λ&stepped. λ{
              #Some: λ&v. λ&r. #Some{sep, #CON{iter, #CON{sep, #CON{0, #NIL}}}}
              #None: #None{}
            }(stepped))(@iter_next(iter))
        }(need_sep)
      }(flag_cell)
    }(rest)
  }(state)

// Intercalate: intersperse then flatten
@intercalate = λ&sep. λ&xss.
  @concat(@intersperse(sep)(xss))

// Remove duplicates (keeps first occurrence)
// Polymorphic: List, Array, Iterator, Range
@nub = λ&xs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&result. #Arr{@list_length(result), result})(@nub_list(data))
    _: λ&u_. @nub_list(@to_list(xs))
  }(xs)

@nub_list = λ&xs.
  @nub_helper(xs)(#NIL)

@nub_helper = λ&xs. λ&seen.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #True: @nub_helper(t)(seen)
        _: λ&u_. #CON{h, @nub_helper(t)(#CON{h, seen})}
      }(@elem_p(h)(seen))
  }(xs)

// Remove duplicates by key function
// Polymorphic: List, Array, Iterator, Range
@nub_by = λ&f. λ&xs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&result. #Arr{@list_length(result), result})(@nub_by_list(f)(data))
    _: λ&u_. @nub_by_list(f)(@to_list(xs))
  }(xs)

@nub_by_list = λ&f. λ&xs.
  @nub_by_helper(f)(xs)(#NIL)

@nub_by_helper = λ&f. λ&xs. λ&seen.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&key.
        λ{
          #True: @nub_by_helper(f)(t)(seen)
          _: λ&u_. #CON{h, @nub_by_helper(f)(t)(#CON{key, seen})}
        }(@elem_p(key)(seen))
      )(f(h))
  }(xs)

// Merge sort (stable sort)
// Polymorphic: List, Array, Iterator, Range
@sort = λ&cmp. λ&xs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&sorted. #Arr{len, sorted})(@sort_list(cmp)(data))
    _: λ&u_. @sort_list(cmp)(@to_list(xs))
  }(xs)

// Helper: sort for lists
@sort_list = λ&cmp. λ&xs.
  !!&len = @length(xs);
  λ{
    #Cst: λ&n.
      λ{
        0: xs
        1: xs
        _: λ&u_. @merge_sorted(cmp)(@sort_list(cmp)(@take(#Cst{(n / 2)})(xs)))
                              (@sort_list(cmp)(@drop(#Cst{(n / 2)})(xs)))
      }(n)
  }(len)

// Merge two sorted lists
@merge_sorted = λ&cmp. λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&xh. λ&xt.
      λ{
        #NIL: xs
        #CON: λ&yh. λ&yt.
          (λ&c.
            λ{
              #Cst: λ&n.
                λ{
                  1: #CON{yh, @merge_sorted(cmp)(xs)(yt)}
                  _: λ&u_. #CON{xh, @merge_sorted(cmp)(xt)(ys)}
                }(n)
            }(c)
          )(cmp(xh)(yh))
      }(ys)
  }(xs)

// Sort by key function (ascending)
// Polymorphic: delegates to @sort
@sort_by = λ&f. λ&xs.
  @sort(λ&a. λ&b. @compare(f(a))(f(b)))(xs)

// Sort ascending (for numeric lists)
@sort_asc = λ&xs.
  @sort(@compare)(xs)

// Sort descending (for numeric lists)
@sort_desc = λ&xs.
  @sort(λ&a. λ&b. @compare(b)(a))(xs)

// Minimum of list by comparison
@minimum_by = λ&cmp. λ&xs.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      @foldl(λ&acc. λ&x.
        (λ&c.
          λ{
            #Cst: λ&n.
              λ{
                1: acc
                _: λ&u_. x
              }(n)
          }(c)
        )(cmp(x)(acc))
      )(h)(t)
  }(xs)

// Maximum of list by comparison
@maximum_by = λ&cmp. λ&xs.
  @minimum_by(λ&a. λ&b. cmp(b)(a))(xs)

// Minimum of numeric list
@minimum = λ&xs.
  @minimum_by(@compare)(xs)

// Maximum of numeric list
@maximum = λ&xs.
  @maximum_by(@compare)(xs)

// =============================================================================
// Additional Iterator Operations
// =============================================================================

// Enumerate: pair elements with indices
// Works on both lists and iterators
@enumerate = λ&xs.
  @zip(@iterate(λ&n. #Cst{(λ{#Cst: λ&m. m}(n) + 1)})(#Cst{0}))(xs)

// Chain: concatenate two sequences
@chain = λ&xs. λ&ys.
  λ{
    // Eager: list
    #NIL: ys
    #CON: λ&h. λ&t. @append(xs)(ys)
    // Lazy: iterator
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{xs, ys}, @chain_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{xs, ys}, @chain_iter_next}
  }(xs)

@chain_iter_next = λ&state.
  λ{#CON: λ&i1. λ&i2.
    λ{
      #Some: λ&v. λ&rest1.
        #Some{v, #CON{rest1, i2}}
      #None: @iter_next(i2)
    }(@iter_next(i1))
  }(state)

// For-each: apply function for side effects
// Works on both lists and iterators
@for_each = λ&f. λ&xs.
  λ{
    // Eager: list
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      (λ&u. @for_each(f)(t))(f(h))
    // Lazy: iterator
    _: λ&u_. @for_each_iter(f)(xs)
  }(xs)

@for_each_iter = λ&f. λ&iter.
  λ{
    #Some: λ&v. λ&rest.
      (λ&u. @for_each_iter(f)(rest))(f(v))
    #None: #Noth{}
  }(@iter_next(iter))

// Reduce: fold without initial value
@reduce = λ&f. λ&xs.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t. @foldl(f)(h)(t)
    _: λ{
      #Some: λ&v. λ&rest.
        @foldl(f)(v)(rest)
      #None: #Noth{}
    }(@iter_next(xs))
  }(xs)

// Count elements
@count = λ&xs.
  λ{
    #NIL: #Cst{0}
    #CON: λ&h. λ&t. @length(xs)
    _: λ&u_. @foldl(λ&acc. λu. #Cst{(λ{#Cst: λ&n. n}(acc) + 1)})(#Cst{0})(xs)
  }(xs)


// =============================================================================
// PARALLEL COMBINATORS (HVM4 Superposition)
// =============================================================================
//
// NOTE: OmniLisp is PARALLEL BY DEFAULT. The standard map, filter, etc. in
// collections.hvm4 already use parallel evaluation via strict bindings.
// These combinators provide EXPLICIT superposition control for advanced use.
//
// =============================================================================

// Fork two computations (explicit HVM4 SUP)
// Creates a superposition - both branches evaluate in parallel
@fork2 = λ&a. λ&b.
  &F{a, b}

// Non-deterministic choice from list (creates nested SUP)
// With collapse mode (-C), would enumerate all choices
@choice = λ&opts.
  λ{
    #NIL: #Err{#NoChoice}
    #CON: λ&h. λ&t.
      λ{
        #NIL: h
        _: λ&u_. &C{h, @choice(t)}
      }(t)
  }(opts)

// Parallel fold with explicit fork
// For associative operations, prefer @omni_reduce_tree in collections.hvm4
@par_fold = λ&f. λ&z. λ&xs.
  λ{
    #NIL: z
    #CON: λ&h. λ&t.
      λ{
        #NIL: f(z)(h)
        _: λ&u_. @fork2(f(z)(h))(@par_fold(f)(z)(t))
      }(t)
  }(xs)

// Amb - choose one value nondeterministically
// Alias for choice, useful for logic programming patterns
@amb = λ&opts. @choice(opts)

// Run both branches and return first success (non-#Err result)
@race = λ&a. λ&b.
  !!&result_a = a;
  !!&result_b = b;
  λ{
    #Err: λ&u_. result_b
    _: λ&u_. result_a
  }(result_a)

// =============================================================================
// Exploration System (Non-Deterministic Search via HVM4 Superposition)
// =============================================================================
//
// This provides a clean API for non-deterministic programming where:
// - @explore picks one value from a list (creates HVM4 superposition)
// - @reject marks a branch as a dead end (returns #Noth{})
// - @require rejects unless a condition is true
// - @exploring wraps a computation and filters rejected branches
//
// Under the hood, @explore uses HVM4's &{} superposition which evaluates
// all branches in parallel. With -C (collapse) mode, all valid results
// are enumerated.
//
// Example:
//   (exploring (fn []
//     (let x (explore '(1 2 3)))
//     (let y (explore '(1 2 3)))
//     (require (= (+ x y) 4))
//     (pair x y)))
//   ;; → superposition of (1,3), (2,2), (3,1)
//
// =============================================================================

// Nick-encoded effect tags for exploration
// expl = omni_nick("expl") = 1410060
// rejt = omni_nick("rejt") = 4739732
@nick_expl = 1410060
@nick_rejt = 4739732

// Explore: non-deterministic choice from a list
// Creates HVM4 superposition - all choices are explored in parallel
@explore = λ&choices. @choice(choices)

// Reject: mark current branch as dead end
// Returns #Noth{} which can be filtered out
@reject = #Noth{}

// Require: reject if condition is false
// (require cond) is shorthand for (if cond nothing (reject))
@require = λ&cond.
  λ{
    1: #True{}
    #True: #True{}
    _: λ&u_. #Noth{}
  }(cond)

// Require with custom failure value
@require_or = λ&cond. λ&fail_val.
  λ{
    1: #True{}
    #True: #True{}
    _: λ&u_. fail_val
  }(cond)

// Guard: return value only if condition is true, else reject
// Useful for filtering in exploration
@guard = λ&cond. λ&val.
  λ{
    1: val
    #True: val
    _: λ&u_. #Noth{}
  }(cond)

// Exploring: wrapper that filters out rejected (#Noth) branches
// For now, this is identity - filtering happens at collapse time
// or can be done manually with @filter_valid
@exploring = λ&body.
  body(0)  // 0 is unit argument

// Filter out #Noth values from a list (for post-processing exploration results)
@filter_valid = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #Noth: @filter_valid(t)
        _: λ&u_. #CON{h, @filter_valid(t)}
      }(h)
  }(xs)

// Explore with immediate filtering (returns first valid result or #Noth)
@explore_first = λ&choices. λ&pred.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      λ{
        1: h
        #True: h
        _: λ&u_. @explore_first(t)(pred)
      }(pred(h))
  }(choices)

// Explore all and collect valid results as a list
// Note: This eagerly evaluates all branches (no superposition)
@explore_all = λ&choices. λ&body.
  @filter_valid(@map(body)(choices))

// Cartesian exploration: explore all combinations of two lists
@explore2 = λ&xs. λ&ys. λ&body.
  @explore(@flat_map(λ&x.
    @map(λ&y. body(x)(y))(ys)
  )(xs))

// Explore with range (integer domain)
@explore_range = λ&lo. λ&hi.
  @explore(@range(lo)(hi))

// Generate range list for exploration
@range = λ&lo. λ&hi.
  λ{
    1: #NIL
    _: λ&u_. #CON{lo, @range((lo + 1))(hi)}
  }((lo >= hi))

// =============================================================================
// Effect-Based Exploration (Uses algebraic effects for more control)
// =============================================================================
//
// For integration with the effect system, use these handlers.
// The effect-based approach captures continuations, allowing:
// - Backtracking search
// - Collecting all solutions
// - Custom exploration strategies
//

// Effect handler for exploration with superposition
// Handles 'expl' effect by creating superposition of resumed branches
// Handles 'rejt' effect by returning nothing
@exploring_handler = λ&body.
  // This is the functional version - for effect-based, use handle/perform
  body(0)

// Helper: flat_map for exploration
@flat_map = λ&f. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      @list_append(f(h))(@flat_map(f)(t))
  }(xs)

// Helper: list append
@list_append = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @list_append(t)(ys)}
  }(xs)

// =============================================================================
// Constraint Solving Helpers
// =============================================================================

// All different: ensure all values in list are distinct
@all_different = λ&xs.
  λ{
    #NIL: #True{}
    #CON: λ&h. λ&t.
      λ{
        #True: @all_different(t)
        _: λ&u_. #Fals{}
      }(@not_member(h)(t))
  }(xs)

// Not member: check if x is not in list
@not_member = λ&x. λ&xs.
  λ{
    #NIL: #True{}
    #CON: λ&h. λ&t.
      λ{
        1: #Fals{}
        _: λ&u_. @not_member(x)(t)
      }((x == h))
  }(xs)

// Member check
@member = λ&x. λ&xs.
  λ{
    #NIL: #Fals{}
    #CON: λ&h. λ&t.
      λ{
        1: #True{}
        _: λ&u_. @member(x)(t)
      }((x == h))
  }(xs)

// =============================================================================
// Tree-Shaped Reductions (Parallel-Friendly)
// =============================================================================
//
// For associative operations, tree-shaped reduction enables parallelism:
//   Sequential: ((((a op b) op c) op d) op e)
//   Tree:       (a op b) || (c op d) → (ab op cd) || e → result
//
// HVM4's lazy evaluation + strict bindings naturally parallelize the tree.
//
// =============================================================================

// Reduce using tree structure (for associative operations)
// Parallel-friendly: left and right halves computed independently
@reduce_tree = λ&op. λ&xs.
  λ{
    #NIL: #Err{#NoElements}
    #CON: λ&h. λ&t.
      λ{
        #NIL: h  // Single element
        _: λ&u_. @reduce_tree_helper(op)(xs)
      }(t)
  }(xs)

// Helper: reduce non-empty list with tree structure
@reduce_tree_helper = λ&op. λ&xs.
  !!&len = @length(xs);
  λ{
    0: #Err{#NoElements}
    1: @head(xs)
    _: λ&u_. // Split, reduce halves in parallel, combine
      (λ&mid.
        (λ&left. (λ&right.
          // These two reductions can happen in parallel (independent bindings)
          (λ&left_result. (λ&right_result.
            op(left_result)(right_result)
          )(@reduce_tree_helper(op)(right)))(@reduce_tree_helper(op)(left))
        )(@drop(mid)(xs)))(@take(mid)(xs))
      )((len / 2))
  }(len)

// Reduce with default value (monoid-style)
@reduce_tree_with = λ&op. λ&default. λ&xs.
  λ{
    #NIL: default
    _: λ&u_. @reduce_tree(op)(xs)
  }(xs)

// Parallel sum using tree reduction
@sum_tree = λ&xs.
  @reduce_tree_with(λ&a. λ&b. (a + b))(0)(xs)

// Parallel product using tree reduction
@product_tree = λ&xs.
  @reduce_tree_with(λ&a. λ&b. (a * b))(1)(xs)

// Parallel maximum using tree reduction
@maximum_tree = λ&xs.
  @reduce_tree(λ&a. λ&b. λ{1: a; _: λ&u_. b}((a > b)))(xs)

// Parallel minimum using tree reduction
@minimum_tree = λ&xs.
  @reduce_tree(λ&a. λ&b. λ{1: a; _: λ&u_. b}((a < b)))(xs)

// Parallel all (logical AND) using tree reduction
@all_tree = λ&pred. λ&xs.
  @reduce_tree_with(λ&a. λ&b.
    λ{#Fals: #Fals{}; 0: #Fals{}; _: λ&u_. b}(a)
  )(#True{})(@map(pred)(xs))

// Parallel any (logical OR) using tree reduction
@any_tree = λ&pred. λ&xs.
  @reduce_tree_with(λ&a. λ&b.
    λ{#True: #True{}; 1: #True{}; _: λ&u_. b}(a)
  )(#Fals{})(@map(pred)(xs))

// Parallel string concatenation
@concat_tree = λ&strings.
  @reduce_tree_with(@string_append)(#NIL)(strings)

// Helper: string append (char list concat)
@string_append = λ&s1. λ&s2.
  λ{
    #NIL: s2
    #CON: λ&c. λ&rest. #CON{c, @string_append(rest)(s2)}
  }(s1)

// Length of list (for tree reduction splitting)
@length = λ&xs.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t. (1 + @length(t))
  }(xs)

// Take first n elements
@take = λ&n. λ&xs.
  λ{
    0: #NIL
    _: λ{
      #NIL: #NIL
      #CON: λ&h. λ&t. #CON{h, @take((n - 1))(t)}
    }(xs)
  }(n)

// Drop first n elements
@drop = λ&n. λ&xs.
  λ{
    0: xs
    _: λ{
      #NIL: #NIL
      #CON: λ&h. λ&t. @drop((n - 1))(t)
    }(xs)
  }(n)

// Head of list
@head = λ&xs.
  λ{
    #NIL: #Err{#EmptyList}
    #CON: λ&h. λ&t. h
  }(xs)

// Tail of list
@tail = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. t
  }(xs)
