// OmniLisp Runtime Library
// Core evaluator and support functions for OmniLisp semantics

// =============================================================================
// IMPORTANT: Internal Tag Conventions (READ THIS FIRST)
// =============================================================================
//
// OmniLisp uses HVM4 tagged values internally. These are IMPLEMENTATION DETAILS
// and should NOT be confused with user-facing language concepts.
//
// CRITICAL DISTINCTION - Empty List vs Nothing:
// ---------------------------------------------
// #NIL    = EMPTY LIST - The empty list value, written as () or '() in OmniLisp.
//           This is a valid list with zero elements. It is NOT "null" or "nil"
//           in the traditional Lisp sense. OmniLisp does NOT have a "nil" concept.
//           User-facing terminology: "empty list" or "empty"
//
// #Noth   = NOTHING - Represents absence of a value (like Option::None or Maybe Nothing).
//           Used for: missing values, failed lookups, uninitialized state.
//           User-facing terminology: "nothing"
//
// These are DISTINCT concepts:
//   - (empty? '())     => true   ; empty list check
//   - (nothing? '())   => false  ; '() is a value, not nothing
//   - (nothing? nothing) => true ; nothing is nothing
//
// Other Internal Tags:
// --------------------
// #Cst{n}       = Constant integer value n
// #CHR{c}       = Character with codepoint c
// #Sym{s}       = Symbol with nick-encoded value s
// #CON{h, t}    = Cons cell (list node) with head h and tail t
// #Clo{env, b}  = Closure with captured environment env and body b
// #CloR{env, b} = Recursive closure
// #True         = Boolean true
// #Fals         = Boolean false
// #Err{tag}     = Error with symbolic tag
// #Hndl{t, id}  = FFI handle of type t with identifier id
//
// List Representation:
// --------------------
// Lists are built from #CON and #NIL:
//   '(1 2 3) => #CON{#Cst{1}, #CON{#Cst{2}, #CON{#Cst{3}, #NIL}}}
//   '()      => #NIL
//
// =============================================================================

// =============================================================================
// Meta-Environment
// =============================================================================

// #MEnv{env, handlers, parent, level}
// - env: association list of bindings
// - handlers: stack of effect handlers
// - parent: parent meta-level (for reflective tower)
// - level: current meta-level number (0 = base)

@omni_menv_new = λ&env. λ&handlers. λ&parent. λ&level.
  #MEnv{env, handlers, parent, level}

@omni_menv_empty = #MEnv{#NIL, #NIL, #Noth, #Cst{0}}

// Create child meta-environment (for tower)
@omni_menv_child = λ&parent_menv.
  λ{
    #MEnv: λ&env. λ&handlers. λ&parent. λ&level.
      (λ&new_level. #MEnv{#NIL, #NIL, #LPar{parent_menv}, new_level})((λ{#Cst: λ&n. #Cst{(n + 1)}; _: λ&u_. #Cst{1}})(level))
    _: λ&u_. #MEnv{#NIL, #NIL, #LPar{parent_menv}, #Cst{1}}
  }(parent_menv)

// Get meta-level number
@omni_menv_level = λ&menv.
  λ{
    #MEnv: λ&env. λ&handlers. λ&parent. λ&level. level
    _: λ&u_. #Cst{0}
  }(menv)

// Force lazy parent
@omni_menv_force_parent = λ&p.
  λ{
    #LPar: λ&thunk. thunk
    #Noth: #Noth
    _: λ&u_. p
  }(p)

// Extend menv with new bindings (preserves handlers, parent, level)
@omni_menv_extend = λ&menv. λ&new_env.
  λ{
    #MEnv: λ&e. λ&h. λ&p. λ&l. #MEnv{new_env, h, p, l}
    _: λ&u_. #MEnv{new_env, #NIL, #Noth, #Cst{0}}
  }(menv)

// =============================================================================
// Environment Operations
// =============================================================================

// Get value at de Bruijn index
// Helper to avoid HVM4 closure capture bug in nested pattern matches
@omni_env_get_idx = λ&h. λ&t. λ&idx.
  λ{
    0: h
    _: λ&u_. @omni_env_get(t)((idx - 1))
  }(idx)

@omni_env_get = λ&env. λ&idx.
  λ{
    #NIL: #Err{#sym_unbound}
    #CON: λ&h. λ&t. @omni_env_get_idx(h)(t)(idx)
  }(env)

// Extend environment with new binding
@omni_env_extend = λ&env. λ&val.
  #CON{val, env}

// Extend with multiple bindings
@omni_env_extend_many = λ&env. λ&vals.
  λ{
    #NIL: env
    #CON: λ&h. λ&t.
      @omni_env_extend_many(#CON{h, env})(t)
  }(vals)

// =============================================================================
// Core Evaluator
// =============================================================================

@omni_eval = λ&menv. λ&exp.
  // Extract all menv components upfront to avoid HVM4 linear type issues
  !!&menv_parts = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. #E4{e, h, p, l}; _: λ&u_. #E4{#NIL, #NIL, #Noth, #Cst{0}}})(menv);
  !!&env = (λ{#E4: λ&e. λ&h. λ&p. λ&l. e})(menv_parts);
  !!&cur_handlers = (λ{#E4: λ&e. λ&h. λ&p. λ&l. h})(menv_parts);
  !!&cur_parent = (λ{#E4: λ&e. λ&h. λ&p. λ&l. p})(menv_parts);
  !!&cur_level = (λ{#E4: λ&e. λ&h. λ&p. λ&l. l})(menv_parts);
  λ{
    // Literal - wrap in #Cst for consistency
    #Lit: λ&n. #Cst{n}

    // Variable - lookup in environment
    #Var: λ&i. @omni_env_get(env)(i)

    // Lambda - create closure
    #Lam: λ&body. #Clo{env, body}

    // Recursive lambda - create recursive closure
    #LamR: λ&body. #CloR{env, body}

    // Generic function - removed explicit handler; falls through to _: which returns exp unchanged
    // (The explicit #GFun{name, methods} reconstruction was allocating a new term which caused issues)

    // Partial generic application - also falls through to default

    // Forward reference - lazy BOOK lookup for mutual recursion
    // #FRef{table_id} is generated by parser for function references.
    // We call book_get FFI (nick 7387220 = "BkGt") to get the AST from BOOK[table_id],
    // then evaluate it to get a closure.
    // IMPORTANT: Use strict binding (!!&) to force FFI execution BEFORE @omni_eval
    // sees the term - otherwise @omni_eval's #FFI handler intercepts it and returns
    // the FFI descriptor unchanged without executing the FFI.
    #FRef: λ&table_id.
      !!&ast = #FFI{7387220, #CON{table_id, #NIL}};
      @omni_eval(menv)(ast)

    // Application
    // Note: use lambda sequencing to avoid HVM4 parallel binding interference
    #App: λ&fn. λ&arg.
      (λ&fn_val.
        (λ&fv.
          (λ&arg_val. @omni_apply(menv)(fv)(arg_val))(@omni_eval(menv)(arg))
        )(fn_val)
      )(@omni_eval(menv)(fn))

    // Let binding (lazy - allows parallel evaluation)
    #Let: λ&val. λ&body.
      (λ&v. (λ&new_env. (λ&new_menv.
        @omni_eval(new_menv)(body)
      )(@omni_menv_extend(menv)(new_env)))(@omni_env_extend(env)(v)))(@omni_eval(menv)(val))

    // Let binding (strict - forces eager evaluation with ^:strict)
    #LetS: λ&val. λ&body.
      (λ&v. (λ&new_env. (λ&new_menv.
        @omni_eval(new_menv)(body)
      )(@omni_menv_extend(menv)(new_env)))(@omni_env_extend(env)(v)))(@omni_eval(menv)(val))

    // Named let (Scheme-style loop)
    // (let loop [i 0] [sum 0] body) → #NLet{name_nick, init_values, loop_body}
    // loop_body is already wrapped in lambdas for each parameter
    #NLet: λ&name_nick. λ&init_values. λ&loop_body.
      // Uses CloR (recursive closure) to avoid forward reference issues
      (λ&loop_closure. (λ&init_vals.
        @omni_apply_list(menv)(loop_closure)(init_vals)
      )(@omni_eval_list(menv)(init_values)))(#CloR{env, loop_body})

    // Named let (sequential) - same but evaluates inits sequentially
    #NLeS: λ&name_nick. λ&init_values. λ&loop_body.
      (λ&loop_closure. (λ&init_vals.
        @omni_apply_list(menv)(loop_closure)(init_vals)
      )(@omni_eval_list_seq(menv)(init_values)))(#CloR{env, loop_body})

    // Conditional
    #If: λ&cond. λ&then_. λ&else_.
      (λ&c.
        λ{
          #Cst: λ&n.
            λ{
              0: @omni_eval(menv)(else_)
              _: λ&u_. @omni_eval(menv)(then_)
            }(n)
          #True: @omni_eval(menv)(then_)
          #Fals: @omni_eval(menv)(else_)
          #Noth: @omni_eval(menv)(else_)
          _: λ&u_. @omni_eval(menv)(else_)
        }(c)
      )(@omni_eval(menv)(cond))

    // Sequence (do)
    #Do: λ&first. λ&rest.
      (λ&uu. @omni_eval(menv)(rest))(@omni_eval(menv)(first))

    // Pattern match
    #Mat: λ&scrut. λ&cases.
      (λ&s. @omni_match(menv)(s)(cases))(@omni_eval(menv)(scrut))

    // Perform effect - requires CPS mode (inside handle block)
    // In direct mode, this is an error - effects need continuation capture
    #Perf: λ&tag. λ&payload.
      #Err{#sym_perf_no_cps}

    // Handle effects - switches to CPS mode for continuation capture
    // (handle body (effect-tag (fn [payload resume] ...)) ...)
    #Hdle: λ&handlers. λ&body.
      // Install handlers and evaluate body in CPS mode
      // Use reconstructed menv to avoid linear type issues
      @omni_handle_cps(#MEnv{env, cur_handlers, cur_parent, cur_level})(handlers)(body)(#KId)

    // Reset (prompt) - enters CPS mode for delimited continuations
    #Prmt: λ&body.
      @omni_eval_cps(#MEnv{env, cur_handlers, cur_parent, cur_level})(#KId)(body)

    // Control - only valid inside reset (CPS mode)
    // In direct mode, this is an error
    #Ctrl: λ&k_idx. λ&body.
      #Err{#sym_ctrl_outside_reset}

    // FFI call
    #FFI: λ&name. λ&args.
      (λ&arg_vals. #FFI{name, arg_vals})(@omni_eval_list(menv)(args))

    // Type-of - get runtime type of value
    #TyOf: λ&val.
      @omni_infer_type_runtime(@omni_eval(menv)(val))

    // Cons
    #CON: λ&h. λ&t.
      #CON{@omni_eval(menv)(h), @omni_eval(menv)(t)}

    // Nil - already a value
    #NIL: #NIL

    // Module definition
    #Modl: λ&name. λ&exports. λ&body.
      @omni_eval_module(menv)(exp)

    // Import statement
    #Impt: λ&mod_name. λ&bindings.
      @omni_process_import(menv)(exp)

    // Arithmetic operations (use lambda sequencing to avoid parallel binding interference)
    #Add: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_add(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #Sub: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_sub(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #Mul: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_mul(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #Div: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_div(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #Mod: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_mod(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #Eql: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_eql(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #Lt: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_lt(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #Gt: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_gt(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    // Not equal: (a != b) -> not (a = b)
    #Neq: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_neq(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    // Less than or equal
    #Le: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_le(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    // Greater than or equal
    #Ge: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_ge(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    // Boolean AND with short-circuit evaluation
    #And: λ&a. λ&b.
      (λ&av.
        λ{
          #Fals: #Fals{}
          #Cst: λ&n. λ{0: #Fals{}; _: λ&u_. @omni_eval(menv)(b)}(n)
          _: λ&u_. @omni_eval(menv)(b)
        }(av)
      )(@omni_eval(menv)(a))

    // Boolean OR with short-circuit evaluation
    #Or: λ&a. λ&b.
      (λ&av.
        λ{
          #True: #True{}
          #Cst: λ&n. λ{0: @omni_eval(menv)(b); _: λ&u_. av}(n)
          #Fals: @omni_eval(menv)(b)
          _: λ&u_. av
        }(av)
      )(@omni_eval(menv)(a))

    // Boolean NOT
    #Not: λ&a.
      (λ&av. @omni_not(av))(@omni_eval(menv)(a))

    // Bitwise operations
    #BAnd: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_band(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #BOr: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_bor(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #BXor: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_bxor(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    #BNot: λ&a.
      (λ&av. @omni_bnot(av))(@omni_eval(menv)(a))

    #BShl: λ&a. λ&b.
      (λ&av. (λ&va. (λ&bv. @omni_bshift(va)(bv))(@omni_eval(menv)(b)))(av))(@omni_eval(menv)(a))

    // Array literal - evaluate elements and compute length
    #Arr: λ&elems.
      (λ&evaluated.
        #Arr{@omni_list_length(evaluated), evaluated}
      )(@omni_eval_list(menv)(elems))

    // Dict literal - evaluate all key-value pairs
    // Parser generates pairs as #CON{key, val} so entries is #CON{#CON{k1,v1}, #CON{#CON{k2,v2}, ...}}
    #Dict: λ&entries.
      #Dict{@omni_eval_dict_entries(menv)(entries)}

    // Dict put: #Put{dict, key, value} -> new dict with key=value added
    #Put: λ&dict. λ&key. λ&val.
      (λ&d. (λ&k. (λ&v.
        @omni_dict_put(d)(k)(v)
      )(@omni_eval(menv)(val)))(@omni_eval(menv)(key)))(@omni_eval(menv)(dict))

    // Debug expression: #Dbug{expr, msg} -> evaluate expr, return result
    #Dbug: λ&expr. λ&msg.
      @omni_eval(menv)(expr)

    // ==========================================================================
    // Collection Operations (dispatch to prelude functions)
    // ==========================================================================

    // Map: (map f xs) -> apply f to each element
    #Map: λ&f. λ&xs.
      (λ&fn. λ&coll.
        @omni_map_apply(menv)(fn)(coll)
      )(@omni_eval(menv)(f))(@omni_eval(menv)(xs))

    // Filter: (filter pred xs) -> keep elements where pred is truthy
    #Filt: λ&pred. λ&xs.
      (λ&fn. λ&coll.
        @omni_filter_apply(menv)(fn)(coll)
      )(@omni_eval(menv)(pred))(@omni_eval(menv)(xs))

    // Fold (left): (foldl f acc xs) -> sequential left fold
    #Fold: λ&f. λ&acc. λ&xs.
      (λ&fn. λ&init. λ&coll.
        @omni_foldl_apply(menv)(fn)(init)(coll)
      )(@omni_eval(menv)(f))(@omni_eval(menv)(acc))(@omni_eval(menv)(xs))

    // Foldr (right): (foldr f acc xs) -> parallel right fold
    #FldR: λ&f. λ&acc. λ&xs.
      (λ&fn. λ&init. λ&coll.
        @omni_foldr_apply(menv)(fn)(init)(coll)
      )(@omni_eval(menv)(f))(@omni_eval(menv)(acc))(@omni_eval(menv)(xs))

    // Length: (len xs) -> count elements
    #Len: λ&xs.
      (λ&coll. @omni_list_length(coll))(@omni_eval(menv)(xs))

    // Reverse: (reverse xs) -> reverse list
    #Rev: λ&xs.
      (λ&coll. @omni_reverse(coll))(@omni_eval(menv)(xs))

    // Concat: (concat xs ys) -> concatenate two lists
    #Conc: λ&xs. λ&ys.
      (λ&left. (λ&right. @omni_append(left)(right))(@omni_eval(menv)(ys)))(@omni_eval(menv)(xs))

    // Type check: (type? value {Type})
    #Tyck: λ&val. λ&type.
      (λ&v. @omni_type_check(v)(type))(@omni_eval(menv)(val))

    // First/Second of pair (also works on arrays)
    #Fst: λ&p.
      (λ&pv. λ{
        #CON: λ&h. λ&t. h
        #Arr: λ&len. λ&data. λ{#CON: λ&h. λ&t. h; _: λ&u_. #Noth{}}(data)
        _: λ&u_. #Noth{}
      }(pv))(@omni_eval(menv)(p))

    #Snd: λ&p.
      (λ&pv. λ{
        #CON: λ&h. λ&t. t
        #Arr: λ&len. λ&data. λ{#CON: λ&h. λ&t. t; _: λ&u_. #NIL}(data)
        _: λ&u_. #NIL
      }(pv))(@omni_eval(menv)(p))

    // ==========================================================================
    // Advanced Collection Operations
    // ==========================================================================

    // Array get: #AGe{arr, idx} -> element at index or nothing
    #AGe: λ&arr. λ&idx.
      (λ&a. (λ&i.
        λ{
          #Arr: λ&len. λ&data. @omni_list_nth(data)(i)
          #CON: λ&h. λ&t. @omni_list_nth(a)(i)
          _: λ&u_. #Noth{}
        }(a)
      )(@omni_eval(menv)(idx)))(@omni_eval(menv)(arr))

    // Array set: #ASe{arr, idx, val} -> new array with element at idx replaced
    #ASe: λ&arr. λ&idx. λ&val.
      (λ&a. (λ&i. (λ&v.
        λ{
          #Arr: λ&len. λ&data. #Arr{len, @omni_list_set(data)(i)(v)}
          #CON: λ&h. λ&t. @omni_list_set(a)(i)(v)
          _: λ&u_. a
        }(a)
      )(@omni_eval(menv)(val)))(@omni_eval(menv)(idx)))(@omni_eval(menv)(arr))

    // Array length: #ALe{arr} -> number of elements
    #ALe: λ&arr.
      (λ&a.
        λ{
          #Arr: λ&len. λ&data. #Cst{len}
          #CON: λ&h. λ&t. #Cst{@omni_list_length(a)}
          #NIL: #Cst{0}
          _: λ&u_. #Cst{0}
        }(a)
      )(@omni_eval(menv)(arr))

    // Slice: #Slce{coll, start, end} -> sub-sequence from start to end
    #Slce: λ&coll. λ&start. λ&end.
      (λ&c. (λ&s. (λ&e.
        @omni_slice(c)(s)(e)
      )(@omni_eval(menv)(end)))(@omni_eval(menv)(start)))(@omni_eval(menv)(coll))

    // Array last index: #ALix{arr} -> (length - 1)
    #ALix: λ&arr.
      (λ&a.
        λ{
          #Arr: λ&len. λ&data. #Cst{(len - 1)}
          #CON: λ&h. λ&t. #Cst{(@omni_list_length(a) - 1)}
          #NIL: #Cst{(0 - 1)}  // -1 for empty
          _: λ&u_. #Cst{(0 - 1)}
        }(a)
      )(@omni_eval(menv)(arr))

    // Array take: #ATak{arr, n} -> first n elements
    #ATak: λ&arr. λ&n.
      (λ&a. (λ&count.
        λ{
          #Arr: λ&len. λ&data.
            (λ&c. (λ&taken. #Arr{@omni_list_length(taken), taken})(@omni_take(#Cst{c})(data)))(@omni_unwrap_num(count))
          #CON: λ&h. λ&t.
            (λ&c. @omni_take(#Cst{c})(a))(@omni_unwrap_num(count))
          #NIL: #NIL
          _: λ&u_. #NIL
        }(a)
      )(@omni_eval(menv)(n)))(@omni_eval(menv)(arr))

    // Array drop: #ADrp{arr, n} -> all but first n elements
    #ADrp: λ&arr. λ&n.
      (λ&a. (λ&count.
        λ{
          #Arr: λ&len. λ&data.
            (λ&c. (λ&dropped. #Arr{(len - c), dropped})(@omni_drop(#Cst{c})(data)))(@omni_unwrap_num(count))
          #CON: λ&h. λ&t.
            (λ&c. @omni_drop(#Cst{c})(a))(@omni_unwrap_num(count))
          #NIL: #NIL
          _: λ&u_. #NIL
        }(a)
      )(@omni_eval(menv)(n)))(@omni_eval(menv)(arr))

    // Array split-at: #ASpA{arr, n} -> pair of (take n, drop n)
    #ASpA: λ&arr. λ&n.
      (λ&a. (λ&count.
        λ{
          #Arr: λ&len. λ&data.
            (λ&c.
              (λ&taken. (λ&dropped.
                #CON{#Arr{@omni_list_length(taken), taken}, #CON{#Arr{(len - c), dropped}, #NIL}}
              )(@omni_drop(#Cst{c})(data)))(@omni_take(#Cst{c})(data))
            )(@omni_unwrap_num(count))
          #CON: λ&h. λ&t.
            (λ&c.
              #CON{@omni_take(#Cst{c})(a), #CON{@omni_drop(#Cst{c})(a), #NIL}}
            )(@omni_unwrap_num(count))
          #NIL: #CON{#NIL, #CON{#NIL, #NIL}}
          _: λ&u_. #NIL
        }(a)
      )(@omni_eval(menv)(n)))(@omni_eval(menv)(arr))

    // Array sum: #ASum{arr} -> sum of all elements
    #ASum: λ&arr.
      (λ&a.
        λ{
          #Arr: λ&len. λ&data. @omni_list_sum(data)
          #CON: λ&h. λ&t. @omni_list_sum(a)
          #NIL: #Cst{0}
          _: λ&u_. #Cst{0}
        }(a)
      )(@omni_eval(menv)(arr))

    // Dict get: #DGe{dict, key} -> value or nothing
    #DGe: λ&dict. λ&key.
      (λ&d. (λ&k.
        λ{
          #Dict: λ&entries. @omni_dict_get(entries)(k)
          _: λ&u_. #Noth{}
        }(d)
      )(@omni_eval(menv)(key)))(@omni_eval(menv)(dict))

    // Dict set: #DSe{dict, key, val} -> new dict with key=val
    #DSe: λ&dict. λ&key. λ&val.
      (λ&d. (λ&k. (λ&v.
        @omni_dict_put(d)(k)(v)
      )(@omni_eval(menv)(val)))(@omni_eval(menv)(key)))(@omni_eval(menv)(dict))

    // Dissoc: #Diss{coll, key} -> new collection with key removed
    #Diss: λ&coll. λ&key.
      (λ&c. (λ&k.
        λ{
          #Dict: λ&entries. #Dict{@omni_dict_remove_key(entries)(k)}
          _: λ&u_. c
        }(c)
      )(@omni_eval(menv)(key)))(@omni_eval(menv)(coll))

    // Keys: #Keys{coll} -> list of keys
    #Keys: λ&coll.
      (λ&c.
        λ{
          #Dict: λ&entries. @omni_dict_keys(entries)
          _: λ&u_. #NIL
        }(c)
      )(@omni_eval(menv)(coll))

    // Vals: #Vals{coll} -> list of values
    #Vals: λ&coll.
      (λ&c.
        λ{
          #Dict: λ&entries. @omni_dict_vals(entries)
          _: λ&u_. #NIL
        }(c)
      )(@omni_eval(menv)(coll))

    // Dict merge: #DMrg{d1, d2} -> merged dict (d2 wins on conflict)
    #DMrg: λ&d1. λ&d2.
      (λ&dict1. (λ&dict2.
        λ{
          #Dict: λ&entries1.
            λ{
              #Dict: λ&entries2. #Dict{@omni_dict_merge(entries1)(entries2)}
              _: λ&u_. dict1
            }(dict2)
          _: λ&u_. dict2
        }(dict1)
      )(@omni_eval(menv)(d2)))(@omni_eval(menv)(d1))

    // Dict entries: #DEnt{dict} -> list of (key . value) pairs
    #DEnt: λ&dict.
      (λ&d.
        λ{
          #Dict: λ&entries. entries
          _: λ&u_. #NIL
        }(d)
      )(@omni_eval(menv)(dict))

    // Nth: #Nth{coll, n} -> element at index n
    #Nth: λ&coll. λ&n.
      (λ&c. (λ&idx.
        λ{
          #Arr: λ&len. λ&data. @omni_list_nth(data)(idx)
          #CON: λ&h. λ&t. @omni_list_nth(c)(idx)
          #NIL: #Noth{}
          _: λ&u_. #Noth{}
        }(c)
      )(@omni_eval(menv)(n)))(@omni_eval(menv)(coll))

    // Last: #Last{coll} -> last element or nothing
    #Last: λ&coll.
      (λ&c.
        λ{
          #Arr: λ&len. λ&data. @omni_list_last(data)
          #CON: λ&h. λ&t. @omni_list_last(c)
          #NIL: #Noth{}
          _: λ&u_. #Noth{}
        }(c)
      )(@omni_eval(menv)(coll))

    // Init: #Init{coll} -> all but last element
    #Init: λ&coll.
      (λ&c.
        λ{
          #Arr: λ&len. λ&data. #Arr{(len - 1), @omni_list_init(data)}
          #CON: λ&h. λ&t. @omni_list_init(c)
          #NIL: #NIL
          _: λ&u_. #NIL
        }(c)
      )(@omni_eval(menv)(coll))

    // Flatten: #Flat{nested} -> flattened list
    #Flat: λ&nested.
      (λ&n. @omni_flatten(n))(@omni_eval(menv)(nested))

    // Distinct: #Dist{coll} -> collection with duplicates removed
    #Dist: λ&coll.
      (λ&c. @omni_distinct(c))(@omni_eval(menv)(coll))

    // Partition: #Part{n, coll} -> list of groups of n elements
    #Part: λ&n. λ&coll.
      (λ&size. (λ&c. @omni_partition(size)(c))(@omni_eval(menv)(coll)))(@omni_eval(menv)(n))

    // Interleave: #Intl{colls} -> interleaved collection
    #Intl: λ&colls.
      (λ&cs. @omni_interleave(menv)(cs))(@omni_eval(menv)(colls))

    // Interpose: #Inps{sep, coll} -> collection with separator between elements
    #Inps: λ&sep. λ&coll.
      (λ&s. (λ&c. @omni_interpose(s)(c))(@omni_eval(menv)(coll)))(@omni_eval(menv)(sep))

    // Group-by: #GrBy{fn, coll} -> dict mapping keys to lists of elements
    #GrBy: λ&fn. λ&coll.
      (λ&f. (λ&c. @omni_group_by(menv)(f)(c))(@omni_eval(menv)(coll)))(@omni_eval(menv)(fn))

    // Frequencies: #Freq{coll} -> dict mapping elements to counts
    #Freq: λ&coll.
      (λ&c. @omni_frequencies(c))(@omni_eval(menv)(coll))

    // Sort: #Sort{list, cmp} -> sorted list using comparator
    #Sort: λ&list. λ&cmp.
      (λ&l. (λ&c.
        @omni_sort(menv)(l)(c)
      )(@omni_eval(menv)(cmp)))(@omni_eval(menv)(list))

    // ==========================================================================
    // Lazy Iterator Wrappers - evaluate to actual lists
    // ==========================================================================

    // Take: #ITkn{list, n} -> first n elements
    #ITkn: λ&xs. λ&n.
      (λ&list. (λ&count.
        @omni_take(count)(list)
      )(@omni_eval(menv)(n)))(@omni_eval(menv)(xs))

    // Drop: #IDrp{list, n} -> skip first n elements
    #IDrp: λ&xs. λ&n.
      (λ&list. (λ&count.
        @omni_drop(count)(list)
      )(@omni_eval(menv)(n)))(@omni_eval(menv)(xs))

    // Zip: #IZip{lists} -> zip multiple lists together
    #IZip: λ&lists.
      (λ&evaled.
        @omni_zip_lists(evaled)
      )(@omni_eval_list(menv)(lists))

    // Iterator map: #IMap{iter, fn} -> lazy mapped iterator
    #IMap: λ&iter. λ&fn.
      (λ&it. (λ&f.
        @omni_iter_map(menv)(it)(f)
      )(@omni_eval(menv)(fn)))(@omni_eval(menv)(iter))

    // Iterator filter: #IFlt{iter, pred} -> lazy filtered iterator
    #IFlt: λ&iter. λ&pred.
      (λ&it. (λ&p.
        @omni_iter_filter(menv)(it)(p)
      )(@omni_eval(menv)(pred)))(@omni_eval(menv)(iter))

    // Iterator take-while: #ITkW{iter, pred} -> take while predicate is true
    #ITkW: λ&iter. λ&pred.
      (λ&it. (λ&p.
        @omni_iter_take_while(menv)(it)(p)
      )(@omni_eval(menv)(pred)))(@omni_eval(menv)(iter))

    // Iterator drop-while: #IDrW{iter, pred} -> drop while predicate is true
    #IDrW: λ&iter. λ&pred.
      (λ&it. (λ&p.
        @omni_iter_drop_while(menv)(it)(p)
      )(@omni_eval(menv)(pred)))(@omni_eval(menv)(iter))

    // Iterator chain: #IChn{iters} -> chain multiple iterators
    #IChn: λ&iters.
      (λ&its.
        @omni_iter_chain_all(its)
      )(@omni_eval_list(menv)(iters))

    // Iterator enumerate: #IEnm{iter} -> add indices (0, val), (1, val), ...
    #IEnm: λ&iter.
      (λ&it.
        @omni_iter_enumerate(it)
      )(@omni_eval(menv)(iter))

    // Iterator flat-map: #IFMp{iter, fn} -> map then flatten
    #IFMp: λ&iter. λ&fn.
      (λ&it. (λ&f.
        @omni_iter_flat_map(menv)(it)(f)
      )(@omni_eval(menv)(fn)))(@omni_eval(menv)(iter))

    // Iterator fold: #IFld{iter, init, fn} -> fold/reduce
    #IFld: λ&iter. λ&init. λ&fn.
      (λ&it. (λ&i. (λ&f.
        @omni_iter_fold(menv)(it)(i)(f)
      )(@omni_eval(menv)(fn)))(@omni_eval(menv)(init)))(@omni_eval(menv)(iter))

    // Iterator find: #IFnd{iter, pred} -> find first matching element
    #IFnd: λ&iter. λ&pred.
      (λ&it. (λ&p.
        @omni_iter_find(menv)(it)(p)
      )(@omni_eval(menv)(pred)))(@omni_eval(menv)(iter))

    // Iterator any?: #IAny{iter, pred} -> true if any element matches
    #IAny: λ&iter. λ&pred.
      (λ&it. (λ&p.
        @omni_iter_any(menv)(it)(p)
      )(@omni_eval(menv)(pred)))(@omni_eval(menv)(iter))

    // Iterator all?: #IAll{iter, pred} -> true if all elements match
    #IAll: λ&iter. λ&pred.
      (λ&it. (λ&p.
        @omni_iter_all(menv)(it)(p)
      )(@omni_eval(menv)(pred)))(@omni_eval(menv)(iter))

    // Iterator nth: #INth{iter, n} -> get nth element
    #INth: λ&iter. λ&n.
      (λ&it. (λ&idx.
        @omni_iter_nth(it)(idx)
      )(@omni_eval(menv)(n)))(@omni_eval(menv)(iter))

    // ==========================================================================
    // Math Operations
    // ==========================================================================

    // Square root (integer)
    #Sqrt: λ&x.
      (λ&n. @omni_isqrt(n))(@omni_eval(menv)(x))

    // Power: base^exp
    #Pow: λ&base. λ&exp.
      (λ&b. (λ&e. @omni_ipow(b)(e))(@omni_eval(menv)(exp)))(@omni_eval(menv)(base))

    // Absolute value
    #MAbs: λ&x.
      (λ&n.
        λ{
          // Positive integer
          #Cst: λ&v. n
          // Fixed-point (possibly negative)
          #Fix: λ&hi. λ&lo. λ&scale.
            // If hi has sign bit set, it's negative
            λ{
              1: // Negative: negate and return as integer
                λ{
                  0: #Cst{(0 - lo)}  // If scale is 0 and hi would be 0, return as Cst
                  _: λ&u_. #Fix{(0 - hi - 1), (0 - lo), scale}
                }((scale + (0 - hi - 1)))  // Check if result is simple integer
              _: λ&u_. // Non-negative: return as integer if possible
                λ{
                  0: λ{
                      0: #Cst{lo}  // hi=0, scale=0 -> just return lo as Cst
                      _: λ&u_. n
                    }(hi)
                  _: λ&u_. n
                }(scale)
            }((hi >= 2147483648))  // Check if MSB is set (2^31)
          _: λ&u_. n
        }(n)
      )(@omni_eval(menv)(x))

    // Floor (round toward negative infinity)
    #Flor: λ&x.
      (λ&v.
        λ{
          #Cst: λ&n. v  // Integer: identity
          #Fix: λ&hi. λ&lo. λ&scale.
            // Get divisor based on scale (10^scale)
            (λ&divisor. (λ&isneg.
              λ{
                1: // Negative number
                  // lo is in two's complement, convert to positive absolute value
                  (λ&negval. (λ&intpart. (λ&rem.
                    // Floor: for negative, if remainder != 0, go more negative
                    // Return as #Fix with scale=0 to preserve negative sign
                    λ{
                      0: #Fix{4294967295, (4294967296 - intpart), 0}
                      _: λ&u_. #Fix{4294967295, (4294967296 - intpart - 1), 0}
                    }(rem)
                  )((negval % divisor)))((negval / divisor)))((4294967296 - lo))
                0: // Positive number: just divide (floor is easy)
                  #Cst{(lo / divisor)}
              }(isneg)
            )((hi >= 2147483648)))(@omni_pow10(scale))
          _: λ&u_. v
        }(v)
      )(@omni_eval(menv)(x))

    // Ceil (round toward positive infinity)
    #MCei: λ&x.
      (λ&v.
        λ{
          #Cst: λ&n. v  // Integer: identity
          #Fix: λ&hi. λ&lo. λ&scale.
            (λ&divisor. (λ&isneg.
              λ{
                1: // Negative number: ceil goes toward zero
                  (λ&negval. (λ&intpart.
                    λ{
                      0: #Cst{0}  // Result is zero
                      _: λ&u_. #Fix{4294967295, (4294967296 - intpart), 0}
                    }(intpart)
                  )((negval / divisor)))((4294967296 - lo))
                0: // Positive number: if remainder != 0, go up
                  (λ&intpart. (λ&rem.
                    λ{
                      0: #Cst{intpart}
                      _: λ&u_. #Cst{(intpart + 1)}
                    }(rem)
                  )((lo % divisor)))((lo / divisor))
              }(isneg)
            )((hi >= 2147483648)))(@omni_pow10(scale))
          _: λ&u_. v
        }(v)
      )(@omni_eval(menv)(x))

    // Round (round to nearest integer, half rounds up)
    #Rond: λ&x.
      (λ&v.
        λ{
          #Cst: λ&n. v  // Integer: identity
          #Fix: λ&hi. λ&lo. λ&scale.
            (λ&divisor. (λ&half. (λ&isneg.
              λ{
                1: // Negative number
                  (λ&negval. (λ&rem. (λ&intpart.
                    λ{
                      1: #Fix{4294967295, (4294967296 - intpart - 1), 0}  // Round away from zero
                      0: λ{
                           0: #Cst{0}
                           _: λ&u_. #Fix{4294967295, (4294967296 - intpart), 0}
                         }(intpart)
                    }((rem >= half))
                  )((negval / divisor)))((negval % divisor)))((4294967296 - lo))
                0: // Positive number
                  (λ&rem. (λ&intpart.
                    λ{
                      1: #Cst{(intpart + 1)}
                      0: #Cst{intpart}
                    }((rem >= half))
                  )((lo / divisor)))((lo % divisor))
              }(isneg)
            )((hi >= 2147483648)))((divisor / 2)))(@omni_pow10(scale))
          _: λ&u_. v
        }(v)
      )(@omni_eval(menv)(x))

    // Sign (returns -1, 0, or 1)
    #Sign: λ&x.
      (λ&v.
        λ{
          #Cst: λ&n.
            λ{
              0: #Cst{0}
              _: λ&u_.
                // Check if high bit is set (negative in two's complement)
                λ{
                  1: #Fix{4294967295, 4294967295, 0}  // -1 as #Fix
                  0: #Cst{1}
                }((n >= 2147483648))
            }(n)
          #Fix: λ&hi. λ&lo. λ&scale.
            λ{
              0: #Cst{0}  // lo = 0 means value is 0
              _: λ&u_.
                λ{
                  1: #Fix{4294967295, 4294967295, 0}  // -1 as #Fix
                  0: #Cst{1}
                }((hi >= 2147483648))
            }(lo)
          _: λ&u_. v
        }(v)
      )(@omni_eval(menv)(x))

    // Truncate (round toward zero)
    #Trnc: λ&x.
      (λ&v.
        λ{
          #Cst: λ&n. v  // Integer: identity
          #Fix: λ&hi. λ&lo. λ&scale.
            (λ&divisor. (λ&isneg.
              λ{
                1: // Negative number: truncate toward zero (like ceil for negative)
                  (λ&negval. (λ&intpart.
                    λ{
                      0: #Cst{0}  // Result is zero
                      _: λ&u_. #Fix{4294967295, (4294967296 - intpart), 0}
                    }(intpart)
                  )((negval / divisor)))((4294967296 - lo))
                0: // Positive number: truncate is just floor
                  #Cst{(lo / divisor)}
              }(isneg)
            )((hi >= 2147483648)))(@omni_pow10(scale))
          _: λ&u_. v
        }(v)
      )(@omni_eval(menv)(x))

    // Exp (e^x) - uses FFI for floating point
    #MExp: λ&x.
      (λ&n.
        #FFI{#sym_exp, #CON{n, #NIL}}
      )(@omni_eval(menv)(x))

    // Log (natural log) - uses FFI for floating point
    #MLog: λ&x.
      (λ&n.
        #FFI{#sym_log, #CON{n, #NIL}}
      )(@omni_eval(menv)(x))

    // Sin - uses FFI for floating point
    #MSin: λ&x.
      (λ&n.
        #FFI{#sym_sin, #CON{n, #NIL}}
      )(@omni_eval(menv)(x))

    // Cos - uses FFI for floating point
    #MCos: λ&x.
      (λ&n.
        #FFI{#sym_cos, #CON{n, #NIL}}
      )(@omni_eval(menv)(x))

    // Tan - uses FFI for floating point
    #MTan: λ&x.
      (λ&n.
        #FFI{#sym_tan, #CON{n, #NIL}}
      )(@omni_eval(menv)(x))

    // Random number (0 to n-1)
    #Rand: λ&n.
      (λ&max.
        #FFI{#sym_random, #CON{max, #NIL}}
      )(@omni_eval(menv)(n))

    // ==========================================================================
    // Type Operations
    // ==========================================================================

    // Make type variable: (make-type-var name) -> #TVar{name}
    #MkTV: λ&name.
      (λ&n. #TVar{n})(@omni_eval(menv)(name))

    // Make function type: (make-fun-type args ret) -> #TFun{args, ret}
    #MkFT: λ&args. λ&ret.
      (λ&a. (λ&r.
        #TFun{a, r}
      )(@omni_eval(menv)(ret)))(@omni_eval(menv)(args))

    // Make type application: (make-type-app base params) -> #TApp{base, params}
    #MkTA: λ&base. λ&params.
      (λ&b. (λ&p.
        #TApp{b, p}
      )(@omni_eval(menv)(params)))(@omni_eval(menv)(base))

    // Type constructor - pass through as value
    #TCon: λ&name. #TCon{name}

    // Type variable - pass through as value
    #TVar: λ&name. #TVar{name}

    // Unification result types - pass through as values
    #USuc: λ&subst. #USuc{subst}
    #UFal: λ&reason. #UFal{reason}

    // Unify types: (unify-types a b) -> #USuc{subst} or #UFal{reason}
    #TUnf: λ&type_a. λ&type_b.
      (λ&a. (λ&b.
        @unify(a)(b)
      )(@omni_eval(menv)(type_b)))(@omni_eval(menv)(type_a))

    // Check if unification succeeded: (success? result) -> bool
    #TSuc: λ&result.
      (λ&r.
        λ{
          #USuc: λ&subst_ignored. #True{}
          #UFal: λ&reason_ignored. #Fals{}
          _: #Fals{}
        }(r)
      )(@omni_eval(menv)(result))

    // Get substitution from unification result: (get-subst result) -> subst or nothing
    #TGSb: λ&result.
      (λ&r.
        λ{
          #USuc: λ&subst. subst
          #UFal: λ&reason_ignored. #Noth{}
          _: #Noth{}
        }(r)
      )(@omni_eval(menv)(result))

    // Apply substitution to type: (apply-subst subst type) -> type
    #TASb: λ&subst. λ&type.
      (λ&s. (λ&t.
        @apply_subst(s)(t)
      )(@omni_eval(menv)(type)))(@omni_eval(menv)(subst))

    // Type variable check: (type-var? type) -> bool
    #TVrP: λ&type.
      (λ&t.
        λ{
          #TVar: λ&name_ignored. #True{}
          _: #Fals{}
        }(t)
      )(@omni_eval(menv)(type))

    // Get type from type descriptor: (type-name tdsc) -> symbol
    #TNam: λ&type.
      (λ&t.
        λ{
          #TDsc: λ&name. λ&p_. λ&f_. name
          #TStr: λ&name. λ&p_. λ&f_. λ&m_. name
          #TEnm: λ&name. λ&v_. name
          #TUni: λ&name. λ&t_. name
          #TVar: λ&name. name
          _: #Noth{}
        }(t)
      )(@omni_eval(menv)(type))

    // ==========================================================================
    // String Operations
    // ==========================================================================

    // String length: (str-length str) -> int
    #SLen: λ&str.
      (λ&s. @omni_list_length(s))(@omni_eval(menv)(str))

    // String empty?: (str-empty? str) -> bool
    #SEmp: λ&str.
      (λ&s.
        λ{
          #NIL: #True{}
          #CON: λ&h. λ&t. #Fals{}
          _: λ&u_. #True{}
        }(s)
      )(@omni_eval(menv)(str))

    // String char-at: (str-char-at str idx) -> char or nothing
    #SChc: λ&str. λ&idx.
      (λ&s. (λ&i. @omni_str_char_at(s)(i))(@omni_eval(menv)(idx)))(@omni_eval(menv)(str))

    // String uppercase: (str-upper str) -> str
    #SUpR: λ&str.
      (λ&s. @omni_str_upper(s))(@omni_eval(menv)(str))

    // String lowercase: (str-lower str) -> str
    #SLwR: λ&str.
      (λ&s. @omni_str_lower(s))(@omni_eval(menv)(str))

    // String trim: (str-trim str) -> str (removes leading/trailing whitespace)
    #STrm: λ&str.
      (λ&s. @omni_str_trim(s))(@omni_eval(menv)(str))

    // String split: (str-split str delim) -> list of strings
    #SSpl: λ&str. λ&delim.
      (λ&s. (λ&d. @omni_str_split(s)(d))(@omni_eval(menv)(delim)))(@omni_eval(menv)(str))

    // String join: (str-join strs delim) -> str
    #SJoi: λ&strs. λ&delim.
      (λ&ss. (λ&d. @omni_str_join(ss)(d))(@omni_eval(menv)(delim)))(@omni_eval(menv)(strs))

    // String replace: (str-replace str old new) -> str
    #SRpl: λ&str. λ&old. λ&new.
      (λ&s. (λ&o. (λ&n.
        @omni_str_replace(s)(o)(n)
      )(@omni_eval(menv)(new)))(@omni_eval(menv)(old)))(@omni_eval(menv)(str))

    // String substring: (str-slice str start len) -> str
    #SSub: λ&str. λ&start. λ&len.
      (λ&s. (λ&st. (λ&ln.
        @omni_str_slice(s)(st)(ln)
      )(@omni_eval(menv)(len)))(@omni_eval(menv)(start)))(@omni_eval(menv)(str))

    // String index-of: (str-index-of str needle) -> int or nothing
    #SInd: λ&str. λ&needle.
      (λ&s. (λ&n. @omni_str_index_of(s)(n))(@omni_eval(menv)(needle)))(@omni_eval(menv)(str))

    // String starts-with?: (str-starts? str prefix) -> bool
    #SSta: λ&str. λ&prefix.
      (λ&s. (λ&p. @omni_str_starts_with(s)(p))(@omni_eval(menv)(prefix)))(@omni_eval(menv)(str))

    // String ends-with?: (str-ends? str suffix) -> bool
    #SEnd: λ&str. λ&suffix.
      (λ&s. (λ&x. @omni_str_ends_with(s)(x))(@omni_eval(menv)(suffix)))(@omni_eval(menv)(str))

    // String contains?: (str-contains? str needle) -> bool
    #SCnt: λ&str. λ&needle.
      (λ&s. (λ&n.
        λ{
          #Noth: #Fals{}
          #Cst: λ&i. #True{}
          _: λ&u_. #Fals{}
        }(@omni_str_index_of(s)(n))
      )(@omni_eval(menv)(needle)))(@omni_eval(menv)(str))

    // String reverse: (str-reverse str) -> str
    #SRev: λ&str.
      (λ&s. @omni_reverse(s))(@omni_eval(menv)(str))

    // String pad: (str-pad str len char side) -> str
    // side: 0 = left, 1 = right, 2 = both
    #SPad: λ&str. λ&len. λ&chr. λ&side.
      (λ&s. (λ&l. (λ&c. (λ&sd.
        @omni_str_pad(s)(l)(c)(sd)
      )(@omni_eval(menv)(side)))(@omni_eval(menv)(chr)))(@omni_eval(menv)(len)))(@omni_eval(menv)(str))

    // String capitalize: (str-capitalize str) -> str (first char upper, rest unchanged)
    #SCap: λ&str.
      (λ&s. @omni_str_capitalize(s))(@omni_eval(menv)(str))

    // String repeat: (str-repeat str n) -> str
    #SRep: λ&str. λ&n.
      (λ&s. (λ&count. @omni_str_repeat(s)(count))(@omni_eval(menv)(n)))(@omni_eval(menv)(str))

    // String compare: (str-compare str1 str2) -> -1, 0, or 1
    #SCmp: λ&str1. λ&str2.
      (λ&s1. (λ&s2. @omni_str_compare(s1)(s2))(@omni_eval(menv)(str2)))(@omni_eval(menv)(str1))

    // String to int: (str-to-int str) -> int or error
    #SToi: λ&str.
      (λ&s. @omni_str_to_int(s))(@omni_eval(menv)(str))

    // Int to string: (int-to-str n) -> str
    #ItoS: λ&n.
      (λ&v. @omni_int_to_str(v))(@omni_eval(menv)(n))

    // Char to int: (char->int char/str) -> code point of first char
    #CToi: λ&val.
      (λ&v. @omni_char_to_int(v))(@omni_eval(menv)(val))

    // Int to char: (int->char n) -> character as single-char string
    #ItoC: λ&n.
      (λ&v. @omni_int_to_char(v))(@omni_eval(menv)(n))

    // ==========================================================================
    // IO Operations
    // ==========================================================================

    // Print: (print val) -> outputs string, returns the result list
    #Prnt: λ&val.
      (λ&v. @omni_print_val(v))(@omni_eval(menv)(val))

    // Println: (println val) -> outputs string with newline, returns the result list
    #PrnL: λ&val.
      (λ&v. @omni_println_val(v))(@omni_eval(menv)(val))

    // Test putc: (test-putc char) -> returns what @omni_putc produces
    #TPut: λ&val.
      (λ&v. @omni_putc(v))(@omni_eval(menv)(val))

    // Debug match: (debug-match val) -> shows what pattern matches
    #DgMt: λ&val.
      (λ&v. @debug_print_match(v))(@omni_eval(menv)(val))

    // Read-line from stdin: (read-line) -> string
    #RdL2:
      @omni_read_line_stdin

    // Getenv: (getenv name) -> string or nothing
    #GtEv: λ&name.
      (λ&n. @omni_getenv(n))(@omni_eval(menv)(name))

    // Setenv: (setenv name value) -> bool
    #StEv: λ&name. λ&val.
      (λ&n. (λ&v. @omni_setenv(n)(v))(@omni_eval(menv)(val)))(@omni_eval(menv)(name))

    // Read file: (read-file path) -> string or error
    #RdFl: λ&path.
      (λ&p. @omni_read_file(p))(@omni_eval(menv)(path))

    // Write file: (write-file path content) -> bool or error
    #WrFl: λ&path. λ&content.
      (λ&p. (λ&c. @omni_write_file(p)(c))(@omni_eval(menv)(content)))(@omni_eval(menv)(path))

    // Append file: (append-file path content) -> bool or error
    #ApFl: λ&path. λ&content.
      (λ&p. (λ&c. @omni_append_file(p)(c))(@omni_eval(menv)(content)))(@omni_eval(menv)(path))

    // File exists?: (file-exists? path) -> bool
    #Exst: λ&path.
      (λ&p. @omni_file_exists(p))(@omni_eval(menv)(path))

    // Is directory?: (dir? path) -> bool
    #IsDr: λ&path.
      (λ&p. @omni_is_dir(p))(@omni_eval(menv)(path))

    // Make directory: (mkdir path) -> true or error
    #MkDr: λ&path.
      (λ&p. @omni_mkdir(p))(@omni_eval(menv)(path))

    // List directory: (list-dir path) -> list of filenames or error
    #LsDr: λ&path.
      (λ&p. @omni_list_dir(p))(@omni_eval(menv)(path))

    // Delete file: (delete-file path) -> true or error
    #DlFl: λ&path.
      (λ&p. @omni_delete_file(p))(@omni_eval(menv)(path))

    // Rename file: (rename-file from to) -> true or error
    #RnFl: λ&from. λ&to.
      (λ&f. (λ&t. @omni_rename_file(f)(t))(@omni_eval(menv)(to)))(@omni_eval(menv)(from))

    // Copy file: (copy-file from to) -> true or error
    #CpFl: λ&from. λ&to.
      (λ&f. (λ&t. @omni_copy_file(f)(t))(@omni_eval(menv)(to)))(@omni_eval(menv)(from))

    // ==========================================================================
    // DateTime Operations
    // ==========================================================================

    // DateTime now: (datetime-now) -> #Dt{year, month, day, hour, min, sec, nsec}
    #DtNw:
      @omni_dt_now(0)

    // DateTime year: (datetime-year dt) -> num
    #DtYr: λ&dt.
      (λ&d. @omni_dt_year(d))(@omni_eval(menv)(dt))

    // DateTime month: (datetime-month dt) -> num
    #DtMo: λ&dt.
      (λ&d. @omni_dt_month(d))(@omni_eval(menv)(dt))

    // DateTime day: (datetime-day dt) -> num
    #DtDy: λ&dt.
      (λ&d. @omni_dt_day(d))(@omni_eval(menv)(dt))

    // DateTime hour: (datetime-hour dt) -> num
    #DtHr: λ&dt.
      (λ&d. @omni_dt_hour(d))(@omni_eval(menv)(dt))

    // DateTime minute: (datetime-minute dt) -> num
    #DtMi: λ&dt.
      (λ&d. @omni_dt_minute(d))(@omni_eval(menv)(dt))

    // DateTime second: (datetime-second dt) -> num
    #DtSc: λ&dt.
      (λ&d. @omni_dt_second(d))(@omni_eval(menv)(dt))

    // DateTime to timestamp: (datetime->timestamp dt) -> num
    #DtTs: λ&dt.
      (λ&d. @omni_dt_to_timestamp(d))(@omni_eval(menv)(dt))

    // Timestamp to datetime: (timestamp->datetime ts) -> #Dt{...}
    #DtFt: λ&ts.
      (λ&t. @omni_dt_from_timestamp(t))(@omni_eval(menv)(ts))

    // DateTime add: (datetime-add dt secs) -> #Dt{...}
    #DtAd: λ&dt. λ&secs.
      (λ&d. (λ&s. @omni_dt_add(d)(s))(@omni_eval(menv)(secs)))(@omni_eval(menv)(dt))

    // DateTime subtract: (datetime-sub dt secs) -> #Dt{...}
    #DtSb: λ&dt. λ&secs.
      (λ&d. (λ&s. @omni_dt_sub(d)(s))(@omni_eval(menv)(secs)))(@omni_eval(menv)(dt))

    // DateTime diff: (datetime-diff dt1 dt2) -> num (seconds)
    #DtDf: λ&dt1. λ&dt2.
      (λ&d1. (λ&d2. @omni_dt_diff(d1)(d2))(@omni_eval(menv)(dt2)))(@omni_eval(menv)(dt1))

    // DateTime format: (datetime-format dt fmt) -> string
    #DtFm: λ&dt. λ&fmt.
      (λ&d. (λ&f. @omni_dt_format(d)(f))(@omni_eval(menv)(fmt)))(@omni_eval(menv)(dt))

    // DateTime parse: (datetime-parse str fmt) -> #Dt{...} or error
    #DtPr: λ&str. λ&fmt.
      (λ&s. (λ&f. @omni_dt_parse(s)(f))(@omni_eval(menv)(fmt)))(@omni_eval(menv)(str))

    // ==========================================================================
    // JSON Operations
    // ==========================================================================

    // JSON parse: (json-parse str) -> value or error
    // Parses JSON string into OmniLisp values:
    //   objects -> #Dict{entries}, arrays -> lists, strings -> char lists,
    //   numbers -> #Cst{n}, booleans -> #True/#Fals, null -> #Noth
    // Note: nick value 9610387 = omni_nick("JPrs")
    #JPrs: λ&str.
      (λ&s. #FFI{9610387, #CON{s, #NIL}})(@omni_eval(menv)(str))

    // JSON stringify: (json-stringify val) -> string
    // Converts OmniLisp values to JSON string
    // Note: nick value 9622802 = omni_nick("JStr")
    #JStr: λ&val.
      (λ&v. #FFI{9622802, #CON{v, #NIL}})(@omni_eval(menv)(val))

    // JSON type predicates
    // json-array?: (json-array? val) -> true if val is an array/list
    #JArr: λ&val.
      (λ&v.
        λ{
          #NIL: #True
          #CON: λ&h. λ&t. #True
          #Arr: λ&len. λ&data. #True
          _: λ&u_. #Fals
        }(v))(@omni_eval(menv)(val))

    // json-object?: (json-object? val) -> true if val is a dict/object
    #JObj: λ&val.
      (λ&v.
        λ{
          #Dict: λ&entries. #True
          _: λ&u_. #Fals
        }(v))(@omni_eval(menv)(val))

    // json-null: returns the JSON null value (nothing)
    #JNul:
      #Noth

    // ==========================================================================
    // Tower / Meta-programming Operations
    // ==========================================================================

    // EM (Eval Meta) - evaluate expression at parent meta-level
    #EM: λ&expr.
      (λ&parent_ref.
        (λ&parent.
          λ{
            #Noth: @omni_eval(menv)(expr)  // At base level, eval here
            _: λ&u_. @omni_eval(parent)(expr)
          }(parent)
        )(@omni_menv_force_parent(parent_ref))
      )((λ{#MEnv: λ&e. λ&h. λ&p. λ&l. p})(menv))

    // Lift - create staged code at next level
    #Lift: λ&expr.
      // Lifting creates a code representation staged for next level
      #Stag{#Cst{1}, expr}

    // Run - execute meta-level code
    #Run: λ&expr.
      (λ&code. @omni_reify(menv)(code))(@omni_eval(menv)(expr))

    // CLambda - compiled/staged lambda
    #CLam: λ&body.
      // Capture current environment for staged execution
      #CLam{env, body}

    // Stage - stage expression at specific level
    #Stag: λ&level. λ&expr.
      (λ&current_level.
        (λ&target.
          (λ&current.
            λ{
              1: @omni_eval(menv)(expr)  // target <= current: evaluate now
              _: λ&u_. #Stag{level, expr}      // target > current: keep staged
            }((target <= current))
          )((λ{#Cst: λ&n. n; _: λ&u_. 0})(current_level))
        )((λ{#Cst: λ&n. n; _: λ&u_. 0})(level))
      )(@omni_menv_level(menv))

    // Splice - splice code into current stage
    #Spli: λ&expr.
      // Evaluate the expression to get code, then return it
      @omni_eval(menv)(expr)

    // Reflect - turn value into code representation
    #Refl: λ&val_expr.
      (λ&val. @omni_reflect(val))(@omni_eval(menv)(val_expr))

    // Reify - turn code into value (execute)
    #Reif: λ&code_expr.
      (λ&code. @omni_reify(menv)(code))(@omni_eval(menv)(code_expr))

    // Meta-level - get current level number
    #MLvl: @omni_menv_level(menv)

    // ==========================================================================
    // Pipe Operator & Function Utilities
    // ==========================================================================

    // Pipe operator: (|> value (f a) (g b)) → (g (f value a) b)
    // Threads value through each form as the first argument
    #Pipe: λ&init. λ&forms.
      (λ&init_val. @omni_pipe_thread(menv)(init_val)(forms))(@omni_eval(menv)(init))

    // Apply: apply function to list of arguments
    // (apply f '(a b c)) → (f a b c)
    #Appl: λ&fn_expr. λ&args_expr.
      (λ&fn.
        (λ&args. @omni_apply_list(menv)(fn)(args))(@omni_eval(menv)(args_expr))
      )(@omni_eval(menv)(fn_expr))

    // ==========================================================================
    // Control Flow (all desugar to match per philosophy)
    // ==========================================================================

    // When: (when test body) → (match test [false nothing] [_ body])
    #When: λ&test. λ&body.
      (λ&t.
        λ{
          #Fals: #Noth{}
          #Cst: λ&n. λ{
            0: #Noth{}
            _: λ&u_. @omni_eval(menv)(body)
          }(n)
          _: λ&u_. @omni_eval(menv)(body)
        }(t)
      )(@omni_eval(menv)(test))

    // Unless: (unless test body) → (match test [true nothing] [_ body])
    #Unls: λ&test. λ&body.
      (λ&t.
        λ{
          #True: #Noth{}
          #Cst: λ&n. λ{
            0: @omni_eval(menv)(body)
            _: λ&u_. #Noth{}
          }(n)
          #Fals: @omni_eval(menv)(body)
          _: λ&u_. #Noth{}
        }(t)
      )(@omni_eval(menv)(test))

    // Cond: multi-way conditional
    // (cond [test1 result1] [test2 result2] ...)
    #Cond: λ&clauses.
      @omni_eval_cond(menv)(clauses)

    // ==========================================================================
    // Path Access (functional)
    // ==========================================================================

    // Get: (get coll key default?) → value or default or nothing
    // u_coll, u_key, u_default are unevaluated AST expressions
    #Get: λ&u_coll. λ&u_key. λ&u_default.
      (λ&coll. λ&key.
        (λ&result.
          λ{
            #Noth: @omni_eval(menv)(u_default)
            _: λ&u_. result
          }(result)
        )(@omni_get(coll)(key))
      )(@omni_eval(menv)(u_coll))(@omni_eval(menv)(u_key))

    // GetIn: (get-in coll path) → nested value or nothing
    #GtIn: λ&coll_expr. λ&path_expr.
      (λ&coll.
        (λ&path. @omni_get_in(coll)(path))(@omni_eval(menv)(path_expr))
      )(@omni_eval(menv)(coll_expr))

    // AssocIn: (assoc-in coll path val) → new coll with nested update
    #AsIn: λ&coll_expr. λ&path_expr. λ&val_expr.
      (λ&coll.
        (λ&path.
          (λ&val. @omni_assoc_in(coll)(path)(val))(@omni_eval(menv)(val_expr))
        )(@omni_eval(menv)(path_expr))
      )(@omni_eval(menv)(coll_expr))

    // Update: (update coll key fn) → new coll with (fn (get coll key))
    #Updt: λ&coll_expr. λ&key_expr. λ&fn_expr.
      (λ&coll.
        (λ&key.
          (λ&fn.
            (λ&old_val.
              (λ&new_val. @omni_assoc(coll)(key)(new_val))(@omni_apply(menv)(fn)(old_val))
            )(@omni_get(coll)(key))
          )(@omni_eval(menv)(fn_expr))
        )(@omni_eval(menv)(key_expr))
      )(@omni_eval(menv)(coll_expr))

    // UpdateIn: (update-in coll path fn) → new coll with nested update
    #UpdI: λ&coll_expr. λ&path_expr. λ&fn_expr.
      (λ&coll.
        (λ&path.
          (λ&fn.
            (λ&old_val.
              (λ&new_val. @omni_assoc_in(coll)(path)(new_val))(@omni_apply(menv)(fn)(old_val))
            )(@omni_get_in(coll)(path))
          )(@omni_eval(menv)(fn_expr))
        )(@omni_eval(menv)(path_expr))
      )(@omni_eval(menv)(coll_expr))

    // ==========================================================================
    // Quasiquote Evaluation
    // ==========================================================================

    // Quasiquote: evaluate unquotes, return quoted structure
    #QQ: λ&expr.
      @omni_eval_qq(menv)(expr)(#Cst{0})

    // Unquote: should only appear inside quasiquote
    #UQ: λ&expr.
      #Err{#sym_unquote_outside_qq}

    // Unquote-splicing: should only appear inside quasiquote
    #UQS: λ&expr.
      #Err{#sym_unquote_splice_outside_qq}

    // Code wrapper: unwrap and evaluate the contents
    #Cod: λ&inner.
      @omni_eval(menv)(inner)

    // Curry wrapper: OmniLisp functions are already curried, so just return the function
    // This makes (curry f) equivalent to f at runtime
    #Cury: λ&fn. λ&arity.
      @omni_eval(menv)(fn)

    // Flip wrapper: swap first two arguments
    // (flip f) returns a function that when called with x, returns another function
    // waiting for y, then calls f(y)(x)
    #Flip: λ&fn.
      (λ&evaled_fn.
        λ&x. λ&y. @omni_apply(menv)(@omni_apply(menv)(evaled_fn)(y))(x)
      )(@omni_eval(menv)(fn))

    // Default: return as-is
    _: λ&u_. exp
  }(exp)

// =============================================================================
// DEBUG: Test pattern matching on GFun
// =============================================================================
@omni_test_gfun_match = λ&x.
  λ{
    #GFun: λ&name. λ&methods. 1000
    #Clo: λ&env. λ&body. 1001
    _: λ&u_. 9999
  }(x)

// =============================================================================
// Function Application
// =============================================================================

// IMPORTANT: Uses helper to avoid HVM4 closure capture bug where outer lambda
// parameters (menv, arg) are not properly captured inside pattern match arms
@omni_apply = λ&menv. λ&fn. λ&arg.
  // Force fn to WNF before pattern matching (needed for FFI-returned values)
  !!&fn_forced = fn;
  @omni_apply_impl(menv)(arg)(fn_forced)

// Helper - takes menv and arg BEFORE the fn pattern match for proper capture
@omni_apply_impl = λ&m. λ&a. λ&fn.
  λ{
    // Macro - expand rather than apply
    #MSyn: λ&name. λ&patterns.
      // Macros receive unevaluated arguments as a list
      // For single arg, wrap in list
      @omni_macro_expand(m)(fn)(#CON{a, #NIL})

    // Closure
    #Clo: λ&env. λ&body.
      (λ&new_env.
        (λ&new_menv. @omni_eval(new_menv)(body))(@omni_menv_extend(m)(new_env))
      )(@omni_env_extend(env)(a))

    // Recursive closure
    #CloR: λ&env. λ&body.
      (λ&self.
        (λ&env1.
          (λ&new_env.
            (λ&new_menv. @omni_eval(new_menv)(body))(@omni_menv_extend(m)(new_env))
          )(@omni_env_extend(env1)(a))
        )(@omni_env_extend(env)(self))
      )(#CloR{env, body})

    // Lambda AST node (from BOOK reference) - convert to closure and apply
    // When a define stores #Lam{body} in BOOK, we need to handle it like a closure
    #Lam: λ&body.
      (λ&new_env.
        (λ&new_menv. @omni_eval(new_menv)(body))(@omni_menv_extend(m)(new_env))
      )(@omni_env_extend(#NIL)(a))

    // Recursive lambda AST node (from BOOK reference)
    #LamR: λ&body.
      (λ&self.
        (λ&new_env.
          (λ&new_menv. @omni_eval(new_menv)(body))(@omni_menv_extend(m)(new_env))
        )(@omni_env_extend(@omni_env_extend(#NIL)(self))(a))
      )(#LamR{body})

    // Generic function (multiple dispatch)
    #GFun: λ&name. λ&methods.
      (λ&arity.
        λ{
          1: // Single arg - dispatch immediately
            @omni_dispatch_gfun(m)(name)(methods)(#CON{a, #NIL})
          _: λ&u_. // Multiple args - create partial application
            #GPrt{name, methods, #CON{a, #NIL}, (arity - 1)}
        }(arity)
      )(@omni_gfun_arity(methods))

    // Generic partial application (collecting args)
    #GPrt: λ&name. λ&methods. λ&args. λ&remaining.
      (λ&new_args.
        λ{
          1: // Final arg - dispatch
            @omni_dispatch_gfun(m)(name)(methods)(new_args)
          _: λ&u_. // More args needed
            #GPrt{name, methods, new_args, (remaining - 1)}
        }(remaining)
      )(@omni_append(args)(#CON{a, #NIL}))

    // Metadata wrappers - unwrap and apply inner function
    #Assc: λ&inner. @omni_apply(m)(inner)(a)
    #Pure: λ&inner. @omni_apply(m)(inner)(a)
    #Spec: λ&inner. @omni_apply(m)(inner)(a)
    #Strc: λ&inner. @omni_apply(m)(inner)(a)

    // Curry wrapper - apply inner function to argument
    // #Cury{fn, arity} wraps a function to enable curried calling
    #Cury: λ&fn. λ&arity. @omni_apply(m)(fn)(a)

    // Flip wrapper - swap first two arguments
    // #Flip{fn} when applied to x returns a function waiting for y, then calls fn(y)(x)
    #Flip: λ&fn. #FlipPartial{fn, a}

    // Flip partial application - has first arg, waiting for second
    #FlipPartial: λ&fn. λ&first_arg.
      @omni_apply(m)(@omni_apply(m)(fn)(a))(first_arg)

    // Captured continuation (lambda-wrapped) - invoke it directly
    // Use strict binding to force evaluation
    #Kont: λ&k. !!&res = (k(a)); res

    // Captured continuation (defunctionalized) - invoke via @omni_apply_k
    #KontD: λ&stored_k. @omni_apply_k(stored_k)(a)

    // Native HVM4 lambda (compiled code)
    _: λ&u_. fn(a)
  }(fn)

// Get arity of generic function from first method's signature
@omni_gfun_arity = λ&methods.
  λ{
    #NIL: 0
    #CON: λ&meth. λ&ux.
      λ{
        #Meth: λ&name. λ&sig. λ&impl. λ&constraints. λ&effects.
          @omni_list_length(sig)
        _: λ&u_. 0
      }(meth)
  }(methods)

// Create a generic function from name and methods list
// Returns: #GFun{name, methods}
@omni_make_generic = λ&name. λ&methods.
  #GFun{name, methods}

// Dispatch generic function with collected arguments
@omni_dispatch_gfun = λ&menv. λ&name. λ&methods. λ&args.
  !!&arg_types = @omni_infer_arg_types_runtime(args);
  !!&best = @omni_find_best_method(name)(arg_types)(methods);
  λ{
    #Noth: #Err{#sym_NoMethod, #CON{name, args}}
    #MAmb: λ&aname. λ&sig_a. λ&sig_b.
      // Ambiguous dispatch - report both conflicting signatures
      #Err{#sym_AmbiguousMethod, #CON{aname, #CON{sig_a, #CON{sig_b, #CON{arg_types, #NIL}}}}}
    #Meth: λ&mname. λ&msig. λ&impl. λ&constraints. λ&effects.
      // Evaluate the implementation (AST) to get a closure, then apply to args
      (λ&impl_closure. @omni_apply_curried(menv)(impl_closure)(args))(@omni_eval(menv)(impl))
    _: λ&u_. #Err{#sym_DispatchFailed, best}
  }(best)

// Apply curried function to list of arguments
@omni_apply_curried = λ&menv. λ&fn. λ&args.
  λ{
    #NIL: fn
    #CON: λ&h. λ&t.
      (λ&applied. @omni_apply_curried(menv)(applied)(t))(@omni_apply(menv)(fn)(h))
  }(args)

// Infer runtime types of argument list
@omni_infer_arg_types_runtime = λ&args.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{@omni_infer_type_runtime(h), @omni_infer_arg_types_runtime(t)}
  }(args)

// Check if a list is a string (contains only #CHR elements)
@omni_is_string_list = λ&lst.
  λ{
    #NIL: #True{}
    #CON: λ&h. λ&t.
      λ{
        #CHR: λ&c. @omni_is_string_list(t)
        _: λ&u_. #Fals{}
      }(h)
    _: λ&u_. #Fals{}
  }(lst)

// Infer runtime type of a value (returns type descriptor)
@omni_infer_type_runtime = λ&val.
  λ{
    #Cst: λ&n. @type_Int
    #Fix: λ&hi. λ&lo. λ&scale. @type_Float
    #CHR: λ&c. @type_Char
    #Sym: λ&s. @type_Symbol
    #CON: λ&h. λ&t.
      // Check if head is a CHR - if so, might be a string
      λ{
        #CHR: λ&c.
          // Head is CHR, check if rest is also all CHRs
          λ{
            #True: @type_String
            #Fals: @type_List
          }(@omni_is_string_list(t))
        _: λ&u_. @type_List
      }(h)
    #NIL: @type_List
    #Arr: λ&len. λ&data. @type_Array
    #Dict: λ&entries. @type_Dict
    #Iter: λ&state. λ&next_fn. @type_Iterator
    #Rang: λ&s. λ&e. λ&st. @type_Range
    #Clo: λ&e. λ&b. @type_Function
    #CloR: λ&e. λ&b. @type_Function
    #Hndl: λ&idx. λ&gen. @type_Handle
    #True: @type_Bool
    #Fals: @type_Bool
    #Noth: @type_Nothing
    _: λ&u_. @type_Any
  }(val)

// Find best matching method for argument types
// Returns: #Meth{...} on success, #Noth{} on no match,
//          #MAmb{name, msig, rsig} on ambiguity
@omni_find_best_method = λ&name. λ&arg_types. λ&methods.
  λ{
    #NIL: #Noth{}
    #CON: λ&meth. λ&rest.
      λ{
        #Meth: λ&mname. λ&msig. λ&mimpl. λ&mconstr. λ&meff.
          (λ&matches.
            λ{
              #True:
                // Found a match - check if rest has better match
                (λ&rest_match.
                  λ{
                    #Noth: meth
                    #MAmb: λ&an. λ&as. λ&rs. rest_match  // Propagate ambiguity
                    #Meth: λ&rn. λ&rsig. λ&ri. λ&rc. λ&re.
                      // Compare specificity with proper ambiguity detection
                      λ{
                        #ASpec: meth       // msig is strictly more specific
                        #BSpec: rest_match // rsig is strictly more specific
                        #Equal: meth       // Same specificity - use first defined
                        #Ambig: #MAmb{name, msig, rsig}  // Ambiguous!
                        _: λ&u_. rest_match      // Fallback
                      }(@omni_compare_specificity(msig)(rsig))
                    _: λ&u_. meth
                  }(rest_match)
                )(@omni_find_best_method(name)(arg_types)(rest))
              _: λ&u_. @omni_find_best_method(name)(arg_types)(rest)
            }(matches)
          )(@omni_sig_matches(arg_types)(msig))
        _: λ&u_. @omni_find_best_method(name)(arg_types)(rest)
      }(meth)
  }(methods)

// Check if argument types match signature
@omni_sig_matches = λ&arg_types. λ&sig.
  λ{
    #NIL:
      λ{
        #NIL: #True{}
        _: λ&u_. #Fals{}
      }(sig)
    #CON: λ&ah. λ&at.
      λ{
        #NIL: #Fals{}
        #CON: λ&sh. λ&st.
          λ{
            #True: @omni_sig_matches(at)(st)
            _: λ&u_. #Fals{}
          }(@omni_subtype(ah)(sh))
      }(sig)
  }(arg_types)

// Helper to convert numeric comparison (1/0) to #True/#Fals
@omni_num_to_bool = λ&n.
  λ{1: #True{}; _: λ&u_. #Fals{}}(n)

// Check if type A is subtype of type B
@omni_subtype = λ&type_a. λ&type_b.
  λ{
    #TDsc: λ&name_a. λ&parent_a. λ&fields_a.
      // Type descriptor - check against type constructor or other descriptor
      λ{
        #TCon: λ&name_b.
          // Check if type descriptor's name matches type constructor's name
          @omni_num_to_bool((name_a == name_b))
        #TDsc: λ&name_b. λ&pb. λ&fb.
          @omni_num_to_bool((name_a == name_b))
        #Sym: λ&name_b. @omni_num_to_bool((name_a == name_b))
        _: λ&u_. #Fals{}
      }(type_b)
    // type_a is a symbol - compare with descriptor name or symbol
    #Sym: λ&name_a.
      λ{
        #TDsc: λ&name_b. λ&ux. λ&ux. @omni_num_to_bool((name_a == name_b))
        #Sym: λ&name_b. @omni_num_to_bool((name_a == name_b))
        #TCon: λ&name_b. @omni_num_to_bool((name_a == name_b))
        _: λ&u_. #Fals{}
      }(type_b)
    // type_a is a type constructor
    #TCon: λ&name_a.
      λ{
        #TDsc: λ&name_b. λ&ux. λ&ux. @omni_num_to_bool((name_a == name_b))
        #Sym: λ&name_b. @omni_num_to_bool((name_a == name_b))
        #TCon: λ&name_b. @omni_num_to_bool((name_a == name_b))
        _: λ&u_. #Fals{}
      }(type_b)
    _: λ&u_. #Fals{}
  }(type_a)

// Check if sig_a is more specific than sig_b
@omni_more_specific = λ&sig_a. λ&sig_b.
  λ{
    #NIL: #Fals{}
    #CON: λ&ah. λ&at.
      λ{
        #NIL: #Fals{}
        #CON: λ&bh. λ&bt.
          λ{
            #True: #True{}  // ah is subtype of bh - more specific
            _: λ&u_. @omni_more_specific(at)(bt)
          }(@omni_subtype(ah)(bh))
      }(sig_b)
  }(sig_a)

// Compare specificity of two signatures - returns:
// #ASpec{} - sig_a is strictly more specific
// #BSpec{} - sig_b is strictly more specific
// #Ambig{} - Neither is more specific (ambiguous)
// #Equal{} - Same specificity (same types)
@omni_compare_specificity = λ&sig_a. λ&sig_b.
  @omni_compare_spec_acc(sig_a)(sig_b)(#Cst{0})(#Cst{0})

// Accumulator-based comparison: count positions where A/B is more specific
// a_wins: count of positions where A is strictly more specific
// b_wins: count of positions where B is strictly more specific
@omni_compare_spec_acc = λ&sig_a. λ&sig_b. λ&a_wins. λ&b_wins.
  λ{
    #NIL:
      λ{
        #NIL:
          // Both signatures exhausted - evaluate results
          λ{
            #Cst: λ&aw.
              λ{
                #Cst: λ&bw.
                  λ{
                    0: λ{ 0: #Equal{} _ : λ&u_. #BSpec{} }(bw)  // No A wins
                    _: λ{ 0: #ASpec{} _ : λ&u_. #Ambig{} }(bw)  // Some A wins
                  }(aw)
              }(b_wins)
          }(a_wins)
        _: λ&u_. #Ambig{}  // Different arities
      }(sig_b)
    #CON: λ&ah. λ&at.
      λ{
        #NIL: #Ambig{}  // Different arities
        #CON: λ&bh. λ&bt.
          // Check subtype relations both ways
          (λ&a_sub_b.
            (λ&b_sub_a.
              λ{
                #True:  // A <: B
                  λ{
                    #True:  // B <: A also - equal at this position
                      @omni_compare_spec_acc(at)(bt)(a_wins)(b_wins)
                    _: λ&u_.  // A <: B but not B <: A - A is strictly more specific here
                      @omni_compare_spec_acc(at)(bt)(#Cst{(@omni_unwrap_cst(a_wins) + 1)})(b_wins)
                  }(b_sub_a)
                _: λ&u_.  // NOT A <: B
                  λ{
                    #True:  // B <: A - B is strictly more specific here
                      @omni_compare_spec_acc(at)(bt)(a_wins)(#Cst{(@omni_unwrap_cst(b_wins) + 1)})
                    _: λ&u_.  // Neither is subtype - incomparable types at this position
                      #Ambig{}
                  }(b_sub_a)
              }(a_sub_b)
            )(@omni_subtype(bh)(ah))
          )(@omni_subtype(ah)(bh))
      }(sig_b)
  }(sig_a)

// =============================================================================
// List Evaluation
// =============================================================================

@omni_eval_list = λ&menv. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{@omni_eval(menv)(h), @omni_eval_list(menv)(t)}
  }(xs)

// Evaluate list elements sequentially (strict left-to-right)
@omni_eval_list_seq = λ&menv. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&hv.
        (λ&tv. #CON{hv, tv})(@omni_eval_list_seq(menv)(t))
      )(@omni_eval(menv)(h))
  }(xs)

// Evaluate list in CPS mode (for named let inside reset/handle)
@omni_eval_list_cps = λ&menv. λ&xs. λ&k.
  λ{
    #NIL: (k(#NIL))
    #CON: λ&h. λ&t.
      @omni_eval_cps(menv)(h)(λ&hv.
        @omni_eval_list_cps(menv)(t)(λ&tv.
          (k(#CON{hv, tv}))))
  }(xs)

// Evaluate dict entries (list of (key value) pairs)
// Parser generates pairs as #CON{key, value} directly (not wrapped in list)
// Pattern: entries = #CON{#CON{k1, v1}, #CON{#CON{k2, v2}, #NIL}}
@omni_eval_dict_entries = λ&menv. λ&entries.
  λ{
    #NIL: #NIL
    #CON: λ&pair. λ&rest.
      // pair should be #CON{key, val}
      #CON{@omni_eval_dict_single_pair(menv)(pair), @omni_eval_dict_entries(menv)(rest)}
  }(entries)

// Evaluate a single dict pair #CON{key, val} -> #CON{key_evaled, #CON{val_evaled, #NIL}}
@omni_eval_dict_single_pair = λ&menv. λ&pair.
  λ{
    #CON: λ&key. λ&val.
      #CON{@omni_eval(menv)(key), #CON{@omni_eval(menv)(val), #NIL}}
    _: λ&u_.
      // Malformed pair - return empty pair
      #CON{#NIL, #CON{#NIL, #NIL}}
  }(pair)

// Evaluate dict entries in CPS mode (for use inside reset/handle)
@omni_eval_dict_entries_cps = λ&menv. λ&entries. λ&k.
  λ{
    #NIL: (k(#NIL))
    #CON: λ&pair. λ&rest.
      λ{
        #CON: λ&key. λ&val_rest.
          λ{
            #CON: λ&val. λ&ux.
              @omni_eval_cps(menv)(key)(λ&kv.
                @omni_eval_cps(menv)(val)(λ&vv.
                  @omni_eval_dict_entries_cps(menv)(rest)(λ&rest_evaled.
                    (k(#CON{#CON{kv, #CON{vv, #NIL}}, rest_evaled})))))
            _: λ&u_. @omni_eval_dict_entries_cps(menv)(rest)(k)
          }(val_rest)
        _: λ&u_. @omni_eval_dict_entries_cps(menv)(rest)(k)
      }(pair)
  }(entries)

// =============================================================================
// Arithmetic
// =============================================================================

@omni_add = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn. #Cst{(an + bn)}
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

@omni_sub = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn. #Cst{(an - bn)}
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

@omni_mul = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn. #Cst{(an * bn)}
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

@omni_div = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn.
          λ{
            0: #Err{#sym_divz}
            _: λ&u_. #Cst{(an / bn)}
          }(bn)
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

@omni_mod = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn.
          λ{
            0: #Err{#sym_divz}
            _: λ&u_. #Cst{(an % bn)}
          }(bn)
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

// =============================================================================
// Bitwise Operations
// =============================================================================

@omni_band = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn. #Cst{(an && bn)}
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

@omni_bor = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn. #Cst{(an || bn)}
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

@omni_bxor = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn. #Cst{(an ^ bn)}
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

@omni_bnot = λ&a.
  λ{
    #Cst: λ&an. #Cst{(4294967295 - an)}  // ~n = -n - 1 = (2^32 - 1) - n for unsigned
    _: λ&u_. #Err{#sym_type}
  }(a)

// bit-shift: positive = left shift, negative = right shift
// Handle negative shift amount by checking high bit (two's complement)
// Handles both #Cst and #Fix representations
@omni_bshift = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn.
          // Check if shift amount is negative (high bit set = >= 2^31)
          !!&isneg = (bn >= 2147483648);
          λ{
            1:
              // Negative shift = right shift, negate to get positive amount
              !!&posamt = (4294967296 - bn);
              #Cst{(an >> posamt)}
            0: #Cst{(an << bn)}
          }(isneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          // #Fix with hi >= 2^31 means negative
          !!&isneg = (bhi >= 2147483648);
          λ{
            1:
              // Negative shift = right shift
              !!&posamt = (4294967296 - blo);
              #Cst{(an >> posamt)}
            0: #Cst{(an << blo)}
          }(isneg)
        _: λ&u_. #Err{#sym_type}
      }(b)
    _: λ&u_. #Err{#sym_type}
  }(a)

// =============================================================================

// Equality comparison for all value types
@omni_eql = λ&a. λ&b.
  λ{
    1: #True{}
    0: #Fals{}
  }(@omni_values_equal(a)(b))

// Inequality comparison for all value types
@omni_neq = λ&a. λ&b.
  λ{
    1: #Fals{}
    0: #True{}
  }(@omni_values_equal(a)(b))

// Signed comparison helpers
// Sign bit is bit 31 (2^31 = 2147483648)
// A number is negative if value >= 2147483648
@omni_is_negative = λ&n. (n >= 2147483648)

// Helper: Check if #Fix represents a negative number (hi has sign bit set)
@omni_fix_is_negative = λ&hi. (hi >= 2147483648)

// Helper: Signed less-than comparison for two values with known sign flags
// aneg, bneg: 1 if negative, 0 if non-negative
// an, bn: the raw unsigned values
// NOTE: Using aneg/bneg instead of a_neg/b_neg due to HVM4 bug with underscore names
// Two's complement: larger unsigned = less negative (closer to 0)
// e.g., -1 = 0xFFFFFFFF (largest), -10 = 0xFFFFFFF6 (smaller)
// So for both negative: normal unsigned comparison works directly
@omni_signed_lt = λ&an. λ&bn. λ&aneg. λ&bneg.
  λ{
    // a is negative
    1: λ{
      // b is also negative: use normal unsigned compare (larger unsigned = larger signed)
      1: λ{1: #True{}; _: λ&u_. #Fals{}}((an < bn))
      // b is non-negative: negative < positive
      _: λ&u_. #True{}
    }(bneg)
    // a is non-negative
    _: λ&u_. λ{
      // b is negative: positive > negative
      1: #Fals{}
      // both non-negative: normal unsigned compare
      _: λ&u_. λ{1: #True{}; _: λ&u_. #Fals{}}((an < bn))
    }(bneg)
  }(aneg)

// Helper: Signed greater-than comparison
@omni_signed_gt = λ&an. λ&bn. λ&aneg. λ&bneg.
  λ{
    // a is negative
    1: λ{
      // b is also negative: use normal unsigned compare
      1: λ{1: #True{}; _: λ&u_. #Fals{}}((an > bn))
      // b is non-negative: negative < positive, so a > b is false
      _: λ&u_. #Fals{}
    }(bneg)
    // a is non-negative
    _: λ&u_. λ{
      // b is negative: positive > negative
      1: #True{}
      // both non-negative: normal unsigned compare
      _: λ&u_. λ{1: #True{}; _: λ&u_. #Fals{}}((an > bn))
    }(bneg)
  }(aneg)

// Helper: Signed less-than-or-equal comparison
@omni_signed_le = λ&an. λ&bn. λ&aneg. λ&bneg.
  λ{
    // a is negative
    1: λ{
      // b is also negative: use normal unsigned compare
      1: λ{1: #True{}; _: λ&u_. #Fals{}}((an <= bn))
      // b is non-negative: negative <= positive
      _: λ&u_. #True{}
    }(bneg)
    // a is non-negative
    _: λ&u_. λ{
      // b is negative: positive > negative, so a <= b is false
      1: #Fals{}
      // both non-negative: normal unsigned compare
      _: λ&u_. λ{1: #True{}; _: λ&u_. #Fals{}}((an <= bn))
    }(bneg)
  }(aneg)

// Helper: Signed greater-than-or-equal comparison
@omni_signed_ge = λ&an. λ&bn. λ&aneg. λ&bneg.
  λ{
    // a is negative
    1: λ{
      // b is also negative: use normal unsigned compare
      1: λ{1: #True{}; _: λ&u_. #Fals{}}((an >= bn))
      // b is non-negative: negative < positive, so a >= b is false
      _: λ&u_. #Fals{}
    }(bneg)
    // a is non-negative
    _: λ&u_. λ{
      // b is negative: positive >= negative
      1: #True{}
      // both non-negative: normal unsigned compare
      _: λ&u_. λ{1: #True{}; _: λ&u_. #Fals{}}((an >= bn))
    }(bneg)
  }(aneg)

// Signed less-than: handles negative numbers correctly
// Supports: #Cst vs #Cst, #Fix vs #Fix, #Cst vs #Fix, #Fix vs #Cst
// NOTE: Using aneg/bneg instead of a_neg/b_neg due to HVM4 bug with underscore names
@omni_lt = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_lt(an)(bn)(aneg)(bneg)
        // #Cst < #Fix
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_lt(an)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    #Fix: λ&ahi. λ&alo. λ&ascale.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_lt(alo)(bn)(aneg)(bneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_lt(alo)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    _: λ&u_. #Fals{}
  }(a)

// Signed greater-than
@omni_gt = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_gt(an)(bn)(aneg)(bneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_gt(an)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    #Fix: λ&ahi. λ&alo. λ&ascale.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_gt(alo)(bn)(aneg)(bneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_gt(alo)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    _: λ&u_. #Fals{}
  }(a)

// Signed less-than-or-equal
@omni_le = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_le(an)(bn)(aneg)(bneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_le(an)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    #Fix: λ&ahi. λ&alo. λ&ascale.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_le(alo)(bn)(aneg)(bneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_le(alo)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    _: λ&u_. #Fals{}
  }(a)

// Signed greater-than-or-equal
@omni_ge = λ&a. λ&b.
  λ{
    #Cst: λ&an.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_ge(an)(bn)(aneg)(bneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_is_negative(an);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_ge(an)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    #Fix: λ&ahi. λ&alo. λ&ascale.
      λ{
        #Cst: λ&bn.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_is_negative(bn);
          @omni_signed_ge(alo)(bn)(aneg)(bneg)
        #Fix: λ&bhi. λ&blo. λ&bscale.
          !!&aneg = @omni_fix_is_negative(ahi);
          !!&bneg = @omni_fix_is_negative(bhi);
          @omni_signed_ge(alo)(blo)(aneg)(bneg)
        _: λ&u_. #Fals{}
      }(b)
    _: λ&u_. #Fals{}
  }(a)

// =============================================================================
// Pattern Matching
// =============================================================================

@omni_match = λ&menv. λ&scrut. λ&cases.
  λ{
    #NIL: #Err{#sym_nomatch}
    #CON: λ&case. λ&rest.
      (λ&result.
        λ{
          #Noth: @omni_match(menv)(scrut)(rest)
          _: λ&u_. result
        }(result)
      )(@omni_try_case(menv)(scrut)(case))
  }(cases)

@omni_try_case = λ&menv. λ&scrut. λ&case.
  λ{
    #Case: λ&pattern. λ&guard. λ&body.
      (λ&bindings.
        // Rebind before nested switch
        !&menv2 = menv;
        !&guard2 = guard;
        !&body2 = body;
        !&bindings2 = bindings;
        λ{
          #Noth: #Noth{}
          _: λ&u_.
            (λ&env.
              (λ&new_env.
                (λ&new_menv.
                  // Rebind before guard check switch
                  !&new_menv2 = new_menv;
                  !&body3 = body2;
                  !&guard3 = guard2;
                  // Check guard if present
                  (λ&guard_ok.
                    λ{
                      #True: @omni_eval(new_menv2)(body3)
                      _: λ&u_. #Noth{}
                    }(guard_ok)
                  )((λ{
                    #NIL: #True{}
                    _: λ&u_. @omni_eval(new_menv2)(guard3)
                  })(guard3))
                )(@omni_menv_extend(menv2)(new_env))
              )(@omni_env_extend_many(env)(bindings2))
            )((λ{#MEnv: λ&e. λ&h. λ&p. λ&l. e})(menv2))
        }(bindings)
      )(@omni_pattern_match(scrut)(pattern))
  }(case)

@omni_pattern_match = λ&scrut. λ&pattern.
  // Rebind scrut before the switch on pattern
  !&scrut2 = scrut;
  λ{
    // Wildcard matches anything
    #PWld: #NIL

    // Variable captures value
    #PVar: λ&i. !&s = scrut2; #CON{s, #NIL}

    // Literal pattern
    #PLit: λ&lit.
      λ{
        1: #NIL
        _: λ&u_. #Noth{}
      }(@omni_values_equal(scrut2)(lit))

    // Constructor pattern
    #PCtr: λ&tag. λ&args.
      !&scrut3 = scrut2;
      !&args2 = args;
      λ{
        #CTR: λ&stag. λ&sargs.
          λ{
            1: @omni_pattern_match_args(sargs)(args2)
            _: λ&u_. #Noth{}
          }((stag == tag))
        _: λ&u_. #Noth{}
      }(scrut3)

    // As-pattern (captures and matches)
    #PAs: λ&inner.
      !&scrut3 = scrut2;
      (λ&inner_bindings.
        λ{
          #Noth: #Noth{}
          _: λ&u_. #CON{scrut3, inner_bindings}
        }(inner_bindings)
      )(@omni_pattern_match(scrut3)(inner))

    // List pattern: #PLst{elements} - matches against list scrutinee
    #PLst: λ&elements.
      @omni_match_list_pattern(scrut2)(elements)

    // Spread pattern: #Sprd{name} - captures remaining list elements
    // This is typically only used inside list patterns but handle it here too
    #Sprd: λ&name. #CON{scrut2, #NIL}

    _: λ&u_. #Noth{}
  }(pattern)

@omni_pattern_match_args = λ&scrut_args. λ&pat_args.
  λ{
    #NIL:
      λ{
        #NIL: #NIL
        _: λ&u_. #Noth{}
      }(pat_args)
    #CON: λ&sh. λ&st.
      λ{
        #NIL: #Noth{}
        #CON: λ&ph. λ&pt.
          (λ&h_bindings.
            λ{
              #Noth: #Noth{}
              _: λ&u_.
                (λ&t_bindings.
                  λ{
                    #Noth: #Noth{}
                    _: λ&u_. @omni_list_append(h_bindings)(t_bindings)
                  }(t_bindings)
                )(@omni_pattern_match_args(st)(pt))
            }(h_bindings)
          )(@omni_pattern_match(sh)(ph))
      }(pat_args)
  }(scrut_args)

// Match list pattern against scrutinee
// patterns is a list of patterns, possibly ending with #Sprd{name}
@omni_match_list_pattern = λ&scrut. λ&patterns.
  λ{
    #NIL:
      // No more patterns - scrutinee must be empty for match
      λ{
        #NIL: #NIL
        _: λ&u_. #Noth{}
      }(scrut)
    #CON: λ&pat. λ&rest_patterns.
      // Rebind variables before inner switches
      !&scrut2 = scrut;
      !&pat2 = pat;
      !&rest_patterns2 = rest_patterns;
      // Check if this is a spread pattern (captures rest)
      λ{
        #Sprd: λ&name.
          // Spread captures the remaining scrutinee
          #CON{scrut2, #NIL}
        _: λ&u_.
          // Regular pattern - need to match against list head
          λ{
            #NIL: #Noth{}  // scrutinee empty but patterns remain
            #CON: λ&scrut_head. λ&scrut_tail.
              // Rebind all variables before nested operations
              !&sh = scrut_head;
              !&st = scrut_tail;
              !&p3 = pat2;
              !&rp3 = rest_patterns2;
              // Match head pattern against head of scrutinee
              (λ&head_bindings.
                !&hb = head_bindings;
                !&st2 = st;
                !&rp4 = rp3;
                λ{
                  #Noth: #Noth{}
                  _: λ&u_.
                    // Head matched, continue with rest
                    (λ&tail_bindings.
                      !&hb2 = hb;
                      λ{
                        #Noth: #Noth{}
                        _: λ&u_. @omni_list_append(hb2)(tail_bindings)
                      }(tail_bindings)
                    )(@omni_match_list_pattern(st2)(rp4))
                }(hb)
              )(@omni_pattern_match(sh)(p3))
            _: λ&u_. #Noth{}  // scrutinee not a list
          }(scrut2)
      }(pat2)
  }(patterns)

// Normalize value for comparison: #Lit{n} -> #Cst{n}, others unchanged
@omni_normalize_value = λ&v.
  λ{
    #Lit: λ&n. #Cst{n}
    _: λ&u_. v
  }(v)

@omni_values_equal = λ&a. λ&b.
  // Normalize both sides to handle #Lit vs #Cst comparison
  (λ&na. (λ&nb.
    λ{
      #Cst: λ&an.
        λ{
          #Cst: λ&bn. (an == bn)
          _: λ&u_. 0
        }(nb)
      #CHR: λ&ac.
        λ{
          #CHR: λ&bc. (ac == bc)
          _: λ&u_. 0
        }(nb)
      #NIL:
        λ{
          #NIL: 1
          _: λ&u_. 0
        }(nb)
      #True:
        λ{
          #True: 1
          _: λ&u_. 0
        }(nb)
      #Fals:
        λ{
          #Fals: 1
          _: λ&u_. 0
        }(nb)
      #Sym: λ&as.
        λ{
          #Sym: λ&bs. (as == bs)
          _: λ&u_. 0
        }(nb)
      #Str: λ&achars.
        λ{
          #Str: λ&bchars. @omni_list_equal(achars)(bchars)
          _: λ&u_. 0
        }(nb)
      #CON: λ&ah. λ&at.
        λ{
          #CON: λ&bh. λ&bt.
            λ{
              1: @omni_values_equal(at)(bt)
              0: 0
            }(@omni_values_equal(ah)(bh))
          _: λ&u_. 0
        }(nb)
      _: λ&u_. 0
    }(na)
  )(@omni_normalize_value(b)))(@omni_normalize_value(a))

// Compare two lists for equality element-wise
@omni_list_equal = λ&a. λ&b.
  λ{
    #NIL: λ{#NIL: 1; _: λ&u_. 0}(b)
    #CON: λ&ah. λ&at.
      λ{
        #NIL: 0
        #CON: λ&bh. λ&bt.
          λ{
            1: @omni_list_equal(at)(bt)
            0: 0
          }(@omni_values_equal(ah)(bh))
      }(b)
  }(a)

@omni_list_append = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @omni_list_append(t)(ys)}
  }(xs)

// =============================================================================
// Delimited Continuations via CPS Transformation
// =============================================================================
//
// OmniLisp implements delimited continuations (reset/control) using a CPS-style
// evaluator, following Purple's design. The key insight is that HVM4's
// interaction nets are fundamentally lambda calculus, so continuations can be
// captured as native lambdas.
//
// How it works:
// 1. (reset body) enters CPS evaluation mode via @omni_eval_cps
// 2. In CPS mode, every expression takes an explicit continuation parameter k
// 3. (control k body) captures k as #Kont{lambda} and binds it
// 4. When the captured continuation is called, it invokes the lambda directly
//
// Example: (reset (+ 10 (control k (+ (k 3) (k 5))))) => 28
//   - Entering reset: call @omni_eval_cps with identity continuation (λ&v. v)
//   - Evaluating (+ 10 _): k becomes (λ&v. (+ 10 v)) in CPS
//   - control captures k as #Kont{λ&v. #Cst{(10 + v)}}
//   - (k 3) calls the lambda with 3 → #Cst{13}
//   - (k 5) calls the lambda with 5 → #Cst{15}
//   - (+ 13 15) → 28
//
// Value types:
// - #CloC{env, body}: Closure created inside reset (evaluated in CPS mode)
// - #Kont{k}: Captured continuation (k is a native HVM lambda)

// Helper to unwrap #Cst
@omni_unwrap_cst = λ&v. λ{#Cst: λ&n. n; _ : λ&u_. 0}(v)

// =============================================================================
// Defunctionalized CPS Continuations
// =============================================================================
// HVM4 has a closure capture bug where lambdas created inside pattern match arms
// don't properly capture variables from outer scopes when those lambdas are passed
// to other functions. The solution is "defunctionalized CPS" - represent continuations
// as tagged data structures instead of lambdas.
//
// Continuation Types:
// -------------------
// #KId                        - Identity continuation (returns value as-is)
// #KLam{k}                    - Native lambda continuation (for callbacks from user code)
//
// Binary operations (Add, Sub, Mul, Div):
// #KBin1{k, op, b, menv}      - Evaluated a, need to eval b, then apply op
// #KBin2{k, op, va}           - Evaluated b, apply op to va and vb
//
// Comparisons (Lt, Gt, Leq, Geq, Eq, Neq):
// #KCmp1{k, op, b, menv}      - Evaluated a, need to eval b, then compare
// #KCmp2{k, op, va}           - Evaluated b, compare va and vb
//
// Application:
// #KApp1{k, x, menv}          - Evaluated f, need to eval arg x
// #KApp2{k, vf, menv}         - Evaluated x, apply function vf to arg
//
// Let binding:
// #KLet{k, body, menv}        - Evaluated value, extend env and eval body
//
// Conditionals:
// #KIf{k, t, el, menv}        - Evaluated condition, branch accordingly
//
// Boolean operations:
// #KAnd{k, b, menv}           - Evaluated a, short-circuit and
// #KOr{k, b, menv}            - Evaluated a, short-circuit or
// #KNot{k}                    - Evaluated a, negate
//
// Effects:
// #KPerf1{k, payload, menv}   - Evaluate tag for perform
// #KPerf2{k, tag, menv}       - Evaluate payload for perform
//
// Collections:
// #KArr{k, rest, acc, menv}   - Evaluating array elements
// #KDict{k, rest, acc, menv}  - Evaluating dict entries
//
// Cons cell:
// #KCons1{k, tail, menv}      - Evaluated head, need to eval tail
// #KCons2{k, head}            - Evaluated tail, construct cons cell
//
// Do block (sequence):
// #KDo{k, rest, menv}         - Evaluated first expr, now eval rest
//
// Pattern match:
// #KMat{k, cases, menv}       - Evaluated scrutinee, now match and eval branch
//
// Effect resumption:
// #KResume{k}                 - Defunctionalized resume (wraps continuation k)

// Apply a continuation to a value - the core dispatcher
@omni_apply_k = λ&k. λ&v.
  λ{
    // Identity - return value directly
    #KId: v

    // Native lambda continuation (from user code or effects)
    #KLam: λ&lam. (lam(v))

    // Binary operation - stage 1: evaluated a, now eval b
    #KBin1: λ&k2. λ&op. λ&b. λ&menv.
      @omni_eval_cps(menv)(#KBin2{k2, op, v})(b)

    // Binary operation - stage 2: evaluated b, compute result
    #KBin2: λ&k2. λ&op. λ&va.
      @omni_apply_k(k2)(@omni_binop(op)(va)(v))

    // Comparison - stage 1: evaluated a, now eval b
    #KCmp1: λ&k2. λ&op. λ&b. λ&menv.
      @omni_eval_cps(menv)(#KCmp2{k2, op, v})(b)

    // Comparison - stage 2: evaluated b, compare
    #KCmp2: λ&k2. λ&op. λ&va.
      @omni_apply_k(k2)(@omni_cmpop(op)(va)(v))

    // Application - stage 1: evaluated f, now eval arg
    #KApp1: λ&k2. λ&x. λ&menv.
      @omni_eval_cps(menv)(#KApp2{k2, v, menv})(x)

    // Application - stage 2: evaluated arg, apply function
    #KApp2: λ&k2. λ&vf. λ&menv.
      @omni_apply_cps_defun(menv)(vf)(v)(k2)

    // Let - evaluated value, extend env and eval body
    #KLet: λ&k2. λ&body. λ&menv.
      @omni_eval_cps(@omni_menv_extend_val(menv)(v))(k2)(body)

    // If - evaluated condition, branch
    #KIf: λ&k2. λ&t. λ&el. λ&menv.
      @omni_eval_cps(menv)(k2)(@omni_if_branch(v)(t)(el))

    // And - short-circuit
    #KAnd: λ&k2. λ&b. λ&menv.
      λ{
        #Fals: @omni_apply_k(k2)(#Fals{})
        #Cst: λ&n. λ{0: @omni_apply_k(k2)(#Fals{}); _: λ&u_. @omni_eval_cps(menv)(k2)(b)}(n)
        _: λ&u_. @omni_eval_cps(menv)(k2)(b)
      }(v)

    // Or - short-circuit
    #KOr: λ&k2. λ&b. λ&menv.
      λ{
        #True: @omni_apply_k(k2)(#True{})
        #Fals: @omni_eval_cps(menv)(k2)(b)
        #Cst: λ&n. λ{0: @omni_eval_cps(menv)(k2)(b); _: λ&u_. @omni_apply_k(k2)(v)}(n)
        _: λ&u_. @omni_apply_k(k2)(v)
      }(v)

    // Not - negate
    #KNot: λ&k2.
      @omni_apply_k(k2)(@omni_not(v))

    // Perform - stage 1: evaluated tag, now eval payload
    #KPerf1: λ&k2. λ&payload. λ&menv.
      @omni_eval_cps(menv)(#KPerf2{k2, v, menv})(payload)

    // Perform - stage 2: evaluated payload, perform effect
    #KPerf2: λ&k2. λ&tag. λ&menv.
      // Resume continuation uses defunctionalized #KontD to avoid HVM4 closure capture bug
      @omni_perform_cps(menv)(tag)(v)(#KontD{k2})

    // Array - evaluating elements
    #KArr: λ&k2. λ&rest. λ&acc. λ&menv.
      @omni_eval_arr_cps(menv)(k2)(rest)(#CON{v, acc})

    // Dict - evaluating entries
    #KDict: λ&k2. λ&rest. λ&acc. λ&menv.
      @omni_eval_dict_cps(menv)(k2)(rest)(#CON{v, acc})

    // Dict value - evaluated a value, now add to acc and continue
    #KDictVal: λ&k2. λ&key. λ&rest. λ&acc. λ&menv.
      @omni_eval_dict_cps(menv)(k2)(rest)(#CON{#Pair{key, v}, acc})

    // Yield - return fiber yield marker
    #KYld: λ&k2.
      #FYld{v, #KontD{k2}}

    // Cons cell - stage 1: evaluated head, now eval tail
    #KCons1: λ&k2. λ&tail. λ&menv.
      @omni_eval_cps(menv)(#KCons2{k2, v})(tail)

    // Cons cell - stage 2: evaluated tail, construct cons
    #KCons2: λ&k2. λ&head.
      @omni_apply_k(k2)(#CON{head, v})

    // Do block - stage 1: evaluated first, now eval rest
    #KDo: λ&k2. λ&rest. λ&menv.
      @omni_eval_cps(menv)(k2)(rest)

    // Pattern match - scrutinee evaluated, now match cases in CPS
    #KMat: λ&k2. λ&cases. λ&menv.
      @omni_match_cps(menv)(k2)(v)(cases)

    // Named let arguments - evaluating init values
    #KNLetArgs: λ&k2. λ&loop_closure. λ&rest. λ&acc. λ&menv.
      λ{
        #NIL:
          // All args evaluated, apply loop closure
          @omni_apply_nlet(menv)(k2)(loop_closure)(@omni_list_reverse(#CON{v, acc}))
        #CON: λ&h. λ&t.
          @omni_eval_cps(menv)(#KNLetArgs{k2, loop_closure, t, #CON{v, acc}, menv})(h)
        _: λ&u_. @omni_apply_k(k2)(#Err{#sym_bad_nlet_args})
      }(rest)

    // Fallback for unknown continuation types
    _ : λ&u_. #Err{#sym_bad_kont}
  }(k)

// Apply named let closure to evaluated arguments
@omni_apply_nlet = λ&menv. λ&k. λ&clo. λ&args.
  λ{
    #NIL: @omni_apply_cps_defun(menv)(clo)(#Noth)(k)
    #CON: λ&h. λ&t. @omni_apply_nlet_args(menv)(k)(clo)(h)(t)
    _: λ&u_. @omni_apply_k(k)(#Err{#sym_bad_nlet_apply})
  }(args)

// Apply arguments one at a time
@omni_apply_nlet_args = λ&menv. λ&k. λ&clo. λ&arg. λ&rest.
  λ{
    #NIL: @omni_apply_cps_defun(menv)(clo)(arg)(k)
    #CON: λ&h. λ&t.
      // Apply first arg, continue with rest
      (λ&partial.
        @omni_apply_nlet_args(menv)(k)(partial)(h)(t)
      )(@omni_apply_partial(menv)(clo)(arg))
    _: λ&u_. @omni_apply_cps_defun(menv)(clo)(arg)(k)
  }(rest)

// Apply one argument to closure (partial application)
@omni_apply_partial = λ&menv. λ&clo. λ&arg.
  λ{
    #CloK: λ&cenv. λ&body.
      // For CloK with multiple args, we need to extend env and return closure for rest
      #CloK{#CON{arg, #CON{#CloK{cenv, body}, cenv}}, body}
    #Clo: λ&cenv. λ&body.
      #Clo{#CON{arg, cenv}, body}
    _: λ&u_. clo
  }(clo)

// Helper: extend menv with a value
@omni_menv_extend_val = λ&menv. λ&val.
  λ{
    #MEnv: λ&env. λ&h. λ&p. λ&l. #MEnv{#CON{val, env}, h, p, l}
    _: λ&u_. #MEnv{#CON{val, #NIL}, #NIL, #Noth, #Cst{0}}
  }(menv)

// Helper: select branch for if
@omni_if_branch = λ&cond. λ&t. λ&el.
  λ{
    #Cst: λ&n. λ{0: el; _: λ&u_. t}(n)
    #Fals: el
    _: λ&u_. t
  }(cond)

// Helper: binary operation dispatcher
@omni_binop = λ&op. λ&a. λ&b.
  λ{
    #OpAdd: #Cst{(@omni_unwrap_cst(a) + @omni_unwrap_cst(b))}
    #OpSub: #Cst{(@omni_unwrap_cst(a) - @omni_unwrap_cst(b))}
    #OpMul: #Cst{(@omni_unwrap_cst(a) * @omni_unwrap_cst(b))}
    #OpDiv: #Cst{(@omni_unwrap_cst(a) / @omni_unwrap_cst(b))}
    #OpMod: #Cst{(@omni_unwrap_cst(a) % @omni_unwrap_cst(b))}
    _: λ&u_. #Err{#sym_bad_binop}
  }(op)

// Helper: comparison operation dispatcher (uses signed comparison)
@omni_cmpop = λ&op. λ&a. λ&b.
  (λ&av. λ&bv.
    !!&a_neg = @omni_is_negative(av);
    !!&b_neg = @omni_is_negative(bv);
    λ{
      #OpLt: @omni_signed_lt(av)(bv)(a_neg)(b_neg)
      #OpGt: @omni_signed_gt(av)(bv)(a_neg)(b_neg)
      #OpLeq: @omni_signed_le(av)(bv)(a_neg)(b_neg)
      #OpGeq: @omni_signed_ge(av)(bv)(a_neg)(b_neg)
      #OpEq: λ{1: #True{}; _: λ&u_. #Fals{}}((av == bv))
      #OpNeq: λ{1: #True{}; _: λ&u_. #Fals{}}((av != bv))
      _: λ&u_. #Err{#sym_bad_cmpop}
    }(op)
  )(@omni_unwrap_cst(a))(@omni_unwrap_cst(b))

// NOTE: Signed comparison helpers (@omni_signed_lt, @omni_signed_gt, etc.)
// are defined earlier in this file around line 1785. They handle:
// - Correct signed comparison for two's complement numbers
// - The HVM4 underscore-variable-name bug (using aneg/bneg instead of a_neg/b_neg)
// - The case where both numbers are negative (larger unsigned = more negative)

// Defunctionalized apply for CPS closures
// Uses helper to capture args before pattern match on function type
@omni_apply_cps_defun = λ&menv. λ&vf. λ&vx. λ&k.
  @omni_apply_cps_defun_impl(vx)(k)(menv)(vf)

// Helper - captures vx and k BEFORE pattern match on function
@omni_apply_cps_defun_impl = λ&arg. λ&kont. λ&menv. λ&func.
  λ{
    // CPS closure - extend closure env with arg
    #CloC: λ&cenv. λ&body.
      @omni_eval_cps(@omni_menv_set_env(menv)(#CON{arg, cenv}))(kont)(body)

    // Recursive CPS closure
    #CloK: λ&cenv. λ&body.
      (λ&self.
        @omni_eval_cps(@omni_menv_set_env(menv)(#CON{arg, #CON{self, cenv}}))(kont)(body)
      )(#CloK{cenv, body})

    // Regular closure from outside reset
    #Clo: λ&cenv. λ&body.
      @omni_eval_cps(@omni_menv_set_env(menv)(#CON{arg, cenv}))(kont)(body)

    // Recursive closure from outside reset
    #CloR: λ&cenv. λ&body.
      (λ&self.
        @omni_eval_cps(@omni_menv_set_env(menv)(#CON{arg, #CON{self, cenv}}))(kont)(body)
      )(#CloR{cenv, body})

    // Captured continuation (lambda-wrapped) - apply it
    // Helper: call saved_k with arg, then pass result to kont
    #Kont: λ&saved_k.
      @omni_apply_kont_lambda_helper(arg)(kont)(saved_k)

    // Captured continuation (defunctionalized) - apply it directly
    // The stored k is a defunctionalized continuation tag, apply it to arg
    // Then pass result to current kont
    #KontD: λ&stored_k.
      @omni_apply_kontd_helper(arg)(kont)(stored_k)

    _: λ&u_. #Err{#sym_not_function}
  }(func)

// Helper for applying lambda-wrapped continuation
// Captures arg and kont BEFORE calling saved_k
@omni_apply_kont_lambda_helper = λ&arg. λ&kont. λ&saved_k.
  (λ&result. @omni_apply_k(kont)(result))((saved_k(arg)))

// Helper for applying defunctionalized continuation directly
// Apply stored_k to arg, then pass result to kont
@omni_apply_kontd_helper = λ&arg. λ&kont. λ&stored_k.
  // stored_k is a defunctionalized continuation tag (e.g., #KBin2{...})
  // First compute the result via the captured continuation
  (λ&result. @omni_apply_k(kont)(result))(@omni_apply_k(stored_k)(arg))

// Helper: set env in menv
@omni_menv_set_env = λ&menv. λ&new_env.
  λ{
    #MEnv: λ&e. λ&h. λ&p. λ&l. #MEnv{new_env, h, p, l}
    _: λ&u_. #MEnv{new_env, #NIL, #Noth, #Cst{0}}
  }(menv)

// Array evaluation helper
@omni_eval_arr_cps = λ&menv. λ&k. λ&elems. λ&acc.
  λ{
    #NIL: @omni_apply_k(k)(#Arr{@omni_list_length(acc), @omni_list_reverse(acc)})
    #CON: λ&h. λ&t.
      @omni_eval_cps(menv)(#KArr{k, t, acc, menv})(h)
    _: λ&u_. @omni_apply_k(k)(#Arr{@omni_list_length(acc), @omni_list_reverse(acc)})
  }(elems)

// Dict evaluation helper
@omni_eval_dict_cps = λ&menv. λ&k. λ&entries. λ&acc.
  λ{
    #NIL: @omni_apply_k(k)(#Dict{@omni_list_reverse(acc)})
    #CON: λ&h. λ&t.
      // Each entry is #Pair{key, val_expr}
      λ{
        #Pair: λ&key. λ&val_expr.
          @omni_eval_cps(menv)(#KDictVal{k, key, t, acc, menv})(val_expr)
        _: λ&u_. @omni_apply_k(k)(#Err{#sym_bad_dict_entry})
      }(h)
    _: λ&u_. @omni_apply_k(k)(#Dict{@omni_list_reverse(acc)})
  }(entries)

// Add KDictVal continuation handler
// Note: This needs to be added to @omni_apply_k above, but for now use separate handler

// CPS evaluator - takes menv, continuation k, and expression
// Uses DEFUNCTIONALIZED CONTINUATIONS to avoid HVM4 closure capture bug
// Continuations are data structures (#KId, #KBin1, etc.) instead of lambdas
@omni_eval_cps = λ&menv. λ&k. λ&expr.
  λ{
    #Lit: λ&n. @omni_apply_k(k)(#Cst{n})

    #Cst: λ&n. @omni_apply_k(k)(#Cst{n})

    #Var: λ&i. @omni_apply_k(k)(@omni_env_get_from_menv(menv)(i))

    #Lam: λ&body. @omni_apply_k(k)(#CloC{@omni_menv_get_env(menv), body})

    #LamR: λ&body. @omni_apply_k(k)(#CloK{@omni_menv_get_env(menv), body})

    // Application - use defunctionalized continuation
    #App: λ&f. λ&x.
      @omni_eval_cps(menv)(#KApp1{k, x, menv})(f)

    // Binary operations - use defunctionalized continuations
    #Add: λ&a. λ&b.
      @omni_eval_cps(menv)(#KBin1{k, #OpAdd, b, menv})(a)

    #Sub: λ&a. λ&b.
      @omni_eval_cps(menv)(#KBin1{k, #OpSub, b, menv})(a)

    #Mul: λ&a. λ&b.
      @omni_eval_cps(menv)(#KBin1{k, #OpMul, b, menv})(a)

    #Div: λ&a. λ&b.
      @omni_eval_cps(menv)(#KBin1{k, #OpDiv, b, menv})(a)

    #Mod: λ&a. λ&b.
      @omni_eval_cps(menv)(#KBin1{k, #OpMod, b, menv})(a)

    // Comparisons - use defunctionalized continuations
    #Lt: λ&a. λ&b.
      @omni_eval_cps(menv)(#KCmp1{k, #OpLt, b, menv})(a)

    #Gt: λ&a. λ&b.
      @omni_eval_cps(menv)(#KCmp1{k, #OpGt, b, menv})(a)

    #Leq: λ&a. λ&b.
      @omni_eval_cps(menv)(#KCmp1{k, #OpLeq, b, menv})(a)

    #Geq: λ&a. λ&b.
      @omni_eval_cps(menv)(#KCmp1{k, #OpGeq, b, menv})(a)

    #Eq: λ&a. λ&b.
      @omni_eval_cps(menv)(#KCmp1{k, #OpEq, b, menv})(a)

    #Neq: λ&a. λ&b.
      @omni_eval_cps(menv)(#KCmp1{k, #OpNeq, b, menv})(a)

    // Conditionals - use defunctionalized continuation
    #If: λ&c. λ&t. λ&el.
      @omni_eval_cps(menv)(#KIf{k, t, el, menv})(c)

    // Do block (sequence) - evaluate first, then rest
    #Do: λ&first. λ&rest.
      @omni_eval_cps(menv)(#KDo{k, rest, menv})(first)

    // Pattern match - evaluate scrutinee, then match in CPS
    #Mat: λ&scrut. λ&cases.
      @omni_eval_cps(menv)(#KMat{k, cases, menv})(scrut)

    // Let binding - use defunctionalized continuation
    #Let: λ&val. λ&body.
      @omni_eval_cps(menv)(#KLet{k, body, menv})(val)

    // Strict let in CPS mode (^:strict)
    #LetS: λ&val. λ&body.
      @omni_eval_cps(menv)(#KLet{k, body, menv})(val)

    // Named let (Scheme-style loop) in CPS mode
    #NLet: λ&name_nick. λ&init_values. λ&loop_body.
      (λ&loop_closure.
        @omni_eval_nlet_cps(menv)(k)(loop_closure)(init_values)
      )(#CloK{@omni_menv_get_env(menv), loop_body})

    // Named let (sequential) in CPS mode
    #NLeS: λ&name_nick. λ&init_values. λ&loop_body.
      (λ&loop_closure.
        @omni_eval_nlet_cps(menv)(k)(loop_closure)(init_values)
      )(#CloK{@omni_menv_get_env(menv), loop_body})

    // Nested reset - creates new delimiter
    #Prmt: λ&body.
      (λ&result. @omni_apply_k(k)(result))(@omni_eval_cps(menv)(#KId)(body))

    // Control - capture the continuation!
    #Ctrl: λ&k_idx. λ&body.
      // Store k directly in #Kont (as defunctionalized tag, not lambda)
      // When Kont is applied, @omni_apply_kont_helper will call @omni_apply_k
      (λ&k_val.
        // Evaluate body with k bound, using identity continuation
        @omni_eval_cps(@omni_menv_extend_val(menv)(k_val))(#KId)(body)
      )(#KontD{k})

    // Perform effect - use defunctionalized continuations
    #Perf: λ&tag. λ&payload.
      @omni_eval_cps(menv)(#KPerf1{k, payload, menv})(tag)

    // Handle effects - install handlers and evaluate body
    #Hdle: λ&hdlrs. λ&body.
      (λ&evaluated_handlers.
        (λ&new_handlers.
          @omni_eval_cps(@omni_menv_set_handlers(menv)(new_handlers))(k)(body)
        )(@omni_list_append(evaluated_handlers)(@omni_menv_get_handlers(menv)))
      )(@omni_eval_handlers(menv)(hdlrs))

    // Yield for fibers
    #Yld: λ&val.
      @omni_eval_cps(menv)(#KYld{k})(val)

    // Boolean AND with short-circuit
    #And: λ&a. λ&b.
      @omni_eval_cps(menv)(#KAnd{k, b, menv})(a)

    // Boolean OR with short-circuit
    #Or: λ&a. λ&b.
      @omni_eval_cps(menv)(#KOr{k, b, menv})(a)

    // Boolean NOT
    #Not: λ&a.
      @omni_eval_cps(menv)(#KNot{k})(a)

    // Array literal
    #Arr: λ&elems.
      @omni_eval_arr_cps(menv)(k)(elems)(#NIL)

    // Dict literal
    #Dict: λ&entries.
      @omni_eval_dict_cps(menv)(k)(entries)(#NIL)

    // Cons cell - evaluate head and tail in CPS mode
    #CON: λ&h. λ&t.
      @omni_eval_cps(menv)(#KCons1{k, t, menv})(h)

    // Empty list - return as-is
    #NIL: @omni_apply_k(k)(#NIL)

    // Quoted data - return as-is (already evaluated)
    #QQ: λ&inner. @omni_apply_k(k)(inner)

    // For other forms, fall back to direct evaluation then continue
    _ : λ&u_. @omni_apply_k(k)(@omni_eval(menv)(expr))
  }(expr)

// Helper: get env from menv
@omni_menv_get_env = λ&menv.
  λ{
    #MEnv: λ&e. λ&h. λ&p. λ&l. e
    _: λ&u_. #NIL
  }(menv)

// Helper: get handlers from menv
@omni_menv_get_handlers = λ&menv.
  λ{
    #MEnv: λ&e. λ&h. λ&p. λ&l. h
    _: λ&u_. #NIL
  }(menv)

// Helper: set handlers in menv
@omni_menv_set_handlers = λ&menv. λ&new_handlers.
  λ{
    #MEnv: λ&e. λ&h. λ&p. λ&l. #MEnv{e, new_handlers, p, l}
    _: λ&u_. #MEnv{#NIL, new_handlers, #Noth, #Cst{0}}
  }(menv)

// Helper: get value from env using de Bruijn index (via menv)
@omni_env_get_from_menv = λ&menv. λ&idx.
  @omni_env_get(@omni_menv_get_env(menv))(idx)

// Named let evaluation helper
@omni_eval_nlet_cps = λ&menv. λ&k. λ&loop_closure. λ&init_values.
  λ{
    #NIL: @omni_apply_k(k)(loop_closure)
    #CON: λ&h. λ&t.
      @omni_eval_cps(menv)(#KNLetArgs{k, loop_closure, t, #NIL, menv})(h)
    _: λ&u_. @omni_apply_k(k)(#Err{#sym_bad_nlet})
  }(init_values)

// CPS pattern matching - like @omni_match but evaluates body in CPS mode
@omni_match_cps = λ&menv. λ&k. λ&scrut. λ&cases.
  λ{
    #NIL: @omni_apply_k(k)(#Err{#sym_nomatch})
    #CON: λ&case. λ&rest.
      // Rebind before nested calls
      !&menv2 = menv;
      !&k2 = k;
      !&scrut2 = scrut;
      !&rest2 = rest;
      (λ&result.
        λ{
          #Noth: @omni_match_cps(menv2)(k2)(scrut2)(rest2)
          _: λ&u_. result
        }(result)
      )(@omni_try_case_cps(menv)(k)(scrut)(case))
  }(cases)

// CPS try case - like @omni_try_case but evaluates body in CPS mode
@omni_try_case_cps = λ&menv. λ&k. λ&scrut. λ&case.
  λ{
    #Case: λ&pattern. λ&guard. λ&body.
      (λ&bindings.
        // Rebind before nested switch
        !&menv2 = menv;
        !&k2 = k;
        !&guard2 = guard;
        !&body2 = body;
        !&bindings2 = bindings;
        λ{
          #Noth: #Noth{}
          _: λ&u_.
            (λ&env.
              (λ&new_env.
                (λ&new_menv.
                  // Rebind before guard check switch
                  !&new_menv2 = new_menv;
                  !&k3 = k2;
                  !&body3 = body2;
                  !&guard3 = guard2;
                  // Check guard if present
                  (λ&guard_ok.
                    λ{
                      #True: @omni_eval_cps(new_menv2)(k3)(body3)
                      _: λ&u_. #Noth{}
                    }(guard_ok)
                  )((λ{
                    #NIL: #True{}
                    // Guard evaluation - use non-CPS since guards shouldn't have effects
                    _: λ&u_. @omni_eval(new_menv2)(guard3)
                  })(guard3))
                )(@omni_menv_extend(menv2)(new_env))
              )(@omni_env_extend_many(env)(bindings2))
            )((λ{#MEnv: λ&e. λ&h. λ&p. λ&l. e})(menv2))
        }(bindings)
      )(@omni_pattern_match(scrut)(pattern))
  }(case)

// Yield continuation handler
// (Added to @omni_apply_k above would be cleaner, but add separately for now)

// CPS application - handles CPS closures and captured continuations
// IMPORTANT: Uses helpers to avoid HVM4 closure capture bug with nested pattern matches
@omni_apply_cps = λ&m. λ&vf. λ&vx. λ&k.
  @omni_apply_cps_impl(m)(vx)(k)(vf)

// Helper - takes menv, arg, kont BEFORE func pattern match for proper capture
@omni_apply_cps_impl = λ&menv. λ&arg. λ&kont. λ&func.
  λ{
    // CPS closure created inside reset - use helper to capture before nested menv match
    #CloC: λ&cenv. λ&body.
      @omni_apply_cps_cloc(arg)(kont)(cenv)(body)(menv)

    // Recursive CPS closure - use helper
    #CloK: λ&cenv. λ&body.
      @omni_apply_cps_clok(arg)(kont)(cenv)(body)(menv)

    // Captured continuation - call it! (no nested pattern match needed)
    #Kont: λ&saved_k.
      // Apply saved continuation to argument, then pass result to current k
      (λ&result. (kont(result)))((saved_k(arg)))

    // Regular closure from outside reset - use helper
    #Clo: λ&cenv. λ&body.
      @omni_apply_cps_clo(arg)(kont)(cenv)(body)(menv)

    // Recursive closure from outside reset - use helper
    #CloR: λ&cenv. λ&body.
      @omni_apply_cps_clor(arg)(kont)(cenv)(body)(menv)

    _ : λ&u_. #Err{#sym_app}
  }(func)

// Helpers for CPS apply - extract menv components FIRST using strict bindings,
// then use those components with a simple lambda (no pattern match)
@omni_apply_cps_cloc = λ&arg. λ&kont. λ&cenv. λ&body. λ&menv.
  // Extract menv components first using strict bindings
  !!&parts = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. #E4{e, h, p, l}; _: λ&u_. #E4{#NIL, #NIL, #Noth, #Cst{0}}})(menv);
  !!&handlers = (λ{#E4: λ&e. λ&h. λ&p. λ&l. h})(parts);
  !!&parent = (λ{#E4: λ&e. λ&h. λ&p. λ&l. p})(parts);
  !!&level = (λ{#E4: λ&e. λ&h. λ&p. λ&l. l})(parts);
  // Now we can use all variables safely (no pattern match with outer vars)
  @omni_eval_cps(#MEnv{#CON{arg, cenv}, handlers, parent, level})(body)(kont)

@omni_apply_cps_clok = λ&arg. λ&kont. λ&cenv. λ&body. λ&menv.
  // Extract menv components first
  !!&parts = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. #E4{e, h, p, l}; _: λ&u_. #E4{#NIL, #NIL, #Noth, #Cst{0}}})(menv);
  !!&handlers = (λ{#E4: λ&e. λ&h. λ&p. λ&l. h})(parts);
  !!&parent = (λ{#E4: λ&e. λ&h. λ&p. λ&l. p})(parts);
  !!&level = (λ{#E4: λ&e. λ&h. λ&p. λ&l. l})(parts);
  (λ&self.
    (λ&env1.
      @omni_eval_cps(#MEnv{#CON{arg, env1}, handlers, parent, level})(body)(kont)
    )(#CON{self, cenv})
  )(#CloK{cenv, body})

@omni_apply_cps_clo = λ&arg. λ&kont. λ&cenv. λ&body. λ&menv.
  // Extract menv components first
  !!&parts = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. #E4{e, h, p, l}; _: λ&u_. #E4{#NIL, #NIL, #Noth, #Cst{0}}})(menv);
  !!&handlers = (λ{#E4: λ&e. λ&h. λ&p. λ&l. h})(parts);
  !!&parent = (λ{#E4: λ&e. λ&h. λ&p. λ&l. p})(parts);
  !!&level = (λ{#E4: λ&e. λ&h. λ&p. λ&l. l})(parts);
  (λ&result. (kont(result)))(@omni_eval(#MEnv{#CON{arg, cenv}, handlers, parent, level})(body))

@omni_apply_cps_clor = λ&arg. λ&kont. λ&cenv. λ&body. λ&menv.
  // Extract menv components first
  !!&parts = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. #E4{e, h, p, l}; _: λ&u_. #E4{#NIL, #NIL, #Noth, #Cst{0}}})(menv);
  !!&handlers = (λ{#E4: λ&e. λ&h. λ&p. λ&l. h})(parts);
  !!&parent = (λ{#E4: λ&e. λ&h. λ&p. λ&l. p})(parts);
  !!&level = (λ{#E4: λ&e. λ&h. λ&p. λ&l. l})(parts);
  (λ&self.
    (λ&env1.
      (λ&result. (kont(result)))(@omni_eval(#MEnv{#CON{arg, env1}, handlers, parent, level})(body))
    )(#CON{self, cenv})
  )(#CloR{cenv, body})

// =============================================================================
// Algebraic Effects (CPS-based with Continuation Capture)
// =============================================================================
//
// Algebraic effects are implemented using CPS-based delimited continuations.
// When an effect is performed, the current continuation is captured and passed
// to the handler as the "resume" function. The handler can:
// - Call resume once (normal resumption)
// - Call resume multiple times (multi-shot continuations)
// - Not call resume (abort/exception-like behavior)
//
// Structure:
// - #Hdlr{tag, handler_fn}: Handler definition (tag is nick-encoded effect name)
// - #Kont{k}: Captured continuation (resume function)
//
// Example:
//   (handle
//     (+ 1 (perform 'ask nil))
//     ('ask (fn [payload resume] (resume 42))))
//   ; => 43
//
// Flow:
// 1. (handle ...) installs handlers and evaluates body in CPS mode
// 2. (perform 'ask nil) captures continuation k = (λ&v. (+ 1 v))
// 3. Handler receives (nil, #Kont{k})
// 4. (resume 42) invokes k with 42 => (+ 1 42) => 43

// Evaluate handler definitions into #Hdlr nodes
// Input: list of (tag handler-fn) pairs
// Output: list of #Hdlr{tag, closure} nodes
@omni_eval_handlers = λ&menv. λ&hdlrs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&evaluated_h. #CON{evaluated_h, @omni_eval_handlers(menv)(t)})(@omni_eval_one_handler(menv)(h))
  }(hdlrs)

@omni_eval_one_handler = λ&menv. λ&h.
  // Handler is #HDef{tag, fn_expr} in AST
  // or could be a cons cell (tag . fn)
  λ{
    #HDef: λ&tag. λ&fn_expr.
      (λ&handler_fn. #Hdlr{tag, handler_fn})(@omni_eval(menv)(fn_expr))
    #CON: λ&tag. λ&fn_part.
      // (tag . fn) form
      (λ&tag_val.
        (λ&fn_val.
          (λ&tag_nick. #Hdlr{tag_nick, fn_val})((λ{#Sym: λ&n. n; #Cst: λ&n. n; _: λ&u_. 0})(tag_val))
        )((λ{#CON: λ&f. λ&ux. @omni_eval(menv)(f); _: λ&u_. @omni_eval(menv)(fn_part)})(fn_part))
      )(@omni_eval(menv)(tag))
    _: λ&u_. h  // Already evaluated
  }(h)

// Handle with CPS - entry point from direct mode
// Installs handlers and evaluates body in CPS mode
// IMPORTANT: Uses helper to avoid HVM4 closure capture bug where pattern match
// arms don't capture outer lambda parameters correctly
@omni_handle_cps = λ&menv. λ&handlers. λ&body. λ&k.
  @omni_handle_cps_impl(handlers)(body)(k)(menv)

// Helper for handle_cps that takes handlers before menv pattern match
// This ensures handlers is properly captured in the pattern match arm
@omni_handle_cps_impl = λ&hdlrs. λ&body_expr. λ&kont. λ&menv.
  λ{
    #MEnv: λ&env. λ&old_handlers. λ&parent. λ&level.
      // Evaluate handler definitions (using hdlrs which is properly captured)
      (λ&evaluated_handlers.
        // Push new handlers onto stack
        (λ&new_handlers.
          // Create new menv with handlers installed
          (λ&new_menv.
            // Evaluate body in CPS mode - use defunctionalized continuation
            @omni_eval_cps(new_menv)(kont)(body_expr)
          )(#MEnv{env, new_handlers, parent, level})
        )(@omni_list_append(evaluated_handlers)(old_handlers))
      )(@omni_eval_handlers(#MEnv{env, old_handlers, parent, level})(hdlrs))
    _: λ&u_. #Err{#sym_handle_cps}
  }(menv)

// Perform effect in CPS mode - searches for handler and invokes with continuation
// IMPORTANT: Uses helper to avoid HVM4 closure capture bug
@omni_perform_cps = λ&menv. λ&tag. λ&payload. λ&resume_k.
  @omni_perform_cps_impl(tag)(payload)(resume_k)(menv)

// Helper - takes tag/payload/resume_k before menv pattern match for proper capture
@omni_perform_cps_impl = λ&tg. λ&pay. λ&res_k. λ&menv.
  λ{
    #MEnv: λ&env. λ&handlers. λ&parent. λ&level.
      // Pass reconstructed menv to avoid consuming the original
      @omni_find_handler_cps(#MEnv{env, handlers, parent, level})(handlers)(tg)(pay)(res_k)
    _: λ&u_. #Err{#sym_perform_cps}
  }(menv)

// Find handler in handler list
// IMPORTANT: Uses helper to avoid HVM4 closure capture bug
@omni_find_handler_cps = λ&menv. λ&handlers. λ&tag. λ&payload. λ&resume_k.
  @omni_find_handler_impl(menv)(tag)(payload)(resume_k)(handlers)

// Helper - takes captured vars before handlers pattern match
@omni_find_handler_impl = λ&menv. λ&tg. λ&pay. λ&res_k. λ&handlers.
  λ{
    #NIL:
      // No handler found locally - propagate to parent menv if available
      @omni_propagate_to_parent(menv)(tg)(pay)(res_k)
    #CON: λ&h. λ&t.
      (λ&matched.
        λ{
          1: @omni_invoke_handler_cps(menv)(h)(pay)(res_k)
          _: λ&u_. @omni_find_handler_impl(menv)(tg)(pay)(res_k)(t)
        }(matched)
      )(@omni_handler_matches(h)(tg))
  }(handlers)

// Propagate effect to parent menv when not handled locally
@omni_propagate_to_parent = λ&menv. λ&tg. λ&pay. λ&res_k.
  λ{
    #MEnv: λ&env. λ&handlers. λ&parent. λ&level.
      λ{
        #Noth: #Err{#sym_nohandler, tg}
        #MEnv: λ&penv. λ&phandlers. λ&pparent. λ&plevel.
          // Propagate to parent - search in parent's handlers
          @omni_find_handler_cps(parent)(phandlers)(tg)(pay)(res_k)
        _: λ&u_. #Err{#sym_nohandler, tg}
      }(parent)
    _: λ&u_. #Err{#sym_nohandler, tg}
  }(menv)

@omni_handler_matches = λ&handler. λ&tag.
  // Handler is #Hdlr{effect_tag, handler_fn}
  // tag might be #Sym{nick} or just a nick number - extract nick if needed
  !!&tag_num = (λ{#Sym: λ&n. n; _: λ&u_. tag})(tag);
  λ{
    #Hdlr: λ&htag. λ&hfn. (htag == tag_num)
    _: λ&u_. 0
  }(handler)

// Invoke a matched handler with payload and resume continuation
// IMPORTANT: Uses helper to avoid HVM4 closure capture bug
@omni_invoke_handler_cps = λ&menv. λ&handler. λ&payload. λ&resume_k.
  @omni_invoke_handler_impl(payload)(resume_k)(handler)(menv)

// Helper - takes payload/resume before menv/handler pattern matches for proper capture
// IMPORTANT: Handler body is evaluated in CPS mode with parent menv for effect propagation
@omni_invoke_handler_impl = λ&pay. λ&res_k. λ&handler. λ&menv.
  λ{
    #MEnv: λ&env. λ&handlers. λ&parent. λ&level.
      // Match handler
      λ{
        #Hdlr: λ&htag. λ&hfn.
          // Handler receives (payload, resume)
          // Handler fn is 2-arg: (fn [payload resume] ...)
          // Apply handler to payload to get partial (closure waiting for resume)
          (λ&partial.
            // Get the parent menv (for effect propagation from handler body)
            (λ&parent_menv.
              // Apply partial to resume continuation
              // The closure body may perform effects which will propagate to parent handlers
              @omni_invoke_handler_body(parent_menv)(partial)(res_k)
            )(@omni_get_parent_or_current(parent)(menv))
          )(@omni_apply(menv)(hfn)(pay))
        _: λ&u_. #Err{#sym_invoke_handler}
      }(handler)
    _: λ&u_. #Err{#sym_invoke_handler_menv}
  }(menv)

// Get parent menv if available, otherwise current menv
@omni_get_parent_or_current = λ&parent. λ&current.
  λ{
    #Noth: current
    #MEnv: λ&e. λ&h. λ&p. λ&l. parent
    _: λ&u_. current
  }(parent)

// Invoke handler body: apply closure to resume_k, evaluate body in CPS mode
// This allows performs inside the handler body to propagate to outer handlers
@omni_invoke_handler_body = λ&menv. λ&closure. λ&resume_k.
  λ{
    #Clo: λ&cenv. λ&body.
      // Extend closure env with resume_k, evaluate body in CPS mode
      @omni_eval_cps(@omni_menv_set_env(menv)(#CON{resume_k, cenv}))(#KId)(body)
    #CloC: λ&cenv. λ&body.
      @omni_eval_cps(@omni_menv_set_env(menv)(#CON{resume_k, cenv}))(#KId)(body)
    _: λ&u_.
      // Fallback: apply normally (may not support inner performs)
      @omni_apply(menv)(closure)(resume_k)
  }(closure)

// =============================================================================
// Proof-as-Effect System (Contract Verification)
// =============================================================================
//
// Proof obligations are expressed as algebraic effects:
// - (perform require predicate) - precondition check
// - (perform ensure predicate) - postcondition check
// - (perform prove goal) - request proof from handler
//
// Handlers can:
// 1. Evaluate predicates directly (runtime checking)
// 2. Attempt automatic proof search (SUP-powered)
// 3. Accept proofs from context
// 4. Abort with contract violation

// Standard proof handler that evaluates predicates at runtime
// Usage: (handle body (reqr [pred resume] ...) (ensr [pred resume] ...))
@omni_proof_handler_runtime = λ&menv.
  #CON{
    #Hdlr{@omni_nick_reqr,
      λ&pred. λ&resume.
        // Evaluate the predicate
        !!&result = @omni_eval(menv)(pred);
        !!&is_true = @omni_truthy(result);
        λ{
          1: // Predicate satisfied, continue
            λ{#Kont: λ&k. (k(#NIL))}(resume)
          _: λ&u_. // Precondition violated
            #Err{#ContractViolation, #sym_require, pred, result}
        }(is_true)},
    #CON{
      #Hdlr{@omni_nick_ensr,
        λ&pred. λ&resume.
          // Evaluate the predicate
          !!&result = @omni_eval(menv)(pred);
          !!&is_true = @omni_truthy(result);
          λ{
            1: // Postcondition satisfied, continue
              λ{#Kont: λ&k. (k(#NIL))}(resume)
            _: λ&u_. // Postcondition violated
              #Err{#ContractViolation, #sym_ensure, pred, result}
          }(is_true)},
      #NIL}}

// Nick-encoded effect tags for proof system
@omni_nick_reqr = 1374401  // omni_nick("reqr")
@omni_nick_ensr = 575286   // omni_nick("ensr")
@omni_nick_prov = 1378742  // omni_nick("prov")

// Check if a value is truthy (non-zero, non-nil, non-false)
@omni_truthy = λ&val.
  λ{
    #Cst: λ&n. (n != 0)
    #NIL: 0
    #Noth: 0
    #Fals: 0
    #True: 1
    _: λ&u_. 1  // Other values are truthy
  }(val)

// Proof handler with automatic proof search (SUP-powered)
// When predicate evaluation fails, attempts to construct a proof
@omni_proof_handler_auto = λ&menv. λ&context.
  #CON{
    #Hdlr{@omni_nick_reqr,
      λ&pred. λ&resume.
        // First try direct evaluation
        !!&result = @omni_eval(menv)(pred);
        !!&is_true = @omni_truthy(result);
        λ{
          1: λ{#Kont: λ&k. (k(#NIL))}(resume)
          _: λ&u_.
            // Try automatic proof search
            !!&proof_result = @omni_auto_prove_predicate(menv)(pred)(context);
            λ{
              #PrSc: λ&proof.
                // Proof found, continue
                λ{#Kont: λ&k. (k(proof))}(resume)
              _: λ&u_.
                #Err{#ContractViolation, #sym_require, pred, result}
            }(proof_result)
        }(is_true)},
    #CON{
      #Hdlr{@omni_nick_ensr,
        λ&pred. λ&resume.
          !!&result = @omni_eval(menv)(pred);
          !!&is_true = @omni_truthy(result);
          λ{
            1: λ{#Kont: λ&k. (k(#NIL))}(resume)
            _: λ&u_.
              !!&proof_result = @omni_auto_prove_predicate(menv)(pred)(context);
              λ{
                #PrSc: λ&proof.
                  λ{#Kont: λ&k. (k(proof))}(resume)
                _: λ&u_.
                  #Err{#ContractViolation, #sym_ensure, pred, result}
              }(proof_result)
          }(is_true)},
      #CON{
        #Hdlr{@omni_nick_prov,
          λ&goal. λ&resume.
            // Handle explicit proof request
            !!&proof_result = @omni_auto_prove_predicate(menv)(goal)(context);
            λ{
              #PrSc: λ&proof.
                λ{#Kont: λ&k. (k(proof))}(resume)
              _: λ&u_.
                #Err{#ProofFailed, goal}
            }(proof_result)},
        #NIL}}}

// Automatic proof attempt for a predicate
// Uses SUP for parallel exploration of proof strategies
@omni_auto_prove_predicate = λ&menv. λ&pred. λ&context.
  λ{
    // Equality check: (= a b)
    #Eql: λ&a. λ&b.
      (λ&va.
        (λ&a_val.
          (λ&vb.
            (λ&eq.
              λ{
                1: #PrSc{#PrRf{a_val}}  // Reflexivity proof
                _: λ&u_.
                  // Try more sophisticated proof search via SUP
                  &Proof{
                    @omni_try_refl_proof(a_val)(vb),
                    &ProofSym{@omni_try_sym_proof(a_val)(vb)(context),
                    &ProofTr{@omni_try_trans_proof(a_val)(vb)(context),
                    #PrFl{#not_equal}}}}
              }(eq)
            )((a_val == vb))
          )(@omni_eval(menv)(b))
        )(va)
      )(@omni_eval(menv)(a))

    // Comparison: (> a b), (< a b), etc.
    #Lt: λ&a. λ&b.
      (λ&va.
        (λ&a_val.
          (λ&vb.
            (λ&lt. λ{1: #PrSc{#PrBy{#lt_check}}; _: λ&u_. #PrFl{#lt_failed}}(lt))((λ{#Cst: λ&x. λ{#Cst: λ&y. (x < y); _: λ&u_. 0}(vb); _: λ&u_. 0})(a_val))
          )(@omni_eval(menv)(b))
        )(va)
      )(@omni_eval(menv)(a))

    #Gt: λ&a. λ&b.
      (λ&va.
        (λ&a_val.
          (λ&vb.
            (λ&gt. λ{1: #PrSc{#PrBy{#gt_check}}; _: λ&u_. #PrFl{#gt_failed}}(gt))((λ{#Cst: λ&x. λ{#Cst: λ&y. (x > y); _: λ&u_. 0}(vb); _: λ&u_. 0})(a_val))
          )(@omni_eval(menv)(b))
        )(va)
      )(@omni_eval(menv)(a))

    #Le: λ&a. λ&b.
      (λ&va.
        (λ&a_val.
          (λ&vb.
            (λ&le. λ{1: #PrSc{#PrBy{#le_check}}; _: λ&u_. #PrFl{#le_failed}}(le))((λ{#Cst: λ&x. λ{#Cst: λ&y. (x <= y); _: λ&u_. 0}(vb); _: λ&u_. 0})(a_val))
          )(@omni_eval(menv)(b))
        )(va)
      )(@omni_eval(menv)(a))

    #Ge: λ&a. λ&b.
      (λ&va.
        (λ&a_val.
          (λ&vb.
            (λ&ge. λ{1: #PrSc{#PrBy{#ge_check}}; _: λ&u_. #PrFl{#ge_failed}}(ge))((λ{#Cst: λ&x. λ{#Cst: λ&y. (x >= y); _: λ&u_. 0}(vb); _: λ&u_. 0})(a_val))
          )(@omni_eval(menv)(b))
        )(va)
      )(@omni_eval(menv)(a))

    // Negation: (not P)
    #Not: λ&p.
      (λ&vp.
        (λ&is_false. λ{1: #PrSc{#PrBy{#not_check}}; _: λ&u_. #PrFl{#not_failed}}(is_false))((λ{#Cst: λ&n. (n == 0); #NIL: 1; #Fals: 1; _: λ&u_. 0})(vp))
      )(@omni_eval(menv)(p))

    // And: (and P Q)
    #And: λ&p. λ&q.
      (λ&pp.
        (λ&pq.
          λ{
            #PrSc: λ&pf1.
              λ{
                #PrSc: λ&pf2. #PrSc{#AndI{pf1, pf2}}
                _: λ&u_. #PrFl{#and_right_failed}
              }(pq)
            _: λ&u_. #PrFl{#and_left_failed}
          }(pp)
        )(@omni_auto_prove_predicate(menv)(q)(context))
      )(@omni_auto_prove_predicate(menv)(p)(context))

    // Or: (or P Q)
    #Or: λ&p. λ&q.
      // Try left disjunct first
      (λ&pp.
        λ{
          #PrSc: λ&pf. #PrSc{#OrI1{pf}}
          _: λ&u_.
            // Try right disjunct
            (λ&pq.
              λ{
                #PrSc: λ&pf. #PrSc{#OrI2{pf}}
                _: λ&u_. #PrFl{#or_failed}
              }(pq)
            )(@omni_auto_prove_predicate(menv)(q)(context))
        }(pp)
      )(@omni_auto_prove_predicate(menv)(p)(context))

    // Default: evaluate and check truthiness
    _: λ&u_.
      (λ&result.
        (λ&is_true.
          λ{
            1: #PrSc{#PrBy{#eval_true}}
            _: λ&u_. #PrFl{#eval_false}
          }(is_true)
        )(@omni_truthy(result))
      )(@omni_eval(menv)(pred))
  }(pred)

// Proof search strategies
@omni_try_refl_proof = λ&a. λ&b.
  λ{1: #PrSc{#PrRf{a}}; _: λ&u_. #PrFl{#not_refl}}((a == b))

@omni_try_sym_proof = λ&a. λ&b. λ&ctx.
  // Look for b = a in context
  @omni_find_equality_in_context(b)(a)(ctx)

@omni_try_trans_proof = λ&a. λ&b. λ&ctx.
  // Look for intermediate c where a = c and c = b in context
  // This is simplified - full implementation would enumerate context
  #PrFl{#no_trans}

@omni_find_equality_in_context = λ&lhs. λ&rhs. λ&ctx.
  λ{
    #NIL: #PrFl{#not_in_ctx}
    #CON: λ&h. λ&t.
      λ{
        #Eq: λ&a. λ&b.
          (λ&match.
            λ{
              1: #PrSc{#PrSm{#PrRf{lhs}}}  // Found, return sym(refl)
              _: λ&u_. @omni_find_equality_in_context(lhs)(rhs)(t)
            }(match)
          )(((a == lhs) * (b == rhs)))
        _: λ&u_. @omni_find_equality_in_context(lhs)(rhs)(t)
      }(h)
  }(ctx)

// Wrap a body with the standard runtime proof handler
// Usage: @omni_with_proof_checking(menv)(body)
@omni_with_proof_checking = λ&menv. λ&body.
  !!&handlers = @omni_proof_handler_runtime(menv);
  @omni_handle_cps(menv)(handlers)(body)(#KId)

// Wrap a body with the auto-proving handler
// Usage: @omni_with_auto_proof(menv)(context)(body)
@omni_with_auto_proof = λ&menv. λ&context. λ&body.
  !!&handlers = @omni_proof_handler_auto(menv)(context);
  @omni_handle_cps(menv)(handlers)(body)(#KId)

// =============================================================================
// Concurrency (Fiber-based with CPS Continuations)
// =============================================================================
//
// Fibers are implemented using CPS-captured continuations. When a fiber yields,
// it captures the current continuation as a #Kont and stores it in the fiber.
// When resumed, the continuation is invoked with the resume value.
//
// Fiber structure: #Fibr{state, continuation, mailbox}
// - state: #FbrR (running), #FbrS (suspended), #FbrD (done)
// - continuation: #Kont{k} for suspended, result for done, thunk for new
// - mailbox: list of pending messages

// Fiber states
@omni_fbr_running   = #FbrR{}
@omni_fbr_suspended = #FbrS{}
@omni_fbr_done      = #FbrD{}

// Create a new fiber from a thunk (zero-arg function)
// The thunk should be an expression that may yield
@omni_fiber_new = λ&thunk.
  #Fibr{#FbrS, #FThk{thunk}, #NIL}

// Spawn a fiber and start it (runs until first yield or completion)
@omni_fiber_spawn = λ&menv. λ&body.
  !!&fibr = #Fibr{#FbrR, #FThk{body}, #NIL};
  @omni_fiber_run(menv)(fibr)

// Run a fiber until it yields or completes
// Returns the updated fiber
@omni_fiber_run = λ&menv. λ&fibr.
  λ{
    #Fibr: λ&state. λ&cont. λ&mailbox.
      λ{
        // Already done - return as-is
        #FbrD: fibr

        // Running or suspended - execute
        _: λ&u_.
          λ{
            // Fresh thunk - start in CPS mode
            #FThk: λ&body.
              (λ&result. @omni_fiber_handle_result(result)(mailbox))(@omni_eval_cps(menv)(body)(λ&v. v))

            // Captured continuation - resume it
            #Kont: λ&k.
              // Resume with unit (or could take a value)
              (λ&result. @omni_fiber_handle_result(result)(mailbox))((k(#NIL)))

            // Already have a result
            _: λ&u_. #Fibr{#FbrD, cont, mailbox}
          }(cont)
      }(state)
  }(fibr)

// Handle result of fiber execution
@omni_fiber_handle_result = λ&result. λ&mailbox.
  λ{
    // Fiber yielded - capture continuation
    #FYld: λ&val. λ&k.
      #Fibr{#FbrS, k, #CON{val, mailbox}}

    // Normal completion
    _: λ&u_. #Fibr{#FbrD, result, mailbox}
  }(result)

// Resume a suspended fiber with a value
@omni_fiber_resume = λ&menv. λ&fibr. λ&val.
  λ{
    #Fibr: λ&state. λ&cont. λ&mailbox.
      λ{
        #FbrS:
          λ{
            #Kont: λ&k.
              (λ&result. @omni_fiber_handle_result(result)(mailbox))((k(val)))
            _: λ&u_. #Err{#sym_notsusp}
          }(cont)
        #FbrD: fibr  // Already done
        _: λ&u_. #Err{#sym_fiberstate}
      }(state)
  }(fibr)

// Check if fiber is done
@omni_fiber_done_p = λ&fibr.
  λ{
    #Fibr: λ&state. λ&cont. λ&mailbox.
      λ{
        #FbrD: #True{}
        _: λ&u_. #Fals{}
      }(state)
  }(fibr)

// Get fiber result (only valid if done)
@omni_fiber_result = λ&fibr.
  λ{
    #Fibr: λ&state. λ&cont. λ&mailbox.
      λ{
        #FbrD: cont
        _: λ&u_. #Err{#sym_notdone}
      }(state)
  }(fibr)

// Get yielded values from mailbox
@omni_fiber_mailbox = λ&fibr.
  λ{
    #Fibr: λ&state. λ&cont. λ&mailbox. mailbox
  }(fibr)

// Yield a value from within a fiber (must be inside reset/CPS mode)
// This is handled specially by @omni_eval_cps when it sees #Yld
// Usage: (yield val) where yield is bound to this
@omni_yield = λ&val.
  #Yld{val}

// =============================================================================
// Concurrency (Fork/Join with HVM4 SUP)
// =============================================================================

// Fork two computations (uses HVM4 superposition)
@omni_fork2 = λ&a. λ&b.
  // HVM4 superposition: both branches evaluate in parallel
  &F{a, b}

// Choice between multiple options
@omni_choice = λ&opts.
  λ{
    #NIL: #Err{#sym_nochoice}
    #CON: λ&h. λ&t.
      λ{
        #NIL: h
        _: λ&u_. &C{h, @omni_choice(t)}
      }(t)
  }(opts)

// =============================================================================
// Tower: Reflect (Value → Code)
// =============================================================================
//
// Reflect converts a runtime value into its code representation.
// This is used for quotation and multi-stage programming.

@omni_reflect = λ&val.
  λ{
    // Literals become Lit nodes
    #Cst: λ&n. #Lit{n}
    #CHR: λ&c. #CHR{c}
    #Sym: λ&s. #Sym{s}

    // Nil
    #NIL: #QQ{#NIL}

    // Cons - recursively reflect
    #CON: λ&h. λ&t.
      λ{
        // Check if string (list of chars)
        #CHR: λ&ux. #QQ{val}  // Quote strings as-is
        _: λ&u_. #QQ{#CON{@omni_reflect(h), @omni_reflect(t)}}
      }(h)

    // Closures reflect as their body (opaque)
    #Clo: λ&env. λ&body. body
    #CloR: λ&env. λ&body. body

    // Compiled lambdas preserve structure
    #CLam: λ&env. λ&body. #CLam{env, body}

    // Staged code stays as-is
    #Stag: λ&level. λ&expr. #Stag{level, expr}

    // Arrays
    #Arr: λ&elems. #QQ{#Arr{@omni_reflect_list(elems)}}

    // Booleans
    #True: #QQ{#True{}}
    #Fals: #QQ{#Fals{}}

    // Nothing
    #Noth: #QQ{#Noth{}}

    // Default: quote as-is
    _: λ&u_. #QQ{val}
  }(val)

// Reflect a list
@omni_reflect_list = λ&list.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. #CON{@omni_reflect(h), @omni_reflect_list(t)}
    _: λ&u_. list
  }(list)

// =============================================================================
// Tower: Reify (Code → Value)
// =============================================================================
//
// Reify executes code representation to produce a value.
// This is the inverse of reflect - it "runs" quoted code.

@omni_reify = λ&menv. λ&code.
  λ{
    // Literal becomes constant
    #Lit: λ&n. #Cst{n}

    // Quoted code - unwrap and reify inner
    #QQ: λ&inner. @omni_reify(menv)(inner)

    // Staged code - force evaluation
    #Stag: λ&level. λ&expr. @omni_eval(menv)(expr)

    // Compiled lambda becomes closure
    #CLam: λ&env. λ&body. #Clo{env, body}

    // Cons - reify both parts
    #CON: λ&h. λ&t.
      #CON{@omni_reify(menv)(h), @omni_reify(menv)(t)}

    // Values pass through
    #Cst: λ&n. #Cst{n}
    #CHR: λ&c. #CHR{c}
    #Sym: λ&s. #Sym{s}
    #NIL: #NIL
    #True: #True{}
    #Fals: #Fals{}
    #Noth: #Noth{}
    #Clo: λ&e. λ&b. #Clo{e, b}
    #CloR: λ&e. λ&b. #CloR{e, b}

    // For other code forms, evaluate them
    _: λ&u_. @omni_eval(menv)(code)
  }(code)

// =============================================================================
// Type Checking (Runtime)
// =============================================================================

@omni_type_of = λ&val.
  λ{
    #Cst: λ&n. #sym_Int
    #Fix: λ&hi. λ&lo. λ&scale. #sym_Float
    #CHR: λ&c. #sym_Char
    #Sym: λ&s. #sym_Symbol
    #CON: λ&h. λ&t. #sym_List
    #NIL: #sym_List
    #Clo: λ&e. λ&b. #sym_Function
    #CloR: λ&e. λ&b. #sym_Function
    #Hndl: λ&idx. λ&gen. #sym_Handle
    #True: #sym_Bool
    #Fals: #sym_Bool
    #Noth: #sym_Nothing
    _: λ&u_. #sym_Unknown
  }(val)

@omni_is_type = λ&val. λ&type.
  λ{
    1: #True{}
    _: λ&u_. #Fals{}
  }((@omni_type_of(val) == type))

// =============================================================================
// Type Descriptors (for multiple dispatch)
// =============================================================================

// Built-in type descriptors: #TDsc{name, parent, fields}
@type_Any      = #TDsc{111513, #NIL, #NIL}           // omni_nick("Any")
@type_Nothing  = #TDsc{10548488, @type_Any, #NIL}    // omni_nick("Noth")
@type_Int      = #TDsc{144276, @type_Any, #NIL}      // omni_nick("Int")
@type_Float    = #TDsc{8438740, @type_Any, #NIL}     // omni_nick("Flot")
@type_Bool     = #TDsc{7402444, @type_Any, #NIL}     // omni_nick("Bool")
@type_Char     = #TDsc{7635026, @type_Any, #NIL}     // omni_nick("Char")
@type_Symbol   = #TDsc{185933, @type_Any, #NIL}      // omni_nick("Sym")
@type_String   = #TDsc{11879561, @type_Any, #NIL}    // nick("Stri") - parser truncates "String" to 4 chars
@type_Function = #TDsc{132430, @type_Any, #NIL}      // omni_nick("Fun")
@type_Handle   = #TDsc{8970508, @type_Any, #NIL}     // omni_nick("Hndl")

// Sequence types (abstract parent for polymorphic dispatch)
@type_Sequence = #TDsc{184657, @type_Any, #NIL}      // omni_nick("Seq")
@type_List     = #TDsc{9999572, @type_Sequence, #NIL}  // omni_nick("List")
@type_Array    = #TDsc{111762, @type_Sequence, #NIL}   // omni_nick("Arr")
@type_Dict     = #TDsc{7901396, @type_Any, #NIL}       // omni_nick("Dict")
@type_Iterator = #TDsc{9257298, @type_Sequence, #NIL}  // omni_nick("Iter")
@type_Range    = #TDsc{11539335, @type_Sequence, #NIL} // omni_nick("Rang")

// DEBUG: Direct test of @type_Int without going through @omni_eval
@omni_test_direct_compare =
  λ{
    #TDsc: λ&name_a. λ&ux. λ&ux.
      λ{
        #TCon: λ&name_b.
          #CON{(name_a + 0), #CON{(name_b + 0), #CON{(name_a == name_b), #NIL}}}
      }(#TCon{144276})
  }(@type_Int)

// =============================================================================
// Math Helpers
// =============================================================================

// Compute 10^n (for fixed-point scale conversion)
@omni_pow10 = λ&n.
  λ{
    0: 1
    1: 10
    2: 100
    3: 1000
    4: 10000
    5: 100000
    6: 1000000
    7: 10000000
    8: 100000000
    9: 1000000000
    _: λ&u_. (10 * @omni_pow10((n - 1)))  // Recursive fallback
  }(n)

// =============================================================================
// List Helpers
// =============================================================================

@omni_list_length = λ&xs.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t. (1 + @omni_list_length(t))
  }(xs)

// Sum of list elements (assumes all elements are #Cst)
@omni_list_sum = λ&xs.
  λ{
    #NIL: #Cst{0}
    #CON: λ&h. λ&t.
      (λ&hval. (λ&tsum.
        λ{
          #Cst: λ&tv. #Cst{(hval + tv)}
          _: λ&u_. #Cst{hval}
        }(tsum)
      )(@omni_list_sum(t)))(@omni_unwrap_num(h))
  }(xs)

@omni_append = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @omni_append(t)(ys)}
  }(xs)

@omni_reverse = λ&xs.
  @omni_reverse_acc(xs)(#NIL)

@omni_reverse_acc = λ&xs. λ&acc.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t. @omni_reverse_acc(t)(#CON{h, acc})
  }(xs)

// Take first n elements from list
@omni_take = λ&n. λ&xs.
  λ{
    #Cst: λ&count.
      λ{
        0: #NIL
        _: λ&u_.
          λ{
            #NIL: #NIL
            #CON: λ&h. λ&t. #CON{h, @omni_take(#Cst{(count - 1)})(t)}
          }(xs)
      }(count)
    _: λ&u_. xs  // non-numeric n, return whole list
  }(n)

// Drop first n elements from list
@omni_drop = λ&n. λ&xs.
  λ{
    #Cst: λ&count.
      λ{
        0: xs
        _: λ&u_.
          λ{
            #NIL: #NIL
            #CON: λ&h. λ&t. @omni_drop(#Cst{(count - 1)})(t)
          }(xs)
      }(count)
    _: λ&u_. #NIL  // non-numeric n, return empty
  }(n)

// Zip list of two lists together: ((a b) (x y)) -> ((a x) (b y))
@omni_zip_lists = λ&lists.
  λ{
    #CON: λ&first. λ&rest.
      λ{
        #CON: λ&second. λ&rest2.
          @omni_zip_two(first)(second)
        _: λ&u_. first  // only one list, return it
      }(rest)
    _: λ&u_. #NIL
  }(lists)

// Zip two lists: (a b c) (x y z) -> ((a x) (b y) (c z))
@omni_zip_two = λ&xs. λ&ys.
  λ{
    #NIL: #NIL
    #CON: λ&xh. λ&xt.
      λ{
        #NIL: #NIL
        #CON: λ&yh. λ&yt.
          #CON{#CON{xh, #CON{yh, #NIL}}, @omni_zip_two(xt)(yt)}
      }(ys)
  }(xs)

// =============================================================================
// Iterator Helpers
// =============================================================================

// Map over a list, applying a function to each element
@omni_iter_map = λ&menv. λ&xs. λ&fn.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{@omni_apply(menv)(fn)(h), @omni_iter_map(menv)(t)(fn)}
  }(xs)

// Filter a list, keeping elements where predicate returns true
@omni_iter_filter = λ&menv. λ&xs. λ&pred.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&result.
        λ{
          #True: #CON{h, @omni_iter_filter(menv)(t)(pred)}
          1: #CON{h, @omni_iter_filter(menv)(t)(pred)}
          _: λ&u_. @omni_iter_filter(menv)(t)(pred)
        }(result)
      )(@omni_apply(menv)(pred)(h))
  }(xs)

// Take elements while predicate returns true
@omni_iter_take_while = λ&menv. λ&xs. λ&pred.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&result.
        λ{
          #True: #CON{h, @omni_iter_take_while(menv)(t)(pred)}
          1: #CON{h, @omni_iter_take_while(menv)(t)(pred)}
          _: λ&u_. #NIL
        }(result)
      )(@omni_apply(menv)(pred)(h))
  }(xs)

// Drop elements while predicate returns true
@omni_iter_drop_while = λ&menv. λ&xs. λ&pred.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&result.
        λ{
          #True: @omni_iter_drop_while(menv)(t)(pred)
          1: @omni_iter_drop_while(menv)(t)(pred)
          _: λ&u_. xs
        }(result)
      )(@omni_apply(menv)(pred)(h))
  }(xs)

// Chain (concatenate) two lists/iterators
@omni_iter_chain = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @omni_iter_chain(t)(ys)}
  }(xs)

// Chain all lists in a list of lists
@omni_iter_chain_all = λ&lists.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. @omni_iter_chain(h)(@omni_iter_chain_all(t))
  }(lists)

// Enumerate: add index to each element, returning list of (index, element) pairs
@omni_iter_enumerate = λ&xs.
  @omni_iter_enumerate_from(0)(xs)

@omni_iter_enumerate_from = λ&idx. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{#CON{#Cst{idx}, #CON{h, #NIL}}, @omni_iter_enumerate_from((idx + 1))(t)}
  }(xs)

// Flat map: map then flatten
@omni_iter_flat_map = λ&menv. λ&xs. λ&fn.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&mapped.
        @omni_iter_chain(mapped)(@omni_iter_flat_map(menv)(t)(fn))
      )(@omni_apply(menv)(fn)(h))
  }(xs)

// Fold: reduce list with function and initial value
@omni_iter_fold = λ&menv. λ&xs. λ&init. λ&fn.
  λ{
    #NIL: init
    #CON: λ&h. λ&t.
      (λ&new_acc.
        @omni_iter_fold(menv)(t)(new_acc)(fn)
      )(
        // Apply fn to init, then apply result to h
        (λ&partial.
          @omni_apply(menv)(partial)(h)
        )(@omni_apply(menv)(fn)(init))
      )
  }(xs)

// Find: return first element matching predicate, or #Noth{}
@omni_iter_find = λ&menv. λ&xs. λ&pred.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      (λ&result.
        λ{
          #True: h
          1: h
          _: λ&u_. @omni_iter_find(menv)(t)(pred)
        }(result)
      )(@omni_apply(menv)(pred)(h))
  }(xs)

// Any: return true if any element matches predicate
@omni_iter_any = λ&menv. λ&xs. λ&pred.
  λ{
    #NIL: #Fals
    #CON: λ&h. λ&t.
      (λ&result.
        λ{
          #True: #True
          1: #True
          _: λ&u_. @omni_iter_any(menv)(t)(pred)
        }(result)
      )(@omni_apply(menv)(pred)(h))
  }(xs)

// All: return true if all elements match predicate
@omni_iter_all = λ&menv. λ&xs. λ&pred.
  λ{
    #NIL: #True
    #CON: λ&h. λ&t.
      (λ&result.
        λ{
          #True: @omni_iter_all(menv)(t)(pred)
          1: @omni_iter_all(menv)(t)(pred)
          _: λ&u_. #Fals
        }(result)
      )(@omni_apply(menv)(pred)(h))
  }(xs)

// Nth: get element at index (0-based), return #Noth{} if out of bounds
@omni_iter_nth = λ&xs. λ&idx.
  λ{
    #Cst: λ&i.
      λ{
        #NIL: #Noth{}
        #CON: λ&h. λ&t.
          λ{
            0: h
            _: λ&u_. @omni_iter_nth(t)(#Cst{(i - 1)})
          }(i)
      }(xs)
    _: λ&u_. #Noth{}
  }(idx)

// =============================================================================
// String Helpers
// =============================================================================

// Get character at index (0-based)
@omni_str_char_at = λ&str. λ&idx.
  λ{
    #Cst: λ&i. @omni_str_char_at_iter(str)(i)
    _: λ&u_. #Noth{}
  }(idx)

@omni_str_char_at_iter = λ&str. λ&idx.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      λ{
        0: h
        _: λ&u_. @omni_str_char_at_iter(t)((idx - 1))
      }(idx)
  }(str)

// Convert character to uppercase
@omni_char_upper = λ&c.
  λ{
    #CHR: λ&code.
      // a-z (97-122) -> A-Z (65-90)
      λ{
        1: #CHR{(code - 32)}
        _: λ&u_. c
      }(((code >= 97) * (code <= 122)))
    #Cst: λ&code.
      λ{
        1: #CHR{(code - 32)}
        _: λ&u_. #CHR{code}
      }(((code >= 97) * (code <= 122)))
    _: λ&u_. c
  }(c)

// Convert character to lowercase
@omni_char_lower = λ&c.
  λ{
    #CHR: λ&code.
      // A-Z (65-90) -> a-z (97-122)
      λ{
        1: #CHR{(code + 32)}
        _: λ&u_. c
      }(((code >= 65) * (code <= 90)))
    #Cst: λ&code.
      λ{
        1: #CHR{(code + 32)}
        _: λ&u_. #CHR{code}
      }(((code >= 65) * (code <= 90)))
    _: λ&u_. c
  }(c)

// Convert string to uppercase
@omni_str_upper = λ&str.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. #CON{@omni_char_upper(h), @omni_str_upper(t)}
  }(str)

// Convert string to lowercase
@omni_str_lower = λ&str.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. #CON{@omni_char_lower(h), @omni_str_lower(t)}
  }(str)

// Check if character is whitespace (space, tab, newline, carriage return)
@omni_char_whitespace = λ&c.
  λ{
    #CHR: λ&code.
      ((code == 32) || ((code == 9) || ((code == 10) || (code == 13))))
    #Cst: λ&code.
      ((code == 32) || ((code == 9) || ((code == 10) || (code == 13))))
    _: λ&u_. 0
  }(c)

// Trim leading whitespace
@omni_str_trim_left = λ&str.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        1: @omni_str_trim_left(t)
        _: λ&u_. str
      }(@omni_char_whitespace(h))
  }(str)

// Trim trailing whitespace
@omni_str_trim_right = λ&str.
  @omni_reverse(@omni_str_trim_left(@omni_reverse(str)))

// Trim both leading and trailing whitespace
@omni_str_trim = λ&str.
  @omni_str_trim_right(@omni_str_trim_left(str))

// Split string by delimiter character or string
@omni_str_split = λ&str. λ&delim.
  @omni_str_split_iter(str)(delim)(#NIL)

@omni_str_split_iter = λ&str. λ&delim. λ&current.
  λ{
    #NIL:
      λ{
        #NIL: #NIL  // Empty current means no trailing element
        _: λ&u_. #CON{@omni_reverse(current), #NIL}
      }(current)
    #CON: λ&h. λ&t.
      λ{
        #True: // Delimiter found at start
          (λ&match_result.
            λ{
              #Fals: // This shouldn't happen if starts_with was true
                @omni_str_split_iter(t)(delim)(#CON{h, current})
              _: λ&u_.
                // Delimiter matched, emit current string and continue
                #CON{@omni_reverse(current), @omni_str_split_iter(match_result)(delim)(#NIL)}
            }(match_result)
          )(@omni_str_match_delim(str)(delim))
        _: λ&u_. @omni_str_split_iter(t)(delim)(#CON{h, current})
      }(@omni_str_starts_with(str)(delim))
  }(str)

// Try to match delimiter at start of string, return remaining string if match
@omni_str_match_delim = λ&str. λ&delim.
  λ{
    #NIL: str  // Empty delimiter matches, return str as remaining
    #CON: λ&dh. λ&dt.
      λ{
        #NIL: #Fals{}  // String shorter than delimiter
        #CON: λ&sh. λ&st.
          λ{
            1: @omni_str_match_delim(st)(dt)
            _: λ&u_. #Fals{}
          }(@omni_char_eq(sh)(dh))
      }(str)
  }(delim)

// Check if two characters are equal
@omni_char_eq = λ&a. λ&b.
  (λ&ca. (λ&cb. (ca == cb))(@omni_char_code(b)))(@omni_char_code(a))

// Get character code
@omni_char_code = λ&c.
  λ{
    #CHR: λ&code. code
    #Cst: λ&code. code
    _: λ&u_. 0
  }(c)

// char->int: Get code point of first character of a string
// Input: string (list of #CHR) or single #CHR
// Output: #Cst{code_point}
@omni_char_to_int = λ&val.
  λ{
    // Single character
    #CHR: λ&code. #Cst{code}
    // String (list of chars) - get first char
    #CON: λ&h. λ&t.
      λ{
        #CHR: λ&code. #Cst{code}
        _: λ&u_. #Err{#sym_type}
      }(h)
    // Integer passed directly (allow passthrough)
    #Cst: λ&n. #Cst{n}
    _: λ&u_. #Err{#sym_type}
  }(val)

// int->char: Convert code point to single-character string
// Input: #Cst{code_point}
// Output: string (list with single #CHR)
@omni_int_to_char = λ&val.
  λ{
    #Cst: λ&code. #CON{#CHR{code}, #NIL}
    // Allow raw number
    _: λ&n. #CON{#CHR{n}, #NIL}
  }(val)

// Join list of strings with delimiter
@omni_str_join = λ&strs. λ&delim.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #NIL: h  // Single element, no delimiter needed
        _: λ&u_. @omni_append(h)(@omni_append(delim)(@omni_str_join(t)(delim)))
      }(t)
  }(strs)

// Replace all occurrences of 'old' with 'new' in string
@omni_str_replace = λ&str. λ&old. λ&new.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #True:
          // Match found - insert replacement and continue after match
          (λ&remaining.
            @omni_append(new)(@omni_str_replace(remaining)(old)(new))
          )(@omni_str_match_delim(str)(old))
        _: λ&u_.
          #CON{h, @omni_str_replace(t)(old)(new)}
      }(@omni_str_starts_with(str)(old))
  }(str)

// Get substring: (str-slice str start len)
@omni_str_slice = λ&str. λ&start. λ&len.
  (λ&st. (λ&ln.
    @omni_take(#Cst{ln})(@omni_drop(#Cst{st})(str))
  )(@omni_unwrap_num(len)))(@omni_unwrap_num(start))

// Unwrap numeric value
@omni_unwrap_num = λ&n.
  λ{
    #Cst: λ&x. x
    _: λ&u_. 0
  }(n)

// Find index of needle in string, returns #Cst{index} or #Noth{}
@omni_str_index_of = λ&str. λ&needle.
  @omni_str_index_of_iter(str)(needle)(0)

@omni_str_index_of_iter = λ&str. λ&needle. λ&idx.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      λ{
        #True: #Cst{idx}  // Found match
        _: λ&u_. @omni_str_index_of_iter(t)(needle)((idx + 1))
      }(@omni_str_starts_with(str)(needle))
  }(str)

// Check if string starts with prefix
@omni_str_starts_with = λ&str. λ&prefix.
  λ{
    #NIL: #True{}  // Empty prefix matches anything
    #CON: λ&ph. λ&pt.
      λ{
        #NIL: #Fals{}  // String shorter than prefix
        #CON: λ&sh. λ&st.
          λ{
            1: @omni_str_starts_with(st)(pt)
            _: λ&u_. #Fals{}
          }(@omni_char_eq(sh)(ph))
      }(str)
  }(prefix)

// Check if string ends with suffix
@omni_str_ends_with = λ&str. λ&suffix.
  @omni_str_starts_with(@omni_reverse(str))(@omni_reverse(suffix))

// Pad string to length with character
// side: 0 = left, 1 = right, 2 = both
// Note: We compute all values upfront and pass them explicitly to avoid closure capture issues
@omni_str_pad = λ&str. λ&len. λ&chr. λ&side.
  @omni_str_pad_core(str)(chr)(@omni_unwrap_num(side))(@omni_unwrap_num(len))(@omni_list_length(str))

// Core: receives str, chr, side (unwrapped), target, current
// Note: avoid _len suffix on both vars - causes HVM4 naming collision
@omni_str_pad_core = λ&str. λ&chr. λ&side. λ&target. λ&current.
  λ{
    0: str  // target <= current, no padding needed
    _: λ&u_. @omni_str_pad_do(str)(chr)(side)((target - current))
  }((target > current))

// Do the actual padding (all args computed)
@omni_str_pad_do = λ&str. λ&chr. λ&side. λ&pad_needed.
  λ{
    0: // Left pad
      @omni_append(@omni_str_repeat_char(chr)(pad_needed))(str)
    1: // Right pad
      @omni_append(str)(@omni_str_repeat_char(chr)(pad_needed))
    _: λ&u_. // Both (center) - pad_needed/2 on left, rest on right
      @omni_str_pad_center(str)(chr)(pad_needed)
  }(side)

// Center padding helper
@omni_str_pad_center = λ&str. λ&chr. λ&pad_needed.
  (λ&left_pad.
    @omni_append(@omni_str_repeat_char(chr)(left_pad))(
      @omni_append(str)(@omni_str_repeat_char(chr)((pad_needed - left_pad)))
    )
  )((pad_needed / 2))

// Repeat a single character n times
@omni_str_repeat_char = λ&chr. λ&n.
  λ{
    0: #NIL
    _: λ&u_. #CON{chr, @omni_str_repeat_char(chr)((n - 1))}
  }(n)

// Capitalize string (first char upper, rest unchanged)
@omni_str_capitalize = λ&str.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. #CON{@omni_char_upper(h), t}
  }(str)

// Repeat string n times
@omni_str_repeat = λ&str. λ&n.
  (λ&count. @omni_str_repeat_iter(str)(count))(@omni_unwrap_num(n))

// Helper: iterate string repeat with raw count
@omni_str_repeat_iter = λ&str. λ&count.
  λ{
    0: #NIL
    _: λ&u_. @omni_append(str)(@omni_str_repeat_iter(str)((count - 1)))
  }(count)

// Compare two strings lexicographically: returns -1, 0, or 1
// Constant for -1 (used for comparison results)
// #Fix{4294967295, 4294967295, 0} represents -1
@omni_neg_one = #Fix{4294967295, 4294967295, 0}

@omni_str_compare = λ&str1. λ&str2.
  λ{
    #NIL:
      λ{
        #NIL: #Cst{0}  // Both empty, equal
        _: λ&u_. @omni_neg_one  // str1 shorter
      }(str2)
    #CON: λ&h1. λ&t1.
      λ{
        #NIL: #Cst{1}  // str2 shorter
        #CON: λ&h2. λ&t2.
          (λ&c1. (λ&c2.
            λ{
              1: @omni_neg_one  // c1 < c2
              _: λ&u_.
                λ{
                  1: #Cst{1}  // c1 > c2
                  _: λ&u_. @omni_str_compare(t1)(t2)  // c1 == c2
                }((c1 > c2))
            }((c1 < c2))
          )(@omni_char_code(h2)))(@omni_char_code(h1))
      }(str2)
  }(str1)

// String length (alias for @omni_list_length for clarity)
@omni_str_length = λ&str. @omni_list_length(str)

// =============================================================================
// String to Int Conversion
// =============================================================================

// Convert a string (list of chars) to an integer
// Handles optional leading '-' for negative numbers
// Returns #Cst{n} on success, #Err{...} on failure
@omni_str_to_int = λ&str.
  λ{
    #NIL: #Err{#Sym{0}}  // Empty string is an error
    #CON: λ&h. λ&t.
      // Check for negative sign (ASCII 45 = '-')
      (λ&code.
        λ{
          45: // '-' sign
            λ{
              #NIL: #Err{#Sym{0}}  // Just "-" is an error
              _: λ&u_.
                // Parse the rest and negate
                (λ&result.
                  λ{
                    #Cst: λ&n. #Cst{(0 - n)}
                    #Err: λ&e. #Err{e}
                    _: λ&u_. #Err{#Sym{0}}
                  }(result)
                )(@omni_str_to_int_pos(t)(0))
            }(t)
          _: λ&u_.
            // Positive number - parse from beginning
            @omni_str_to_int_pos(str)(0)
        }(code)
      )(@omni_char_code(h))
    _: λ&u_. #Err{#Sym{0}}  // Not a list
  }(str)

// Parse positive integer from string, accumulating value
// str: remaining characters to parse
// acc: accumulated value so far
@omni_str_to_int_pos = λ&str. λ&acc.
  λ{
    #NIL: #Cst{acc}  // End of string, return accumulated value
    #CON: λ&h. λ&t.
      (λ&code.
        // Check if digit (ASCII 48-57 = '0'-'9')
        // Use nested conditions: first check >= 48, then check <= 57
        λ{
          1: // code >= 48
            λ{
              1: // code <= 57, it's a digit
                (λ&digit. @omni_str_to_int_pos(t)(((acc * 10) + digit)))((code - 48))
              _: λ&u_. #Err{#Sym{0}}  // code > 57, not a digit
            }((code <= 57))
          _: λ&u_. #Err{#Sym{0}}  // code < 48, not a digit
        }((code >= 48))
      )(@omni_char_code(h))
    _: λ&u_. #Err{#Sym{0}}  // Not a list
  }(str)

// =============================================================================
// Int to String Conversion
// =============================================================================

// Convert an integer to a string (list of chars)
@omni_int_to_str = λ&n.
  λ{
    #Cst: λ&val.
      λ{
        // Handle zero specially
        0: #CON{#CHR{48}, #NIL}  // "0"
        _: λ&u_.
          λ{
            // Negative number
            1: #CON{#CHR{45}, @omni_int_to_str_pos((0 - val))}  // "-" + digits
            _: λ&u_. @omni_int_to_str_pos(val)  // Positive
          }((val < 0))
      }(val)
    _: λ&u_. #NIL  // Not a number
  }(n)

// Convert positive integer to string (list of chars)
// Builds list in reverse, then reverses at end
@omni_int_to_str_pos = λ&n.
  @omni_reverse(@omni_int_to_str_rev(n))

// Build digits in reverse order (easier for HVM)
@omni_int_to_str_rev = λ&n.
  λ{
    0: #NIL  // Base case: no more digits
    _: λ&u_.
      (λ&digit. (λ&rest.
        #CON{#CHR{(digit + 48)}, @omni_int_to_str_rev(rest)}
      )((n / 10)))((n % 10))
  }(n)

// =============================================================================
// IO Helper Functions
// =============================================================================

// Print a value (string as list of chars) - outputs each char via FFI
// Returns #NIL on success
@omni_print_val = λ&val.
  λ{
    #NIL: #NIL  // Done, return empty list
    #CON: λ&h. λ&t.
      // Putc the char, then recurse on the tail
      // Use seq pattern: force putc, then return recursive result
      !!&result = @omni_putc(h);
      !!&rest = @omni_print_val(t);
      #CON{result, rest}  // Build result list to force evaluation
    // For non-string values, return #NIL
    _: λ&u_. #NIL
  }(val)

// Test function to see what @omni_putc produces
@test_putc = λ&c. @omni_putc(c)

// Debug: check what a value looks like when pattern matched
@debug_print_match = λ&val.
  λ{
    #NIL: #Sym{2}  // 0 = nil case
    #CON: λ&h. λ&t. h  // return the head to show it matched CON
    _: λ&u. #Sym{1}  // 1 = unknown case
  }(val)

// Print with newline - must return something that depends on printed + newline to force eval
@omni_println_val = λ&val.
  !!&printed = @omni_print_val(val);
  !!&newline = @omni_putc(#CHR{10});
  // Return a list containing both to force their evaluation
  #CON{printed, #CON{newline, #NIL}}


// Put a single character via FFI
// putc nick = ((((16 << 6) + 21) << 6) + 20) << 6 + 3 = 4281603
@omni_putc = λ&chr.
  λ{
    #CHR: λ&c. #FFI{4281603, #CON{#Cst{c}, #NIL}}
    _: λ&u_. #NIL
  }(chr)

// Get a single character from stdin via FFI
// getc nick = ((((7 << 6) + 5) << 6) + 20) << 6 + 3 = 1856771
@omni_getc =
  #FFI{1856771, #NIL}

// Read a line from stdin - reads until newline or EOF
@omni_read_line_stdin =
  @omni_read_line_iter(#NIL)

// Helper: accumulate characters until newline (char 10) or EOF (-1)
@omni_read_line_iter = λ&acc.
  (λ&c.
    λ{
      10: @omni_reverse(acc)  // Newline - done, reverse to get correct order
      _: λ&u_.
        λ{
          1: @omni_reverse(acc)  // EOF (c <= -1, which wraps to large number)
          _: λ&u_. @omni_read_line_iter(#CON{#CHR{c}, acc})
        }((c >= 4294967295))  // Check for wrapped -1 (EOF)
    }(c)
  )(@omni_getc_raw)

// Get raw char code (unwrapped) from FFI getc
@omni_getc_raw =
  (λ&result.
    λ{
      #Cst: λ&n. n
      _: λ&u_. 4294967295  // Return -1 equivalent on error
    }(result)
  )(#FFI{1856771, #NIL})

// Getenv - get environment variable
// FFI nick: GtEv = 8734678
// Returns char list on success, #Noth{} on failure
@omni_getenv = λ&name.
  #FFI{8734678, #CON{name, #NIL}}

// Setenv - set environment variable
// FFI nick: StEv = 11880406
// Returns #True on success, #Fals on failure
@omni_setenv = λ&name. λ&val.
  #FFI{11880406, #CON{name, #CON{val, #NIL}}}

// Read file - read entire file as char list
// FFI nick: RdFl = 11552780
// Returns char list on success, #Err{errno} on failure
@omni_read_file = λ&path.
  #FFI{11552780, #CON{path, #NIL}}

// Write file - write char list to file
// FFI nick: WrFl = 12920844
// Returns #True on success, #Err{errno} on failure
@omni_write_file = λ&path. λ&content.
  #FFI{12920844, #CON{path, #CON{content, #NIL}}}

// Append file - append char list to file
// FFI nick: ApFl = 7145484
// Returns #True on success, #Err{errno} on failure
@omni_append_file = λ&path. λ&content.
  #FFI{7145484, #CON{path, #CON{content, #NIL}}}

// File exists - check if file exists
// FFI nick: Exst = 8226004
// Returns #True or #Fals
@omni_file_exists = λ&path.
  #FFI{8226004, #CON{path, #NIL}}

// Is directory - check if path is a directory
// FFI nick: IsDr = 9254802
// Returns #True or #Fals
@omni_is_dir = λ&path.
  #FFI{9254802, #CON{path, #NIL}}

// Make directory - create a new directory
// FFI nick: MkDr = 10270610
// Returns #True on success, #Err{errno} on failure
@omni_mkdir = λ&path.
  #FFI{10270610, #CON{path, #NIL}}

// List directory - list directory contents
// FFI nick: LsDr = 10041234
// Returns list of filenames on success, #Err{errno} on failure
@omni_list_dir = λ&path.
  #FFI{10041234, #CON{path, #NIL}}

// Delete file - remove a file
// FFI nick: DlFl = 7915532
// Returns #True on success, #Err{errno} on failure
@omni_delete_file = λ&path.
  #FFI{7915532, #CON{path, #NIL}}

// Rename file - rename or move a file
// FFI nick: RnFl = 11593740
// Returns #True on success, #Err{errno} on failure
@omni_rename_file = λ&from. λ&to.
  #FFI{11593740, #CON{from, #CON{to, #NIL}}}

// Copy file - copy a file
// FFI nick: CpFl = 7669772
// Returns #True on success, #Err{errno} on failure
@omni_copy_file = λ&from. λ&to.
  #FFI{7669772, #CON{from, #CON{to, #NIL}}}


// =============================================================================
// End IO Helper Functions
// =============================================================================

// =============================================================================
// DateTime Helper Functions
// =============================================================================

// DateTime now - get current datetime
// FFI nick: DtNw = 7948823
// Returns #Dt{year, month, day, hour, min, sec, nsec}
@omni_dt_now = λ&u.
  #FFI{7948823, #NIL}

// DateTime year - extract year from datetime
// FFI nick: DtYr = 7949522
@omni_dt_year = λ&dt.
  #FFI{7949522, #CON{dt, #NIL}}

// DateTime month - extract month from datetime
// FFI nick: DtMo = 7948751
@omni_dt_month = λ&dt.
  #FFI{7948751, #CON{dt, #NIL}}

// DateTime day - extract day from datetime
// FFI nick: DtDy = 7948185
@omni_dt_day = λ&dt.
  #FFI{7948185, #CON{dt, #NIL}}

// DateTime hour - extract hour from datetime
// FFI nick: DtHr = 7948434
@omni_dt_hour = λ&dt.
  #FFI{7948434, #CON{dt, #NIL}}

// DateTime minute - extract minute from datetime
// FFI nick: DtMi = 7948745
@omni_dt_minute = λ&dt.
  #FFI{7948745, #CON{dt, #NIL}}

// DateTime second - extract second from datetime
// FFI nick: DtSc = 7949123
@omni_dt_second = λ&dt.
  #FFI{7949123, #CON{dt, #NIL}}

// DateTime to timestamp - convert datetime to Unix timestamp
// FFI nick: DtTs = 7949203
@omni_dt_to_timestamp = λ&dt.
  #FFI{7949203, #CON{dt, #NIL}}

// DateTime from timestamp - convert Unix timestamp to datetime
// FFI nick: DtFt = 7948308
@omni_dt_from_timestamp = λ&ts.
  #FFI{7948308, #CON{ts, #NIL}}

// DateTime add - add seconds to datetime
// FFI nick: DtAd = 7947972
@omni_dt_add = λ&dt. λ&secs.
  #FFI{7947972, #CON{dt, #CON{secs, #NIL}}}

// DateTime subtract - subtract seconds from datetime
// FFI nick: DtSb = 7949122
@omni_dt_sub = λ&dt. λ&secs.
  #FFI{7949122, #CON{dt, #CON{secs, #NIL}}}

// DateTime diff - difference in seconds between two datetimes
// FFI nick: DtDf = 7948166
@omni_dt_diff = λ&dt1. λ&dt2.
  #FFI{7948166, #CON{dt1, #CON{dt2, #NIL}}}

// DateTime format - format datetime as string
// FFI nick: DtFm = 7948301
@omni_dt_format = λ&dt. λ&fmt.
  #FFI{7948301, #CON{dt, #CON{fmt, #NIL}}}

// DateTime parse - parse string to datetime
// FFI nick: DtPr = 7948946
@omni_dt_parse = λ&str. λ&fmt.
  #FFI{7948946, #CON{str, #CON{fmt, #NIL}}}

// =============================================================================
// End DateTime Helper Functions
// =============================================================================

// Integer square root - find largest k where k*k <= n
@omni_isqrt = λ&n.
  λ{
    #Cst: λ&x.
      λ{
        0: #Cst{0}
        _: λ&u_. @omni_isqrt_search(x)(0)(x)
      }(x)
    _: λ&u_. #Cst{0}
  }(n)

// Binary search for sqrt: find largest k where k*k <= n
// lo <= sqrt(n) <= hi
@omni_isqrt_search = λ&n. λ&lo. λ&hi.
  (λ&mid.
    (λ&sq.
      λ{
        #True:  // sq <= n: answer is mid or higher
          λ{
            #True: #Cst{mid}  // lo >= hi: done
            _: λ&u_. @omni_isqrt_search(n)((mid + 1))(hi)
          }(@omni_ge(#Cst{lo})(#Cst{hi}))
        _: λ&u_.  // sq > n: answer is lower than mid
          @omni_isqrt_search(n)(lo)((mid - 1))
      }(@omni_le(#Cst{sq})(#Cst{n}))
    )((mid * mid))
  )(((lo + hi) / 2))

// Integer power: base^exp
@omni_ipow = λ&base. λ&exp.
  λ{
    #Cst: λ&b.
      λ{
        #Cst: λ&e.
          λ{
            0: #Cst{1}
            1: base
            _: λ&u_. @omni_ipow_iter(b)(e)(1)
          }(e)
        _: λ&u_. #Cst{1}
      }(exp)
    _: λ&u_. #Cst{0}
  }(base)

@omni_ipow_iter = λ&base. λ&exp. λ&acc.
  λ{
    0: #Cst{acc}
    _: λ&u_. @omni_ipow_iter(base)((exp - 1))((acc * base))
  }(exp)

// Map function over list (parallel - head and tail evaluated in parallel)
@omni_map = λ&f. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      !!&head_result = f(h);
      !!&tail_result = @omni_map(f)(t);
      #CON{head_result, tail_result}
  }(xs)

// Filter list by predicate (parallel)
@omni_filter = λ&p. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      !!&pred_result = p(h);
      !!&tail_result = @omni_filter(p)(t);
      λ{
        1: #CON{h, tail_result}
        _: tail_result
      }(pred_result)
  }(xs)

// Left fold (sequential - accumulator threading)
@omni_foldl = λ&f. λ&acc. λ&xs.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t. @omni_foldl(f)(f(acc)(h))(t)
  }(xs)

// Right fold (parallel for recursive call)
@omni_foldr = λ&f. λ&acc. λ&xs.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t.
      !!&tail_result = @omni_foldr(f)(acc)(t);
      f(h)(tail_result)
  }(xs)

// =============================================================================
// Polymorphic Sequence Operations
// =============================================================================
// These functions dispatch on type: List, Array, Dict, Iterator
// All use @omni_apply to invoke OmniLisp closures properly

// Map with @omni_apply - applies OmniLisp function to each element
// Polymorphic: List → List, Array → Array, Dict → Dict (over values), Iterator → Iterator
@omni_map_apply = λ&menv. λ&fn. λ&xs.
  λ{
    // List
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{@omni_apply(menv)(fn)(h), @omni_map_apply(menv)(fn)(t)}
    // Array - map over data, preserve length
    #Arr: λ&len. λ&data.
      #Arr{len, @omni_map_apply(menv)(fn)(data)}
    // Dict - map over values, preserve keys
    #Dict: λ&entries.
      #Dict{@omni_map_apply(menv)(λ&pair.
        λ{#CON: λ&k. λ&rest.
          λ{#CON: λ&v. λ&u.
            #CON{k, #CON{@omni_apply(menv)(fn)(v), #NIL}}
          }(rest)
        }(pair)
      )(entries)}
    // Iterator - lazy map
    #Iter: λ&state. λ&next_fn.
      #Iter{xs, λ&i. @omni_map_iter_next(menv)(fn)(i)}
    // Range - convert to mapped iterator
    #Rang: λ&s. λ&e. λ&st.
      #Iter{xs, λ&i. @omni_map_iter_next(menv)(fn)(i)}
  }(xs)

// Helper: map iterator next function
@omni_map_iter_next = λ&menv. λ&fn. λ&iter.
  (λ&stepped.
    λ{
      #Some: λ&v. λ&rest. #Some{@omni_apply(menv)(fn)(v), @omni_map_apply(menv)(fn)(rest)}
      #None: #None{}
    }(stepped)
  )(@omni_iter_next(iter))

// Generic iterator step (handles Iter and Rang)
@omni_iter_next = λ&iter.
  λ{
    #Iter: λ&state. λ&next_fn. next_fn(state)
    #Rang: λ&cur. λ&end. λ&step.
      λ{
        1: #None{}
        _: #Some{cur, #Rang{(cur + step), end, step}}
      }((cur >= end))
    _: λ&u_. #None{}
  }(iter)

// Filter with @omni_apply - keeps elements where predicate returns truthy
// Polymorphic: List → List, Array → Array, Dict → Dict (by value), Iterator → Iterator
@omni_filter_apply = λ&menv. λ&pred. λ&xs.
  λ{
    // List
    #NIL: #NIL
    #CON: λ&h. λ&t.
      @omni_filter_one(menv)(pred)(h)(@omni_filter_apply(menv)(pred)(t))
    // Array - filter data, recompute length
    #Arr: λ&len. λ&data.
      (λ&filtered. #Arr{@omni_list_length(filtered), filtered})(@omni_filter_apply(menv)(pred)(data))
    // Dict - filter by value predicate
    #Dict: λ&entries.
      #Dict{@omni_filter_apply(menv)(λ&pair.
        λ{#CON: λ&k. λ&rest.
          λ{#CON: λ&v. λ&u. @omni_apply(menv)(pred)(v)}(rest)
        }(pair)
      )(entries)}
    // Iterator - lazy filter
    #Iter: λ&state. λ&next_fn.
      #Iter{xs, λ&i. @omni_filter_iter_next(menv)(pred)(i)}
    // Range - convert to filtered iterator
    #Rang: λ&s. λ&e. λ&st.
      #Iter{xs, λ&i. @omni_filter_iter_next(menv)(pred)(i)}
  }(xs)

// Helper: filter iterator next function
@omni_filter_iter_next = λ&menv. λ&pred. λ&iter.
  (λ&stepped.
    λ{
      #Some: λ&v. λ&rest.
        @omni_filter_iter_check(menv)(pred)(v)(rest)
      #None: #None{}
    }(stepped)
  )(@omni_iter_next(iter))

// Helper: check filter predicate and continue if false
@omni_filter_iter_check = λ&menv. λ&pred. λ&v. λ&rest.
  (λ&result.
    λ{
      #Fals: @omni_filter_iter_next(menv)(pred)(rest)
      #Noth: @omni_filter_iter_next(menv)(pred)(rest)
      #Cst: λ&n. λ{0: @omni_filter_iter_next(menv)(pred)(rest); _: λ&u_. #Some{v, @omni_filter_apply(menv)(pred)(rest)}}(n)
      _: λ&u_. #Some{v, @omni_filter_apply(menv)(pred)(rest)}
    }(result)
  )(@omni_apply(menv)(pred)(v))

// Helper: filter a single element, prepend if truthy
@omni_filter_one = λ&menv. λ&pred. λ&h. λ&tail.
  (λ&result.
    λ{
      #Fals: tail
      #Noth: tail
      #Cst: λ&n. λ{0: tail; _: λ&u_. #CON{h, tail}}(n)
      _: λ&u_. #CON{h, tail}
    }(result)
  )(@omni_apply(menv)(pred)(h))

// Left fold with @omni_apply - applies curried OmniLisp function
// Polymorphic: List, Array, Dict (values), Iterator
@omni_foldl_apply = λ&menv. λ&fn. λ&acc. λ&xs.
  λ{
    // List
    #NIL: acc
    #CON: λ&h. λ&t.
      (λ&new_acc. @omni_foldl_apply(menv)(fn)(new_acc)(t))(@omni_apply(menv)(@omni_apply(menv)(fn)(acc))(h))
    // Array - fold over data
    #Arr: λ&len. λ&data.
      @omni_foldl_apply(menv)(fn)(acc)(data)
    // Dict - fold over values
    #Dict: λ&entries.
      @omni_foldl_apply(menv)(λ&a. λ&pair.
        λ{#CON: λ&k. λ&rest.
          λ{#CON: λ&v. λ&u. @omni_apply(menv)(@omni_apply(menv)(fn)(a))(v)}(rest)
        }(pair)
      )(acc)(entries)
    // Iterator - materialize and fold
    #Iter: λ&state. λ&next_fn.
      @omni_foldl_iter(menv)(fn)(acc)(xs)
    // Range - iterate and fold
    #Rang: λ&s. λ&e. λ&st.
      @omni_foldl_iter(menv)(fn)(acc)(xs)
  }(xs)

// Helper: fold over iterator
@omni_foldl_iter = λ&menv. λ&fn. λ&acc. λ&iter.
  (λ&stepped.
    λ{
      #Some: λ&v. λ&rest.
        (λ&new_acc. @omni_foldl_iter(menv)(fn)(new_acc)(rest))(@omni_apply(menv)(@omni_apply(menv)(fn)(acc))(v))
      #None: acc
    }(stepped)
  )(@omni_iter_next(iter))

// Right fold with @omni_apply
// Polymorphic: List, Array (note: foldr on iterators would need to materialize)
@omni_foldr_apply = λ&menv. λ&fn. λ&acc. λ&xs.
  λ{
    // List
    #NIL: acc
    #CON: λ&h. λ&t.
      (λ&tail_result.
        @omni_apply(menv)(@omni_apply(menv)(fn)(h))(tail_result)
      )(@omni_foldr_apply(menv)(fn)(acc)(t))
    // Array - foldr over data
    #Arr: λ&len. λ&data.
      @omni_foldr_apply(menv)(fn)(acc)(data)
    // Dict - foldr over values
    #Dict: λ&entries.
      @omni_foldr_apply(menv)(λ&elem. λ&a.
        λ{#CON: λ&k. λ&rest.
          λ{#CON: λ&v. λ&u. @omni_apply(menv)(@omni_apply(menv)(fn)(v))(a)}(rest)
        }(elem)
      )(acc)(entries)
  }(xs)

// =============================================================================
// Pipe Operator Helpers
// =============================================================================

// Thread value through a list of forms
// Each form is either a function or (fn arg1 arg2 ...) where value is inserted first
@omni_pipe_thread = λ&menv. λ&val. λ&forms.
  λ{
    #NIL: val
    #CON: λ&form. λ&rest.
      (λ&result. @omni_pipe_thread(menv)(result)(rest))(@omni_pipe_apply(menv)(val)(form))
  }(forms)

// Apply a pipe form to a value
// Form is either: function f → (f val)
//                 or (f args...) → (f val args...)
@omni_pipe_apply = λ&menv. λ&val. λ&form.
  λ{
    // Form is (fn arg1 arg2 ...) - insert val as first arg
    #App: λ&fn. λ&arg.
      // Reconstruct: (fn val original-args...)
      (λ&fn_val.
        (λ&applied_to_val.
          // Now apply the remaining arg
          (λ&arg_val. @omni_apply(menv)(applied_to_val)(arg_val))(@omni_eval(menv)(arg))
        )(@omni_apply(menv)(fn_val)(val))
      )(@omni_eval(menv)(fn))

    // Form is just a function reference - apply directly
    #Var: λ&i.
      (λ&fn. @omni_apply(menv)(fn)(val))(@omni_eval(menv)(form))

    #Sym: λ&s.
      (λ&fn. @omni_apply(menv)(fn)(val))(@omni_eval(menv)(form))

    // Form is a closure - apply directly
    #Clo: λ&e. λ&b.
      @omni_apply(menv)(form)(val)

    #CloR: λ&e. λ&b.
      @omni_apply(menv)(form)(val)

    // Generic: evaluate and apply
    _: λ&u_.
      (λ&fn. @omni_apply(menv)(fn)(val))(@omni_eval(menv)(form))
  }(form)

// Apply function to list of arguments
@omni_apply_list = λ&menv. λ&fn. λ&args.
  λ{
    #NIL: fn  // No args left - return (possibly partial) result
    #CON: λ&h. λ&t.
      (λ&applied. @omni_apply_list(menv)(applied)(t))(@omni_apply(menv)(fn)(h))
  }(args)

// Apply function to list of args in CPS mode (for named let inside reset/handle)
@omni_apply_list_cps = λ&menv. λ&fn. λ&args. λ&k.
  λ{
    #NIL: (k(fn))  // No args left - return result to continuation
    #CON: λ&h. λ&t.
      @omni_apply_cps(menv)(fn)(h)(λ&applied.
        @omni_apply_list_cps(menv)(applied)(t)(k))
  }(args)

// =============================================================================
// Cond Evaluation
// =============================================================================

// Evaluate cond clauses until one test is truthy
@omni_eval_cond = λ&menv. λ&clauses.
  λ{
    #NIL: #Noth{}  // No clause matched
    #CON: λ&clause. λ&rest.
      λ{
        // Clause is #CCls{test, body}
        #CCls: λ&test. λ&body.
          (λ&t.
            λ{
              #Fals: @omni_eval_cond(menv)(rest)
              #Cst: λ&n. λ{
                0: @omni_eval_cond(menv)(rest)
                _: λ&u_. @omni_eval(menv)(body)
              }(n)
              #Noth: @omni_eval_cond(menv)(rest)
              #True: @omni_eval(menv)(body)
              _: λ&u_. @omni_eval(menv)(body)  // Any other truthy value
            }(t)
          )(@omni_eval(menv)(test))
        // Also handle [test body] as a pair
        #CON: λ&test. λ&body_rest.
          λ{
            #CON: λ&body. λ&ux.
              (λ&t.
                λ{
                  #Fals: @omni_eval_cond(menv)(rest)
                  #Cst: λ&n. λ{
                    0: @omni_eval_cond(menv)(rest)
                    _: λ&u_. @omni_eval(menv)(body)
                  }(n)
                  #Noth: @omni_eval_cond(menv)(rest)
                  _: λ&u_. @omni_eval(menv)(body)
                }(t)
              )(@omni_eval(menv)(test))
            _: λ&u_. @omni_eval_cond(menv)(rest)
          }(body_rest)
        _: λ&u_. @omni_eval_cond(menv)(rest)
      }(clause)
  }(clauses)

// =============================================================================
// Path Access Functions
// =============================================================================

// Get value from collection by key
// Key can be #Cst{n} for indexed access or #Sym{s} for alist/dict lookup
// Uses same pattern as @nth for extracting from list
// Note: key is consumed by the switch, so we extract what we need in each branch
@omni_get = λ&coll. λ&key.
  λ{
    // Numeric key - check if coll is dict first, otherwise use index
    #Cst: λ&n.
      λ{
        // For dicts, use numeric key lookup
        #Dict: λ&entries. @omni_dict_get(entries)(#Cst{n})
        // For lists, use index access
        #NIL: #Noth{}
        #CON: λ&h. λ&t.
          λ{
            0: h
            _: λ&u_. @omni_get(t)(#Cst{(n - 1)})
          }(n)
        #Arr: λ&len. λ&data. @omni_get(data)(#Cst{n})
        _: λ&u_. #Noth{}
      }(coll)
    // Symbol key - use alist or dict lookup
    #Sym: λ&s.
      λ{
        #CON: λ&h. λ&t. @omni_alist_get(coll)(#Sym{s})
        #Dict: λ&entries. @omni_dict_get(entries)(#Sym{s})
        _: λ&u_. #Noth{}
      }(coll)
    // String key (as #Str) - use dict lookup
    #Str: λ&chars.
      λ{
        #Dict: λ&entries. @omni_dict_get(entries)(#Str{chars})
        _: λ&u_. #Noth{}
      }(coll)
    // List key (strings are char lists, also could be general list keys)
    #CON: λ&h. λ&t.
      λ{
        // Check if coll is a dict
        #Dict: λ&entries. @omni_dict_get(entries)(key)
        // Otherwise check if coll is an alist
        #CON: λ&ch. λ&ct. @omni_alist_get(coll)(key)
        _: λ&u_. #Noth{}
      }(coll)
    // Other key types
    _: λ&u_. #Noth{}
  }(key)

// Get from alist (association list) by key
// Rebind rest/key before inner switch to fix de Bruijn levels
@omni_alist_get = λ&alist. λ&key.
  λ{
    #NIL: #Noth{}
    #CON: λ&pair. λ&rest.
      // Rebind rest and key here BEFORE entering inner switch
      !&rest2 = rest;
      !&key2 = key;
      λ{
        #CON: λ&k. λ&v_rest.
          !!&matches = @omni_values_equal(k)(key2);
          λ{
            1: λ{#CON: λ&v. λ&ux. v; _: #Noth{}}(v_rest)
            0: @omni_alist_get(rest2)(key2)
          }(matches)
        _: @omni_alist_get(rest2)(key2)
      }(pair)
  }(alist)

// Get from dict entries - rebind rest/key before inner switch to fix de Bruijn levels
@omni_dict_get = λ&entries. λ&key.
  λ{
    #NIL: #Noth{}
    #CON: λ&pair. λ&rest.
      // Rebind rest and key here BEFORE entering inner switch
      !&rest2 = rest;
      !&key2 = key;
      λ{
        #CON: λ&k. λ&v_rest.
          !!&matches = @omni_values_equal(k)(key2);
          λ{
            1: λ{#CON: λ&v. λ&ux. v; _: #Noth{}}(v_rest)
            0: @omni_dict_get(rest2)(key2)
          }(matches)
        _: @omni_dict_get(rest2)(key2)
      }(pair)
  }(entries)

// Put into dict - returns new dict with key=value
// If key exists, updates; otherwise prepends
// If value is #Noth{}, removes the key (dissoc behavior)
@omni_dict_put = λ&dict. λ&key. λ&value.
  λ{
    #Dict: λ&entries.
      // Check if value is #Noth{} - if so, just remove key (dissoc)
      λ{
        #Noth: #Dict{@omni_dict_remove_key(entries)(key)}
        _: λ&u_. #Dict{#CON{#CON{key, #CON{value, #NIL}}, @omni_dict_remove_key(entries)(key)}}
      }(value)
    _: λ&u_.
      // For list/array, treat as array-set
      λ{
        #CON: λ&h. λ&t. @omni_list_set(dict)(key)(value)
        #Arr: λ&len. λ&data. #Arr{len, @omni_list_set(data)(key)(value)}
        _: λ&u_. #Err{#sym_cannot_put}
      }(dict)
  }(dict)

// Remove key from dict entries
// Rebind rest/key/pair before inner switch to fix de Bruijn levels
@omni_dict_remove_key = λ&entries. λ&key.
  λ{
    #NIL: #NIL
    #CON: λ&pair. λ&rest.
      // Rebind variables BEFORE entering inner switch
      !&rest2 = rest;
      !&key2 = key;
      !&pair2 = pair;
      λ{
        #CON: λ&k. λ&v_rest.
          !!&matches = @omni_values_equal(k)(key2);
          λ{
            1: @omni_dict_remove_key(rest2)(key2)  // skip this entry
            0: #CON{pair2, @omni_dict_remove_key(rest2)(key2)}
          }(matches)
        _: #CON{pair2, @omni_dict_remove_key(rest2)(key2)}
      }(pair)
  }(entries)

// Merge two dict entry lists (d2 wins on conflict)
@omni_dict_merge = λ&entries1. λ&entries2.
  λ{
    #NIL: entries1
    #CON: λ&pair. λ&rest.
      // Add each entry from entries2, overwriting keys in entries1
      λ{
        #CON: λ&k. λ&v_rest.
          λ{
            #CON: λ&v. λ&tail.
              // entries1 with key removed, then prepend pair
              !&e1 = @omni_dict_remove_key(entries1)(k);
              #CON{pair, @omni_dict_merge(e1)(rest)}
            _: λ&u_. @omni_dict_merge(entries1)(rest)
          }(v_rest)
        _: λ&u_. @omni_dict_merge(entries1)(rest)
      }(pair)
  }(entries2)

// Set element at index in list
@omni_list_set = λ&list. λ&idx. λ&val.
  λ{
    #Cst: λ&i.
      λ{
        #NIL: #NIL
        #CON: λ&h. λ&t.
          λ{
            0: #CON{val, t}
            _: λ&u_. #CON{h, @omni_list_set(t)(#Cst{(i - 1)})(val)}
          }(i)
      }(list)
    _: λ&u_. list
  }(idx)

// Get element at index from list (returns #Noth{} if out of bounds)
@omni_list_nth = λ&list. λ&idx.
  λ{
    #Cst: λ&i.
      λ{
        #NIL: #Noth{}
        #CON: λ&h. λ&t.
          λ{
            0: h
            _: λ&u_. @omni_list_nth(t)(#Cst{(i - 1)})
          }(i)
      }(list)
    _: λ&u_. #Noth{}
  }(idx)

// Get last element of list
@omni_list_last = λ&list.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t.
      λ{
        #NIL: h
        #CON: λ&h2. λ&t2. @omni_list_last(t)
      }(t)
  }(list)

// Get all but last element of list
@omni_list_init = λ&list.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #NIL: #NIL
        #CON: λ&h2. λ&t2. #CON{h, @omni_list_init(t)}
      }(t)
  }(list)

// Slice: get elements from start to end (exclusive)
// Returns array for array input, list for list input
@omni_slice = λ&coll. λ&start. λ&end.
  λ{
    #Arr: λ&len. λ&data.
      (λ&st. (λ&en.
        (λ&sliced. #Arr{@omni_list_length(sliced), sliced})
        (@omni_take(#Cst{(en - st)})(@omni_drop(#Cst{st})(data)))
      )(@omni_unwrap_num(end)))(@omni_unwrap_num(start))
    #CON: λ&h. λ&t.
      (λ&st. (λ&en.
        (λ&dropped. @omni_take(#Cst{(en - st)})(dropped))(@omni_drop(#Cst{st})(coll))
      )(@omni_unwrap_num(end)))(@omni_unwrap_num(start))
    _: λ&u_. #NIL
  }(coll)

// Get keys from dict entries
@omni_dict_keys = λ&entries.
  λ{
    #NIL: #NIL
    #CON: λ&pair. λ&rest.
      (λ&r.
        λ{
          #CON: λ&key. λ&val_rest. #CON{key, @omni_dict_keys(r)}
          _: λ&u_. @omni_dict_keys(r)
        }(pair)
      )(rest)
  }(entries)

// Get values from dict entries
@omni_dict_vals = λ&entries.
  λ{
    #NIL: #NIL
    #CON: λ&pair. λ&rest.
      (λ&r.
        λ{
          #CON: λ&key. λ&val_rest.
            λ{
              #CON: λ&val. λ&rest_. #CON{val, @omni_dict_vals(r)}
              _: λ&u2_. @omni_dict_vals(r)
            }(val_rest)
          _: λ&u_. @omni_dict_vals(r)
        }(pair)
      )(rest)
  }(entries)

// Flatten nested list (one level)
@omni_flatten = λ&nested.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #NIL: @omni_flatten(t)
        #CON: λ&h2. λ&t2. @omni_append(h)(@omni_flatten(t))
        _: λ&u_. #CON{h, @omni_flatten(t)}
      }(h)
    _: λ&u_. #NIL
  }(nested)

// Remove duplicates from a list (keeps first occurrence)
@omni_distinct = λ&list.
  @omni_distinct_acc(list)(#NIL)

@omni_distinct_acc = λ&list. λ&seen.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&already.
        λ{
          #True: @omni_distinct_acc(t)(seen)
          #Fals: #CON{h, @omni_distinct_acc(t)(#CON{h, seen})}
        }(already)
      )(@omni_member(h)(seen))
  }(list)

// Check if element is member of list
@omni_member = λ&elem. λ&list.
  λ{
    #NIL: #Fals
    #CON: λ&h. λ&t.
      (λ&eq.
        λ{
          #True: #True
          _: λ&u_. @omni_member(elem)(t)
        }(eq)
      )(@omni_eql(elem)(h))
  }(list)

// Partition list into groups of n elements
@omni_partition = λ&n. λ&list.
  λ{
    #Cst: λ&size.
      @omni_partition_iter(size)(list)
    _: λ&u_. #NIL
  }(n)

@omni_partition_iter = λ&size. λ&list.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      (λ&group. (λ&rest.
        #CON{group, @omni_partition_iter(size)(rest)}
      )(@omni_drop(#Cst{size})(list)))(@omni_take(#Cst{size})(list))
  }(list)

// Interleave multiple collections
@omni_interleave = λ&menv. λ&colls.
  λ{
    #NIL: #NIL
    #CON: λ&first. λ&rest.
      // Evaluate all collections first
      (λ&evaled_colls. @omni_interleave_iter(evaled_colls))
      (@omni_map_eval(menv)(colls))
  }(colls)

@omni_interleave_iter = λ&colls.
  // If any collection is empty, we're done
  (λ&all_non_empty.
    λ{
      #Fals: #NIL
      #True:
        // Get heads from all, then recurse with tails
        (λ&heads. (λ&tails.
          @omni_append(heads)(@omni_interleave_iter(tails))
        )(@omni_map_tail(colls)))(@omni_map_head(colls))
    }(all_non_empty)
  )(@omni_all_non_empty(colls))

// Check if all lists are non-empty
@omni_all_non_empty = λ&colls.
  λ{
    #NIL: #True
    #CON: λ&h. λ&t.
      λ{
        #NIL: #Fals
        #CON: λ&h2. λ&t2. @omni_all_non_empty(t)
        _: λ&u_. #Fals
      }(h)
  }(colls)

// Get head of each list
@omni_map_head = λ&colls.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&hd. λ&tl. #CON{hd, @omni_map_head(t)}
        _: λ&u_. @omni_map_head(t)
      }(h)
  }(colls)

// Get tail of each list
@omni_map_tail = λ&colls.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&hd. λ&tl. #CON{tl, @omni_map_tail(t)}
        _: λ&u_. #CON{#NIL, @omni_map_tail(t)}
      }(h)
  }(colls)

// Evaluate each element in a list
@omni_map_eval = λ&menv. λ&list.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{@omni_eval(menv)(h), @omni_map_eval(menv)(t)}
  }(list)

// Insert separator between elements
@omni_interpose = λ&sep. λ&list.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #NIL: #CON{h, #NIL}
        #CON: λ&h2. λ&t2.
          #CON{h, #CON{sep, @omni_interpose(sep)(t)}}
      }(t)
  }(list)

// Group elements by key function
// Returns a dict mapping keys to lists of elements with that key
@omni_group_by = λ&menv. λ&fn. λ&list.
  @omni_group_by_acc(menv)(fn)(list)(#NIL)

@omni_group_by_acc = λ&menv. λ&fn. λ&list. λ&acc.
  λ{
    #NIL: #Dict{acc}
    #CON: λ&h. λ&t.
      // Get key for this element - force evaluation
      !!&key = @omni_apply(menv)(fn)(h);
      // Add element to the group for this key
      !!&new_acc = @omni_add_to_group(key)(h)(acc);
      @omni_group_by_acc(menv)(fn)(t)(new_acc)
  }(list)

// Add element to a group in the accumulator
// Uses immediate lambda binding pattern like @omni_increment_count
@omni_add_to_group = λ&key. λ&elem. λ&groups.
  λ{
    #NIL: #CON{#CON{key, #CON{#CON{elem, #NIL}, #NIL}}, #NIL}
    #CON: λ&group. λ&rest.
      // Extract key from this group entry
      (λ&gkey.
        // Extract current elements list from this group
        (λ&cur_elems.
          // Check if this is our key
          (λ&eq.
            λ{
              #True:
                // Found it! Add element to front of list
                #CON{#CON{gkey, #CON{#CON{elem, cur_elems}, #NIL}}, rest}
              _: λ&u_.
                // Not this key, recurse
                !!&updated_rest = @omni_add_to_group(key)(elem)(rest);
                #CON{group, updated_rest}
            }(eq)
          )(@omni_eql(key)(gkey))
        )(@omni_get_group_elems(group))
      )(@omni_get_group_key(group))
  }(groups)

// Helper: get key from a group entry (key . (elems . nil))
@omni_get_group_key = λ&entry.
  λ{
    #CON: λ&k. λ&rest. k
    _: λ&u_. #Noth{}
  }(entry)

// Helper: get elements list from a group entry (key . (elems . nil))
@omni_get_group_elems = λ&entry.
  λ{
    #CON: λ&k. λ&rest.
      λ{
        #CON: λ&elems. λ&ign. elems
        _: λ&u_. #NIL
      }(rest)
    _: λ&u_. #NIL
  }(entry)

// Count occurrences of each element
// Returns a dict mapping elements to counts
@omni_frequencies = λ&list.
  #Dict{@omni_frequencies_acc(list)(#NIL)}

@omni_frequencies_acc = λ&list. λ&acc.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t.
      @omni_frequencies_acc(t)(@omni_increment_count(h)(acc))
  }(list)

// Increment count for an element in the accumulator
@omni_increment_count = λ&elem. λ&counts.
  λ{
    #NIL: #CON{#CON{elem, #CON{#Cst{1}, #NIL}}, #NIL}
    #CON: λ&pair. λ&rest.
      // Each pair is (elem . (count . nil))
      (λ&key. (λ&cur_count.
        (λ&eq.
          λ{
            #True:
              // Found it, increment count
              #CON{#CON{key, #CON{#Cst{(cur_count + 1)}, #NIL}}, rest}
            _: λ&u_.
              // Not this element, keep searching
              !!&updated_rest = @omni_increment_count(elem)(rest);
              #CON{pair, updated_rest}
          }(eq)
        )(@omni_eql(elem)(key))
      )(@omni_get_count(pair)))(@omni_get_key(pair))
  }(counts)

// Helper to get key from a pair
@omni_get_key = λ&pair.
  λ{
    #CON: λ&k. λ&rest. k
    _: λ&u_. #Noth{}
  }(pair)

// Helper to get count from a pair (extracts from (key . (count . nil)))
@omni_get_count = λ&pair.
  λ{
    #CON: λ&k. λ&rest.
      λ{
        #CON: λ&count. λ&ign.
          λ{
            #Cst: λ&n. n
            _: λ&u_. 1
          }(count)
        _: λ&u_. 1
      }(rest)
    _: λ&u_. 1
  }(pair)

// Sort list using comparator (merge sort)
@omni_sort = λ&menv. λ&list. λ&cmp.
  (λ&len.
    λ{
      0: #NIL
      1: list
      _: λ&u_.
        (λ&half.
          (λ&left. (λ&right.
            @omni_merge(menv)(@omni_sort(menv)(left)(cmp))(@omni_sort(menv)(right)(cmp))(cmp)
          )(@omni_drop(#Cst{half})(list)))(@omni_take(#Cst{half})(list))
        )((len / 2))
    }(len)
  )(@omni_list_length(list))

// Merge two sorted lists using comparator
@omni_merge = λ&menv. λ&left. λ&right. λ&cmp.
  λ{
    #NIL: right
    #CON: λ&lh. λ&lt.
      λ{
        #NIL: left
        #CON: λ&rh. λ&rt.
          // Compare lh and rh using cmp
          (λ&cmp_result.
            λ{
              #True: #CON{lh, @omni_merge(menv)(lt)(right)(cmp)}
              #Fals: #CON{rh, @omni_merge(menv)(left)(rt)(cmp)}
              // For numeric comparators, true if <= 0
              #Cst: λ&n.
                λ{
                  1: #CON{rh, @omni_merge(menv)(left)(rt)(cmp)}
                  _: λ&u_. #CON{lh, @omni_merge(menv)(lt)(right)(cmp)}
                }((n > 0))
              _: λ&u_. #CON{lh, @omni_merge(menv)(lt)(right)(cmp)}
            }(cmp_result)
          )(@omni_apply2(menv)(cmp)(lh)(rh))
      }(right)
  }(left)

// Apply function to two arguments (handles curried functions)
@omni_apply2 = λ&menv. λ&fn. λ&a. λ&b.
  // Apply curried function: ((fn a) b)
  @omni_apply(menv)(@omni_apply(menv)(fn)(a))(b)

// Get nested value by path
@omni_get_in = λ&coll. λ&path.
  λ{
    #NIL: coll
    #CON: λ&key. λ&rest.
      (λ&sub.
        λ{
          #Noth: #Noth{}
          _: λ&u_. @omni_get_in(sub)(rest)
        }(sub)
      )(@omni_get(coll)(key))
  }(path)

// Associate key with value in collection (functional update)
@omni_assoc = λ&coll. λ&key. λ&val.
  λ{
    // Dict: update or add entry
    #Dict: λ&entries.
      #Dict{@omni_dict_assoc(entries)(key)(val)}

    // List as alist
    #CON: λ&h. λ&t.
      λ{
        #Cst: λ&n. @omni_list_assoc(coll)(n)(val)
        _: λ&u_. @omni_alist_assoc(coll)(key)(val)
      }(key)

    #NIL:
      λ{
        #Cst: λ&n. #CON{val, #NIL}
        _: λ&u_. #CON{#CON{key, #CON{val, #NIL}}, #NIL}
      }(key)

    _: λ&u_. #Err{#sym_cannot_assoc}
  }(coll)

// Assoc in dict entries
@omni_dict_assoc = λ&entries. λ&key. λ&val.
  λ{
    #NIL: #CON{#CON{key, #CON{val, #NIL}}, #NIL}
    #CON: λ&pair. λ&rest.
      λ{
        #CON: λ&k. λ&ux.
          λ{
            1: #CON{#CON{key, #CON{val, #NIL}}, rest}
            _: λ&u_. #CON{pair, @omni_dict_assoc(rest)(key)(val)}
          }(@omni_values_equal(k)(key))
        _: λ&u_. #CON{pair, @omni_dict_assoc(rest)(key)(val)}
      }(pair)
  }(entries)

// Assoc in alist
@omni_alist_assoc = λ&alist. λ&key. λ&val.
  λ{
    #NIL: #CON{#CON{key, #CON{val, #NIL}}, #NIL}
    #CON: λ&pair. λ&rest.
      λ{
        #CON: λ&k. λ&ux.
          λ{
            1: #CON{#CON{key, #CON{val, #NIL}}, rest}
            _: λ&u_. #CON{pair, @omni_alist_assoc(rest)(key)(val)}
          }(@omni_values_equal(k)(key))
        _: λ&u_. #CON{pair, @omni_alist_assoc(rest)(key)(val)}
      }(pair)
  }(alist)

// Assoc at list index
@omni_list_assoc = λ&xs. λ&idx. λ&val.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        0: #CON{val, t}
        _: λ&u_. #CON{h, @omni_list_assoc(t)((idx - 1))(val)}
      }(idx)
  }(xs)

// Associate nested value by path
@omni_assoc_in = λ&coll. λ&path. λ&val.
  λ{
    #NIL: val  // Empty path - replace entire value
    #CON: λ&key. λ&rest.
      λ{
        #NIL: @omni_assoc(coll)(key)(val)
        _: λ&u_.
          (λ&sub.
            (λ&sub_or_empty.
              (λ&updated. @omni_assoc(coll)(key)(updated))(@omni_assoc_in(sub_or_empty)(rest)(val))
            )((λ{#Noth: #NIL; _: λ&u_. sub})(sub))
          )(@omni_get(coll)(key))
      }(rest)
  }(path)

// =============================================================================
// Quasiquote Evaluation
// =============================================================================

// Evaluate quasiquote at given nesting level
// level 0 = evaluate unquotes, level > 0 = inside nested quasiquote
@omni_eval_qq = λ&menv. λ&expr. λ&level.
  !!&lvl = (λ{#Cst: λ&n. n; _: λ&u_. 0})(level);
  λ{
    // Unquote - evaluate if level is 0
    #UQ: λ&inner.
      λ{
        0: @omni_eval(menv)(inner)
        _: λ&u_. #UQ{@omni_eval_qq(menv)(inner)(#Cst{(lvl - 1)})}
      }(lvl)

    // Unquote-splicing - mark for splicing if level is 0
    #UQS: λ&inner.
      λ{
        0: (λ&val. #UQS_Val{val})(@omni_eval(menv)(inner))  // Special marker for list splicing
        _: λ&u_. #UQS{@omni_eval_qq(menv)(inner)(#Cst{(lvl - 1)})}
      }(lvl)

    // Nested quasiquote - increase level
    #QQ: λ&inner.
      #QQ{@omni_eval_qq(menv)(inner)(#Cst{(lvl + 1)})}

    // List - recurse and handle splicing
    #CON: λ&h. λ&t.
      (λ&h_qq.
        (λ&t_qq. @omni_qq_cons(h_qq)(t_qq))(@omni_eval_qq(menv)(t)(level))
      )(@omni_eval_qq(menv)(h)(level))

    // Other structures - return as-is (quoted)
    _: λ&u_. expr
  }(expr)

// Cons in quasiquote, handling splice markers
@omni_qq_cons = λ&h. λ&t.
  λ{
    // Head is splice result - append to tail
    #UQS_Val: λ&list.
      @omni_append(list)(t)
    // Normal cons
    _: λ&u_. #CON{h, t}
  }(h)

// =============================================================================
// type? Predicate (user-facing)
// =============================================================================

// (type? value {Type}) - check if value has given type
// Works with both type descriptors and type symbols
@omni_type_check = λ&val. λ&type.
  !!&inferred = @omni_infer_type_runtime(val);
  @omni_subtype(inferred)(type)

// =============================================================================
// Boolean Operations
// =============================================================================

@omni_and = λ&a. λ&b.
  λ{
    #True: b
    _: λ&u_. #Fals{}
  }(a)

@omni_or = λ&a. λ&b.
  λ{
    #Fals: b
    _: λ&u_. #True{}
  }(a)

@omni_not = λ&a.
  λ{
    #True: #Fals{}
    _: λ&u_. #True{}
  }(a)

// =============================================================================
// Macro Expansion
// =============================================================================
//
// Macros are defined with (define [syntax name] [pattern template] ...)
// and stored as #MSyn{name, patterns} where patterns is a list of
// #MPat{pattern, template} entries.
//
// Expansion matches the input against patterns and substitutes into templates.

// Expand a macro call
// macro: #MSyn{name, patterns}
// args: list of argument expressions (unevaluated)
@omni_macro_expand = λ&menv. λ&macro. λ&args.
  λ{
    #MSyn: λ&name. λ&patterns.
      @omni_macro_try_patterns(menv)(args)(patterns)
    _: λ&u_. #Err{#sym_NotMacro, macro}
  }(macro)

// Try matching against each pattern in order
@omni_macro_try_patterns = λ&menv. λ&args. λ&patterns.
  λ{
    #NIL: #Err{#sym_NoMatchingPattern, args}
    #CON: λ&pat_entry. λ&rest.
      λ{
        #MPat: λ&pattern. λ&template.
          (λ&bindings.
            λ{
              #Noth: @omni_macro_try_patterns(menv)(args)(rest)
              _: λ&u_.
                // Successfully matched - substitute and evaluate
                (λ&expanded. @omni_eval(menv)(expanded))(@omni_macro_substitute(template)(bindings))
            }(bindings)
          )(@omni_macro_match(args)(pattern)(#NIL))
        _: λ&u_. @omni_macro_try_patterns(menv)(args)(rest)
      }(pat_entry)
  }(patterns)

// Match input against a pattern, returning bindings or #Noth on failure
// bindings is a list of #CON{var_nick, value} pairs
@omni_macro_match = λ&input. λ&pattern. λ&bindings.
  λ{
    // Pattern variable - binds the input
    #MVar: λ&var_nick.
      #CON{#CON{var_nick, input}, bindings}

    // Literal - must match exactly
    #MLit: λ&lit_val.
      λ{
        1: bindings
        _: λ&u_. #Noth{}
      }(@omni_macro_lit_equal(input)(lit_val))

    // Rest pattern - binds remaining list
    #MRst: λ&var_nick.
      #CON{#CON{var_nick, input}, bindings}

    // List pattern - match element by element
    #CON: λ&pat_head. λ&pat_tail.
      λ{
        #CON: λ&inp_head. λ&inp_tail.
          (λ&head_bindings.
            λ{
              #Noth: #Noth{}
              _: λ&u_. @omni_macro_match(inp_tail)(pat_tail)(head_bindings)
            }(head_bindings)
          )(@omni_macro_match(inp_head)(pat_head)(bindings))
        _: λ&u_. #Noth{}  // Input not a list
      }(input)

    #NIL:
      λ{
        #NIL: bindings
        _: λ&u_. #Noth{}
      }(input)

    // Array pattern
    #Arr: λ&elems.
      @omni_macro_match(input)(elems)(bindings)

    _: λ&u_. #Noth{}
  }(pattern)

// Check if input matches a literal
@omni_macro_lit_equal = λ&input. λ&lit.
  λ{
    #Lit: λ&iv.
      λ{
        #Lit: λ&lv. (iv == lv)
        _: λ&u_. 0
      }(lit)
    #Sym: λ&iv.
      λ{
        #Sym: λ&lv. (iv == lv)
        _: λ&u_. 0
      }(lit)
    #Cst: λ&iv.
      λ{
        #Cst: λ&lv. (iv == lv)
        #Lit: λ&lv. (iv == lv)
        _: λ&u_. 0
      }(lit)
    _: λ&u_. 0
  }(input)

// Substitute bindings into a template
@omni_macro_substitute = λ&template. λ&bindings.
  λ{
    // Variable reference - look up in bindings
    #MVar: λ&var_nick.
      @omni_macro_lookup(var_nick)(bindings)

    // Literal - return as-is
    #MLit: λ&lit_val. lit_val

    // Rest - look up the rest binding
    #MRst: λ&var_nick.
      @omni_macro_lookup(var_nick)(bindings)

    // List - substitute in each element
    #CON: λ&h. λ&t.
      #CON{@omni_macro_substitute(h)(bindings),
           @omni_macro_substitute(t)(bindings)}

    #NIL: #NIL

    // Array
    #Arr: λ&elems.
      #Arr{@omni_macro_substitute(elems)(bindings)}

    // Other nodes - recurse into children
    #App: λ&f. λ&a.
      #App{@omni_macro_substitute(f)(bindings),
           @omni_macro_substitute(a)(bindings)}

    #If: λ&c. λ&t. λ&e.
      #If{@omni_macro_substitute(c)(bindings),
          @omni_macro_substitute(t)(bindings),
          @omni_macro_substitute(e)(bindings)}

    #Let: λ&v. λ&b.
      #Let{@omni_macro_substitute(v)(bindings),
           @omni_macro_substitute(b)(bindings)}

    #LetS: λ&v. λ&b.
      #LetS{@omni_macro_substitute(v)(bindings),
            @omni_macro_substitute(b)(bindings)}

    #Lam: λ&b.
      #Lam{@omni_macro_substitute(b)(bindings)}

    #Do: λ&a. λ&b.
      #Do{@omni_macro_substitute(a)(bindings),
          @omni_macro_substitute(b)(bindings)}

    // Anything else - return as-is
    _: λ&u_. template
  }(template)

// Look up a variable in bindings
@omni_macro_lookup = λ&var_nick. λ&bindings.
  λ{
    #NIL: #Err{#sym_UnboundMacroVar, var_nick}
    #CON: λ&binding. λ&rest.
      λ{
        #CON: λ&nick. λ&rest2.
          λ{
            #CON: λ&value. λ&ux.
              λ{
                1: value
                _: λ&u_. @omni_macro_lookup(var_nick)(rest)
              }((nick == var_nick))
          }(rest2)
      }(binding)
  }(bindings)

// Gensym for hygiene - generate unique symbol
// counter is stored in menv or as a global ref
@omni_gensym_counter = 0

@omni_gensym = λ&prefix.
  !!&count = @omni_gensym_counter;
  !!&uu = (count + 1);
  // Create unique nick by combining prefix with counter
  // In practice, this would use string concatenation
  (prefix + (count * 1000000))

// =============================================================================
// Module System
// =============================================================================
//
// Modules are defined with (module Name (export ...) body...)
// and stored as #Modl{name, exports, body}.
//
// Import brings module exports into current environment.

// Global module registry - maps module names to evaluated modules
// In practice, this would be a ref cell or hash table
@omni_module_registry = #NIL

// Evaluate a module definition
// Returns #Mod{name, env} where env contains the exported bindings
@omni_eval_module = λ&menv. λ&module.
  λ{
    #Modl: λ&name. λ&exports. λ&body.
      // Evaluate body expressions in fresh environment
      (λ&mod_env.
        // Filter to exports only
        (λ&export_list.
          (λ&exported_env.
            // Create module value
            (λ&mod_val.
              // Register in global registry
              (λ&uu. mod_val)(@omni_register_module(name)(mod_val))
            )(#Mod{name, exported_env})
          )(@omni_filter_exports(mod_env)(export_list))
        )((λ{#Expt: λ&names. names; _: λ&u_. #NIL})(exports))
      )(@omni_eval_module_body(menv)(body)(#NIL))
    _: λ&u_. #Err{#sym_NotModule, module}
  }(module)

// Evaluate module body, collecting bindings
@omni_eval_module_body = λ&menv. λ&body. λ&env.
  λ{
    #NIL: env
    #CON: λ&expr. λ&rest.
      (λ&result. @omni_eval_module_body(menv)(rest)(result))(@omni_eval_module_expr(menv)(expr)(env))
  }(body)

// Evaluate a single expression in module context
// Definitions add to env, other expressions are just evaluated
@omni_eval_module_expr = λ&menv. λ&expr. λ&env.
  λ{
    // Definition - add to module env
    #Def: λ&name. λ&value.
      (λ&v. #CON{#CON{name, v}, env})(@omni_eval(menv)(value))

    // Lambda wrapped in book entry
    #Lam: λ&body.
      // Standalone lambda - just evaluate it
      (λ&v. env)(@omni_eval(menv)(expr))

    // Syntax macro definition
    #MSyn: λ&name. λ&patterns.
      #CON{#CON{name, expr}, env}

    // Generic function
    #GFun: λ&name. λ&methods.
      #CON{#CON{name, expr}, env}

    // Other expression - evaluate for side effects
    _: λ&u_.
      (λ&uu. env)(@omni_eval(menv)(expr))
  }(expr)

// Filter module env to exports only
@omni_filter_exports = λ&env. λ&exports.
  λ{
    #NIL: env  // Empty export list = export all
    _: λ&u_. @omni_filter_exports_list(env)(exports)
  }(exports)

@omni_filter_exports_list = λ&env. λ&exports.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #Cst: λ&nick.
          (λ&binding.
            λ{
              #Noth: @omni_filter_exports_list(env)(t)
              _: λ&u_. #CON{binding, @omni_filter_exports_list(env)(t)}
            }(binding)
          )(@omni_module_lookup_nick(nick)(env))
        _: λ&u_. @omni_filter_exports_list(env)(t)
      }(h)
  }(exports)

// Lookup by nick in module env
@omni_module_lookup_nick = λ&nick. λ&env.
  λ{
    #NIL: #Noth{}
    #CON: λ&binding. λ&rest.
      λ{
        #CON: λ&bname. λ&rest2.
          λ{
            #CON: λ&bvalue. λ&ux.
              λ{
                1: binding
                _: λ&u_. @omni_module_lookup_nick(nick)(rest)
              }((bname == nick))
          }(rest2)
      }(binding)
  }(env)

// Register module in global registry
@omni_register_module = λ&name. λ&mod.
  !!&old = @omni_module_registry;
  !!&uu = #CON{#CON{name, mod}, old};
  #NIL

// Lookup module in registry
@omni_lookup_module = λ&name.
  @omni_lookup_module_in(name)(@omni_module_registry)

@omni_lookup_module_in = λ&name. λ&registry.
  λ{
    #NIL: #Noth{}
    #CON: λ&entry. λ&rest.
      λ{
        #CON: λ&mod_name. λ&rest2.
          λ{
            #CON: λ&mod_val. λ&ux.
              λ{
                1: mod_val
                _: λ&u_. @omni_lookup_module_in(name)(rest)
              }((mod_name == name))
          }(rest2)
      }(entry)
  }(registry)

// Process import statement
// Returns new environment with imported bindings
// bindings can be:
//   #NIL - import all exports
//   #CON{...} - list of names to import selectively
//   #Sym{alias_nick, ...} - import all with prefix (from :as alias)
@omni_process_import = λ&menv. λ&import.
  λ{
    #Impt: λ&mod_name. λ&bindings.
      (λ&mod.
        λ{
          #Noth: #Err{#sym_ModuleNotFound, mod_name}
          #Mod: λ&name. λ&mod_env.
            // Dispatch on bindings type
            λ{
              #NIL: mod_env  // Import all exports directly
              #Sym: λ&alias_nick. λ&ux.
                // Aliased import: prefix all exports with alias
                @omni_alias_imports(mod_env)(alias_nick)
              #CON: λ&h. λ&t.
                // Selective import: only specified names
                @omni_select_imports(mod_env)(bindings)
              _: λ&u_. mod_env  // Fallback: import all
            }(bindings)
          _: λ&u_. #Err{#sym_InvalidModule, mod}
        }(mod)
      )(@omni_lookup_module(mod_name))
    _: λ&u_. #Err{#sym_NotImport, import}
  }(import)

// Select specific imports from module env
@omni_select_imports = λ&mod_env. λ&names.
  λ{
    #NIL: #NIL
    #CON: λ&name. λ&rest.
      (λ&binding.
        λ{
          #Noth: @omni_select_imports(mod_env)(rest)
          _: λ&u_. #CON{binding, @omni_select_imports(mod_env)(rest)}
        }(binding)
      )(@omni_module_lookup_nick(name)(mod_env))
  }(names)

// Alias imports: prefix all bindings with alias nick
// (import Math :as M) makes Math.sin available as M.sin
// We create a single binding: alias_nick -> #Mod{name, mod_env}
// so M.sin resolves to looking up sin in the aliased module
@omni_alias_imports = λ&mod_env. λ&alias_nick.
  // Return a single binding that maps the alias to the module's env
  // The path resolution (M.sin) will look up the alias, get the env,
  // then look up the symbol in that env
  #CON{#CON{alias_nick, #ModAlias{mod_env}}, #NIL}

// =============================================================================
// Stage-Polymorphic Evaluation (Collapsing Towers)
// =============================================================================
//
// Stage-polymorphic evaluation is the key to collapsing towers of interpreters.
// The same evaluator code behaves differently at different meta-levels:
//
// - At level 0 (base): Evaluate directly, produce values
// - At level > 0 (meta): Generate code, produce staged expressions
//
// This enables the Amin & Rompf "Collapsing Towers" optimization where
// nested interpreters collapse into single-pass compilation.
//
// Example:
//   (run (lift (+ 1 2)))  ; At level 1, generates #Add{#Lit{1}, #Lit{2}}
//                         ; Then run executes it: 3
//
// The stage-polymorphic primitives:
// - @sp_lit: literal (value at level 0, #Lit at level > 0)
// - @sp_add: addition (compute at level 0, generate #Add at level > 0)
// - @sp_if: conditional (branch at level 0, generate #If at level > 0)
// - etc.

// Stage-polymorphic literal
// At level 0: return the value
// At level > 0: return code that produces the value
@sp_lit = λ&menv. λ&n.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: #Cst{n}           // Level 0: actual value
    _: λ&u_. #Lit{n}           // Level > 0: code for literal
  }(lv)

// Stage-polymorphic variable
// At level 0: lookup and return value
// At level > 0: return code for variable access
@sp_var = λ&menv. λ&idx.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  !!&env = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. e})(menv);
  λ{
    0: @omni_env_get(env)(idx)  // Level 0: actual lookup
    _: λ&u_. #Var{idx}                 // Level > 0: code for var
  }(lv)

// Stage-polymorphic lambda
// At level 0: create closure
// At level > 0: return code for lambda
@sp_lam = λ&menv. λ&body.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  !!&env = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. e})(menv);
  λ{
    0: #Clo{env, body}  // Level 0: actual closure
    _: λ&u_. #Lam{body}       // Level > 0: code for lambda
  }(lv)

// Stage-polymorphic application
// At level 0: apply the function
// At level > 0: return code for application
@sp_app = λ&menv. λ&fn. λ&arg.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: @omni_apply(menv)(fn)(arg)  // Level 0: actual application
    _: λ&u_. #App{fn, arg}               // Level > 0: code for app
  }(lv)

// Stage-polymorphic addition
// At level 0: compute the sum
// At level > 0: return code for addition
@sp_add = λ&menv. λ&a. λ&b.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: @omni_add(a)(b)  // Level 0: compute
    _: λ&u_. #Add{a, b}       // Level > 0: code for add
  }(lv)

// Stage-polymorphic subtraction
@sp_sub = λ&menv. λ&a. λ&b.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: @omni_sub(a)(b)
    _: λ&u_. #Sub{a, b}
  }(lv)

// Stage-polymorphic multiplication
@sp_mul = λ&menv. λ&a. λ&b.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: @omni_mul(a)(b)
    _: λ&u_. #Mul{a, b}
  }(lv)

// Stage-polymorphic division
@sp_div = λ&menv. λ&a. λ&b.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: @omni_div(a)(b)
    _: λ&u_. #Div{a, b}
  }(lv)

// Stage-polymorphic conditional
// At level 0: branch based on condition
// At level > 0: return code for if (may partially evaluate if condition is known)
@sp_if = λ&menv. λ&cond. λ&then_br. λ&else_br.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0:  // Level 0: branch
      λ{
        #Cst: λ&n.
          λ{
            0: else_br
            _: λ&u_. then_br
          }(n)
        _: λ&u_. else_br
      }(cond)
    _: λ&u_.  // Level > 0: generate code or partially evaluate
      // Try to partially evaluate if condition is known
      λ{
        #Cst: λ&n.
          λ{
            0: else_br
            _: λ&u_. then_br
          }(n)
        #Lit: λ&n.  // Condition is staged literal
          λ{
            0: else_br
            _: λ&u_. then_br
          }(n)
        _: λ&u_. #If{cond, then_br, else_br}  // Unknown: generate code
      }(cond)
  }(lv)

// Stage-polymorphic equality
@sp_eql = λ&menv. λ&a. λ&b.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: @omni_eql(a)(b)
    _: λ&u_. #Eql{a, b}
  }(lv)

// Stage-polymorphic less-than
@sp_lt = λ&menv. λ&a. λ&b.
  !!&level = @omni_menv_level(menv);
  !!&lv = (λ{#Cst: λ&v. v; _: λ&u_. 0})(level);
  λ{
    0: @omni_lt(a)(b)
    _: λ&u_. #Lt{a, b}
  }(lv)

// =============================================================================
// Stage-Polymorphic Evaluator
// =============================================================================
//
// This evaluator uses stage-polymorphic primitives so it can:
// 1. Execute code directly when at level 0
// 2. Generate code when at level > 0
//
// This is the foundation for collapsing towers of interpreters.

@omni_eval_sp = λ&menv. λ&exp.
  !!&env = (λ{#MEnv: λ&e. λ&h. λ&p. λ&l. e})(menv);
  λ{
    #Lit: λ&n. @sp_lit(menv)(n)

    #Var: λ&i. @sp_var(menv)(i)

    #Lam: λ&body. @sp_lam(menv)(body)

    #App: λ&fn. λ&arg.
      (λ&fn_v.
        (λ&arg_v. @sp_app(menv)(fn_v)(arg_v))(@omni_eval_sp(menv)(arg))
      )(@omni_eval_sp(menv)(fn))

    #Add: λ&a. λ&b.
      (λ&av.
        (λ&bv. @sp_add(menv)(av)(bv))(@omni_eval_sp(menv)(b))
      )(@omni_eval_sp(menv)(a))

    #Sub: λ&a. λ&b.
      (λ&av.
        (λ&bv. @sp_sub(menv)(av)(bv))(@omni_eval_sp(menv)(b))
      )(@omni_eval_sp(menv)(a))

    #Mul: λ&a. λ&b.
      (λ&av.
        (λ&bv. @sp_mul(menv)(av)(bv))(@omni_eval_sp(menv)(b))
      )(@omni_eval_sp(menv)(a))

    #Div: λ&a. λ&b.
      (λ&av.
        (λ&bv. @sp_div(menv)(av)(bv))(@omni_eval_sp(menv)(b))
      )(@omni_eval_sp(menv)(a))

    #If: λ&cond. λ&then_. λ&else_.
      (λ&cv.
        (λ&tv.
          (λ&ev. @sp_if(menv)(cv)(tv)(ev))(@omni_eval_sp(menv)(else_))
        )(@omni_eval_sp(menv)(then_))
      )(@omni_eval_sp(menv)(cond))

    #Eql: λ&a. λ&b.
      (λ&av.
        (λ&bv. @sp_eql(menv)(av)(bv))(@omni_eval_sp(menv)(b))
      )(@omni_eval_sp(menv)(a))

    #Lt: λ&a. λ&b.
      (λ&av.
        (λ&bv. @sp_lt(menv)(av)(bv))(@omni_eval_sp(menv)(b))
      )(@omni_eval_sp(menv)(a))

    // Let (lazy - allows parallel evaluation)
    #Let: λ&val. λ&body.
      (λ&v. (λ&new_env. (λ&new_menv.
        @omni_eval_sp(new_menv)(body)
      )(@omni_menv_extend(menv)(new_env)))(@omni_env_extend(env)(v)))(@omni_eval_sp(menv)(val))

    // LetS (strict - forces eager evaluation with ^:strict)
    #LetS: λ&val. λ&body.
      (λ&v.
        (λ&new_env.
          (λ&new_menv. @omni_eval_sp(new_menv)(body))(@omni_menv_extend(menv)(new_env))
        )(@omni_env_extend(env)(v))
      )(@omni_eval_sp(menv)(val))

    // Tower operations in stage-polymorphic eval
    #Lift: λ&expr.
      // Create child menv at next level
      (λ&child_menv. @omni_eval_sp(child_menv)(expr))(@omni_menv_child(menv))

    #Run: λ&expr.
      (λ&code.
        // Force parent and evaluate there
        (λ&parent_ref.
          (λ&parent.
            λ{
              #Noth: @omni_reify(menv)(code)
              _: λ&u_. @omni_eval_sp(parent)(code)
            }(parent)
          )(@omni_menv_force_parent(parent_ref))
        )((λ{#MEnv: λ&e. λ&h. λ&p. λ&l. p})(menv))
      )(@omni_eval_sp(menv)(expr))

    #EM: λ&expr.
      (λ&parent_ref.
        (λ&parent.
          λ{
            #Noth: @omni_eval_sp(menv)(expr)
            _: λ&u_. @omni_eval_sp(parent)(expr)
          }(parent)
        )(@omni_menv_force_parent(parent_ref))
      )((λ{#MEnv: λ&e. λ&h. λ&p. λ&l. p})(menv))

    // Fall through to regular eval for other forms
    _: λ&u_. @omni_eval(menv)(exp)
  }(exp)

// =============================================================================
// Entry Point
// =============================================================================

@omni_run = λ&expr.
  @omni_eval(@omni_menv_empty)(expr)

// Run with stage-polymorphic evaluation
@omni_run_sp = λ&expr.
  @omni_eval_sp(@omni_menv_empty)(expr)

// Run at specific meta-level
@omni_run_at_level = λ&level. λ&expr.
  !!&menv = #MEnv{#NIL, #NIL, #Noth, #Cst{level}};
  @omni_eval_sp(menv)(expr)

// Unwrap result values for cleaner output
// - #Cst{n} -> n (raw number)
// - #True -> 1, #Fals -> 0
// - Lists and arrays pass through (HVM4 will format them)
// - Other values pass through
@omni_unwrap = λ&v.
  λ{
    #Cst: λ&n. n
    #Fix: λ&hi. λ&lo. λ&scale.
      // Fixed-point number - convert to printable
      λ{
        1: (0 - lo)  // Negative: negate lo
        0: v         // Positive: return as-is (HVM4 will format)
      }((hi >= 2147483648))
    #True: 1
    #Fals: 0
    #Noth: v  // Keep as #Noth for display
    #NIL: v   // Keep as #NIL (shows as ())
    #CON: λ&h. λ&t. v  // Keep list as-is
    #Arr: λ&len. λ&data. v  // Keep array as-is
    #Dict: λ&entries. v  // Keep dict as-is
    #Err: λ&e. v  // Keep error for debugging
    _: λ&u_. v  // Everything else passes through
  }(v)

// DEBUG TEST - simple FFI node creation
@test_ffi_node = #FFI{4281603, #NIL}

