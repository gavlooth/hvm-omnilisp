// OmniLisp Collections Runtime
// Operations on lists, arrays, dicts, and sets

// =============================================================================
// PARALLEL-FIRST PHILOSOPHY
// =============================================================================
//
// OmniLisp functions are PARALLEL BY DEFAULT using HVM4 superpositions.
// Sequential versions are available with _seq suffix for when ordering matters.
//
// Parallel execution: Independent computations run simultaneously via HVM4's
// strict binding mechanism (!!&). When two strict bindings are independent,
// HVM4 evaluates them in parallel.
//
// Use sequential (_seq) when:
//   - Side effects require ordering
//   - You need deterministic evaluation order
//   - Accumulator threading (foldl is inherently sequential)
//
// =============================================================================

// =============================================================================
// List Operations - PARALLEL BY DEFAULT
// =============================================================================

// Map a function over a list (PARALLEL)
// Each f(element) is evaluated in parallel with recursive map
@omni_map = λ&f. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      !!&head_result = f(h);
      !!&tail_result = @omni_map(f)(t);
      #CON{head_result, tail_result}
  }(xs)

// Map - SEQUENTIAL version (use when side effects need ordering)
@omni_map_seq = λf. λxs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. #CON{f(h), @omni_map_seq(f)(t)}
  }(xs)

// Filter elements satisfying predicate (PARALLEL)
// Predicate evaluation parallelized with recursive filter
@omni_filter = λ&p. λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      !!&pred_result = p(h);
      !!&tail_result = @omni_filter(p)(t);
      λ{
        1: #CON{h, tail_result}
        _: tail_result
      }(pred_result)
  }(xs)

// Filter - SEQUENTIAL version
@omni_filter_seq = λp. λxs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        1: #CON{h, @omni_filter_seq(p)(t)}
        _: @omni_filter_seq(p)(t)
      }(p(h))
  }(xs)

// Left fold - INHERENTLY SEQUENTIAL (accumulator threading)
// No parallel version exists - use reduce_tree for parallel reduction
@omni_foldl = λf. λacc. λxs.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t. @omni_foldl(f)(f(acc)(h))(t)
  }(xs)

// Right fold (PARALLEL for the recursive call)
@omni_foldr = λ&f. λ&acc. λ&xs.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t.
      !!&tail_result = @omni_foldr(f)(acc)(t);
      f(h)(tail_result)
  }(xs)

// Right fold - SEQUENTIAL version
@omni_foldr_seq = λf. λacc. λxs.
  λ{
    #NIL: acc
    #CON: λ&h. λ&t. f(h)(@omni_foldr_seq(f)(acc)(t))
  }(xs)

// Tree reduction for associative operations (TRULY PARALLEL)
// Splits list in half, reduces each half in parallel, combines
@omni_reduce_tree = λ&f. λ&xs.
  λ{
    #NIL: #Err{#sym_EmptyList, #sym_reduce}
    #CON: λ&h. λ&t.
      λ{
        #NIL: h  // Single element
        _:
          !!&len = @omni_length_fast(xs);
          !!&mid = (len / 2);
          !!&left = @omni_take(mid)(xs);
          !!&right = @omni_drop(mid)(xs);
          !!&left_result = @omni_reduce_tree(f)(left);
          !!&right_result = @omni_reduce_tree(f)(right);
          f(left_result)(right_result)
      }(t)
  }(xs)

// Fast length (direct recursion, no foldl overhead)
@omni_length_fast = λxs.
  λ{
    #NIL: 0
    #CON: λ&_. λ&t. (1 + @omni_length_fast(t))
  }(xs)

// Reduce (fold with first element as accumulator)
@omni_reduce = λf. λxs.
  λ{
    #NIL: #Err{#sym_EmptyList, #sym_reduce}
    #CON: λ&h. λ&t. @omni_foldl(f)(h)(t)
  }(xs)

// Take first n elements
@omni_take = λn. λxs.
  λ{
    0: #NIL
    _:
      λ{
        #NIL: #NIL
        #CON: λ&h. λ&t. #CON{h, @omni_take((n - 1))(t)}
      }(xs)
  }(n)

// Drop first n elements
@omni_drop = λn. λxs.
  λ{
    0: xs
    _:
      λ{
        #NIL: #NIL
        #CON: λ&_. λ&t. @omni_drop((n - 1))(t)
      }(xs)
  }(n)

// Reverse a list
@omni_reverse = λxs.
  @omni_foldl(λacc. λx. #CON{x, acc})(#NIL)(xs)

// List length
@omni_length = λxs.
  @omni_foldl(λacc. λ_. (acc + 1))(0)(xs)

// Check if list is empty
@omni_empty? = λxs.
  λ{
    #NIL: 1
    _: 0
  }(xs)

// Find first element satisfying predicate
// Find first element satisfying predicate
// Polymorphic: List, Array, Iterator, Range
@omni_find = λp. λxs.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t. λ{1: h; _: @omni_find(p)(t)}(p(h))
    #Arr: λ&len. λ&data. @omni_find(p)(data)
    #Iter: λ&state. λ&next_fn. @omni_find_iter(p)(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_find_iter(p)(xs)
  }(xs)

// Helper: find over iterator
@omni_find_iter = λ&p. λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{1: v; _: @omni_find_iter(p)(rest)}(p(v))
    #None: #Noth{}
  }(stepped))(@omni_iter_step(iter))

// Find index of first match
// Polymorphic: List, Array, Iterator, Range
@omni_index_of = λval. λxs.
  λ{
    #Arr: λ&len. λ&data. @omni_index_of_helper(val)(data)(0)
    #Iter: λ&state. λ&next_fn. @omni_index_of_iter(val)(xs)(0)
    #Rang: λ&s. λ&e. λ&st. @omni_index_of_iter(val)(xs)(0)
    _: λ&u_. @omni_index_of_helper(val)(xs)(0)
  }(xs)

@omni_index_of_helper = λval. λxs. λidx.
  λ{
    #NIL: #Noth{}
    #CON: λ&h. λ&t. λ{1: idx; _: @omni_index_of_helper(val)(t)((idx + 1))}((h == val))
  }(xs)

// Helper: index_of over iterator
@omni_index_of_iter = λ&val. λ&iter. λ&idx.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{1: idx; _: @omni_index_of_iter(val)(rest)((idx + 1))}((v == val))
    #None: #Noth{}
  }(stepped))(@omni_iter_step(iter))

// Check if any element satisfies predicate (PARALLEL)
// Polymorphic: List, Array, Iterator, Range
@omni_any = λ&p. λ&xs.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t.
      !!&head_result = p(h);
      !!&tail_result = @omni_any(p)(t);
      λ{1: 1; _: tail_result}(head_result)
    #Arr: λ&len. λ&data. @omni_any(p)(data)
    #Iter: λ&state. λ&next_fn. @omni_any_iter(p)(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_any_iter(p)(xs)
  }(xs)

// Helper: any over iterator
@omni_any_iter = λ&p. λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{1: 1; _: @omni_any_iter(p)(rest)}(p(v))
    #None: 0
  }(stepped))(@omni_iter_step(iter))

// Generic iterator step
@omni_iter_step = λ&iter.
  λ{
    #Iter: λ&state. λ&next_fn. next_fn(state)
    #Rang: λ&cur. λ&end. λ&step.
      λ{1: #None{}; _: #Some{cur, #Rang{(cur + step), end, step}}}((cur >= end))
    _: λ&u_. #None{}
  }(iter)

// Any - SEQUENTIAL version (short-circuits)
// Polymorphic: List, Array, Iterator, Range
@omni_any_seq = λp. λxs.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t. λ{1: 1; _: @omni_any_seq(p)(t)}(p(h))
    #Arr: λ&len. λ&data. @omni_any_seq(p)(data)
    #Iter: λ&state. λ&next_fn. @omni_any_iter(p)(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_any_iter(p)(xs)
  }(xs)

// Check if all elements satisfy predicate (PARALLEL)
// Polymorphic: List, Array, Iterator, Range
@omni_all = λ&p. λ&xs.
  λ{
    #NIL: 1
    #CON: λ&h. λ&t.
      !!&head_result = p(h);
      !!&tail_result = @omni_all(p)(t);
      λ{0: 0; _: tail_result}(head_result)
    #Arr: λ&len. λ&data. @omni_all(p)(data)
    #Iter: λ&state. λ&next_fn. @omni_all_iter(p)(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_all_iter(p)(xs)
  }(xs)

// Helper: all over iterator
@omni_all_iter = λ&p. λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{0: 0; _: @omni_all_iter(p)(rest)}(p(v))
    #None: 1
  }(stepped))(@omni_iter_step(iter))

// All - SEQUENTIAL version (short-circuits)
// Polymorphic: List, Array, Iterator, Range
@omni_all_seq = λp. λxs.
  λ{
    #NIL: 1
    #CON: λ&h. λ&t. λ{0: 0; _: @omni_all_seq(p)(t)}(p(h))
    #Arr: λ&len. λ&data. @omni_all_seq(p)(data)
    #Iter: λ&state. λ&next_fn. @omni_all_iter(p)(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_all_iter(p)(xs)
  }(xs)

// Check if sequence contains value
// Polymorphic: delegates to @omni_any which handles all types
@omni_contains = λval. λxs.
  @omni_any(λx. (x == val))(xs)

// Get nth element (0-indexed)
// Polymorphic: List (O(n)), Array (O(1)), Iterator (O(n))
@omni_nth = λn. λxs.
  λ{
    #NIL: #Err{#sym_IndexOutOfBounds, n}
    #CON: λ&h. λ&t. λ{0: h; _: @omni_nth((n - 1))(t)}(n)
    #Arr: λ&len. λ&data.
      λ{1: #Err{#sym_IndexOutOfBounds, n}; _: @omni_nth(n)(data)}((n >= len))
    #Iter: λ&state. λ&next_fn. @omni_nth_iter(n)(xs)
    #Rang: λ&s. λ&e. λ&st.
      (λ&idx. λ{1: #Err{#sym_IndexOutOfBounds, n}; _: (s + (n * st))}((idx >= e)))((s + (n * st)))
  }(xs)

// Helper: nth over iterator
@omni_nth_iter = λ&n. λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. λ{0: v; _: @omni_nth_iter((n - 1))(rest)}(n)
    #None: #Err{#sym_IndexOutOfBounds, n}
  }(stepped))(@omni_iter_step(iter))

// Concatenate two sequences (PARALLEL recursive concat)
// Polymorphic: List++List→List, Array++Array→Array, etc.
// Result type follows first argument
@omni_concat = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t.
      !!&tail_result = @omni_concat(t)(ys);
      #CON{h, tail_result}
    #Arr: λ&len1. λ&data1.
      (λ&ys_data. λ&ys_len.
        #Arr{(len1 + ys_len), @omni_concat(data1)(ys_data)}
      )(@omni_to_list(ys))(@omni_seq_length(ys))
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{xs, ys}, @omni_concat_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{xs, ys}, @omni_concat_iter_next}
  }(xs)

// Helper: concat iterator next
@omni_concat_iter_next = λ&pair.
  λ{#CON: λ&first. λ&rest.
    λ{#CON: λ&second. λ&_.
      (λ&stepped. λ{
        #Some: λ&v. λ&r. #Some{v, #CON{r, #CON{second, #NIL}}}
        #None: @omni_iter_step(second)
      }(stepped))(@omni_iter_step(first))
    }(rest)
  }(pair)

// Helper: convert any sequence to list
@omni_to_list = λ&xs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. xs
    #Arr: λ&len. λ&data. data
    #Iter: λ&state. λ&next_fn. @omni_iter_to_list(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_iter_to_list(xs)
  }(xs)

// Helper: materialize iterator to list
@omni_iter_to_list = λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. #CON{v, @omni_iter_to_list(rest)}
    #None: #NIL
  }(stepped))(@omni_iter_step(iter))

// Helper: get sequence length
@omni_seq_length = λ&xs.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t. (1 + @omni_seq_length(t))
    #Arr: λ&len. λ&data. len
    #Iter: λ&state. λ&next_fn. @omni_iter_length(xs)
    #Rang: λ&s. λ&e. λ&st. ((e - s) / st)
  }(xs)

// Helper: iterator length (materializes)
@omni_iter_length = λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest. (1 + @omni_iter_length(rest))
    #None: 0
  }(stepped))(@omni_iter_step(iter))

// Concatenate - SEQUENTIAL version
@omni_concat_seq = λxs. λys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @omni_concat_seq(t)(ys)}
    #Arr: λ&len1. λ&data1.
      (λ&ys_data. #Arr{(len1 + @omni_seq_length(ys)), @omni_concat_seq(data1)(ys_data)})(@omni_to_list(ys))
  }(xs)

// Flatten nested sequence (one level) - uses parallel foldr
// Polymorphic: flattens any sequence of sequences
@omni_flatten = λ&xss.
  λ{
    #Arr: λ&len. λ&data.
      (λ&flattened. #Arr{@omni_seq_length(flattened), flattened})(@omni_foldr(@omni_concat)(#NIL)(data))
    _: λ&u_. @omni_foldr(@omni_concat)(#NIL)(xss)
  }(xss)

// Flatten - SEQUENTIAL version
@omni_flatten_seq = λxss.
  @omni_foldr_seq(@omni_concat_seq)(#NIL)(@omni_to_list(xss))

// Deep flatten
@omni_flatten_deep = λxs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&_. λ&_. @omni_concat(@omni_flatten_deep(h))(@omni_flatten_deep(t))
        #NIL: @omni_flatten_deep(t)
        _: #CON{h, @omni_flatten_deep(t)}
      }(h)
  }(xs)

// Zip two lists together
// Zip two sequences together
// Polymorphic: List, Array, Iterator, Range
// Result type follows first argument
@omni_zip = λxs. λys.
  λ{
    #NIL: #NIL
    #CON: λ&xh. λ&xt.
      (λ&ys_step. λ{
        #Some: λ&yh. λ&yt. #CON{#CON{xh, #CON{yh, #NIL}}, @omni_zip(xt)(yt)}
        #None: #NIL
      }(ys_step))(@omni_seq_first(ys))
    #Arr: λ&len. λ&data.
      (λ&zipped. #Arr{@omni_seq_length(zipped), zipped})(@omni_zip(data)(@omni_to_list(ys)))
    #Iter: λ&state. λ&next_fn. @omni_zip_iter(xs)(ys)
    #Rang: λ&s. λ&e. λ&st. @omni_zip_iter(xs)(ys)
  }(xs)

// Helper: get first element and rest as #Some{head, tail} or #None
@omni_seq_first = λ&xs.
  λ{
    #NIL: #None{}
    #CON: λ&h. λ&t. #Some{h, t}
    #Arr: λ&len. λ&data. @omni_seq_first(data)
    #Iter: λ&state. λ&next_fn. @omni_iter_step(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_iter_step(xs)
  }(xs)

// Helper: zip iterator
@omni_zip_iter = λ&xs. λ&ys.
  #Iter{#CON{xs, #CON{ys, #NIL}}, λ&pair.
    λ{#CON: λ&x_iter. λ&rest.
      λ{#CON: λ&y_iter. λ&_.
        (λ&xs_step. λ{
          #Some: λ&xh. λ&xt.
            (λ&ys_step. λ{
              #Some: λ&yh. λ&yt. #Some{#CON{xh, #CON{yh, #NIL}}, #CON{xt, #CON{yt, #NIL}}}
              #None: #None{}
            }(ys_step))(@omni_iter_step(y_iter))
          #None: #None{}
        }(xs_step))(@omni_iter_step(x_iter))
      }(rest)
    }(pair)
  }

// Zip with function (PARALLEL)
// Polymorphic: List, Array, Iterator, Range
@omni_zip_with = λ&f. λ&xs. λ&ys.
  λ{
    #NIL: #NIL
    #CON: λ&xh. λ&xt.
      (λ&ys_step. λ{
        #Some: λ&yh. λ&yt.
          !!&head_result = f(xh)(yh);
          !!&tail_result = @omni_zip_with(f)(xt)(yt);
          #CON{head_result, tail_result}
        #None: #NIL
      }(ys_step))(@omni_seq_first(ys))
    #Arr: λ&len. λ&data.
      (λ&zipped. #Arr{@omni_seq_length(zipped), zipped})(@omni_zip_with(f)(data)(@omni_to_list(ys)))
    #Iter: λ&state. λ&next_fn. @omni_zip_with_iter(f)(xs)(ys)
    #Rang: λ&s. λ&e. λ&st. @omni_zip_with_iter(f)(xs)(ys)
  }(xs)

// Helper: zip_with iterator
@omni_zip_with_iter = λ&f. λ&xs. λ&ys.
  #Iter{#CON{xs, #CON{ys, #NIL}}, λ&pair.
    λ{#CON: λ&x_iter. λ&rest.
      λ{#CON: λ&y_iter. λ&_.
        (λ&xs_step. λ{
          #Some: λ&xh. λ&xt.
            (λ&ys_step. λ{
              #Some: λ&yh. λ&yt. #Some{f(xh)(yh), #CON{xt, #CON{yt, #NIL}}}
              #None: #None{}
            }(ys_step))(@omni_iter_step(y_iter))
          #None: #None{}
        }(xs_step))(@omni_iter_step(x_iter))
      }(rest)
    }(pair)
  }

// Zip with function - SEQUENTIAL version
@omni_zip_with_seq = λf. λxs. λys.
  λ{
    #NIL: #NIL
    #CON: λ&xh. λ&xt.
      (λ&ys_step. λ{
        #Some: λ&yh. λ&yt. #CON{f(xh)(yh), @omni_zip_with_seq(f)(xt)(yt)}
        #None: #NIL
      }(ys_step))(@omni_seq_first(ys))
    #Arr: λ&len. λ&data.
      (λ&zipped. #Arr{@omni_seq_length(zipped), zipped})(@omni_zip_with_seq(f)(data)(@omni_to_list(ys)))
  }(xs)

// Unzip list of pairs
// Polymorphic: List, Array
@omni_unzip = λxs.
  λ{
    #NIL: #CON{#NIL, #CON{#NIL, #NIL}}
    #CON: λ&h. λ&t.
      !!&rest = @omni_unzip(t);
      λ{
        #CON: λ&a. λ&b_cell.
          λ{#CON: λ&b. λ&_.
            λ{#CON: λ&as. λ&bs_cell.
              λ{#CON: λ&bs. λ&_.
                #CON{#CON{a, as}, #CON{#CON{b, bs}, #NIL}}
              }(bs_cell)
            }(rest)
          }(b_cell)
      }(h)
    #Arr: λ&len. λ&data.
      (λ&unzipped.
        λ{#CON: λ&as. λ&rest.
          λ{#CON: λ&bs. λ&_.
            #CON{#Arr{len, as}, #CON{#Arr{len, bs}, #NIL}}
          }(rest)
        }(unzipped)
      )(@omni_unzip(data))
  }(xs)

// Group by key function
// Group by key function
// Polymorphic: List, Array, Iterator, Range (delegates to foldl which is polymorphic)
@omni_group_by = λkey_fn. λxs.
  λ{
    #Arr: λ&len. λ&data.
      // For arrays, convert result back to array of arrays
      @omni_map(λ&group.
        λ{#CON: λ&k. λ&vals_cell.
          λ{#CON: λ&vals. λ&_. #CON{k, #CON{#Arr{@omni_seq_length(vals), vals}, #NIL}}}(vals_cell)
        }(group)
      )(@omni_group_by_list(key_fn)(data))
    _: λ&u_. @omni_group_by_list(key_fn)(@omni_to_list(xs))
  }(xs)

// Helper: group_by for lists
@omni_group_by_list = λkey_fn. λxs.
  @omni_foldl(@omni_group_by_insert(key_fn))(#NIL)(xs)

@omni_group_by_insert = λkey_fn. λgroups. λx.
  !!&k = key_fn(x);
  @omni_group_by_add(k)(x)(groups)

@omni_group_by_add = λk. λx. λgroups.
  λ{
    #NIL: #CON{#CON{k, #CON{#CON{x, #NIL}, #NIL}}, #NIL}
    #CON: λ&group. λ&rest.
      λ{
        #CON: λ&gk. λ&gv_cell.
          λ{
            1:
              λ{#CON: λ&gv. λ&_.
                #CON{#CON{gk, #CON{#CON{x, gv}, #NIL}}, rest}
              }(gv_cell)
            _: #CON{group, @omni_group_by_add(k)(x)(rest)}
          }((gk == k))
      }(group)
  }(groups)

// Partition by predicate
// Polymorphic: List, Array, Iterator, Range
// Returns (satisfying, not-satisfying) pair, same type as input for Array
@omni_partition = λp. λxs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&result.
        λ{#CON: λ&yes. λ&no_cell.
          λ{#CON: λ&no. λ&_.
            #CON{#Arr{@omni_seq_length(yes), yes}, #CON{#Arr{@omni_seq_length(no), no}, #NIL}}
          }(no_cell)
        }(result)
      )(@omni_partition_list(p)(data))
    _: λ&u_. @omni_partition_list(p)(@omni_to_list(xs))
  }(xs)

// Helper: partition for lists
@omni_partition_list = λp. λxs.
  @omni_foldl(λacc. λx.
    λ{#CON: λ&yes. λ&no_cell.
      λ{#CON: λ&no. λ&_.
        λ{
          1: #CON{#CON{x, yes}, #CON{no, #NIL}}
          _: #CON{yes, #CON{#CON{x, no}, #NIL}}
        }(p(x))
      }(no_cell)
    }(acc)
  )(#CON{#NIL, #CON{#NIL, #NIL}})(xs)

// Slice sequence from start to end (exclusive)
// Polymorphic: List, Array, Iterator, Range
@omni_slice = λstart. λend. λxs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&sliced. #Arr{@omni_seq_length(sliced), sliced})(@omni_take((end - start))(@omni_drop(start)(data)))
    _: λ&u_. @omni_take((end - start))(@omni_drop(start)(xs))
  }(xs)

// Range of integers
@omni_range = λstart. λend.
  λ{
    1: #NIL
    _: #CON{start, @omni_range((start + 1))(end)}
  }((start >= end))

// Range with step
@omni_range_step = λstart. λend. λstep.
  λ{
    1: #NIL
    _: #CON{start, @omni_range_step((start + step))(end)(step)}
  }((start >= end))

// =============================================================================
// Sorting (Merge Sort)
// =============================================================================

// Sort with comparator function (PARALLEL merge sort)
// Polymorphic: List, Array, Iterator, Range
// cmp returns: negative if a < b, 0 if a == b, positive if a > b
@omni_sort = λ&cmp. λ&xs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&sorted. #Arr{len, sorted})(@omni_sort_list(cmp)(data))
    #Iter: λ&state. λ&next_fn. @omni_sort_list(cmp)(@omni_iter_to_list(xs))
    #Rang: λ&s. λ&e. λ&st. @omni_sort_list(cmp)(@omni_iter_to_list(xs))
    _: λ&u_. @omni_sort_list(cmp)(xs)
  }(xs)

// Helper: sort list (merge sort, parallel)
@omni_sort_list = λ&cmp. λ&xs.
  !!&len = @omni_length_fast(xs);
  λ{
    0: xs
    1: xs
    _:
      !!&mid = (len / 2);
      !!&left = @omni_take(mid)(xs);
      !!&right = @omni_drop(mid)(xs);
      // PARALLEL: sort both halves simultaneously
      !!&sorted_left = @omni_sort_list(cmp)(left);
      !!&sorted_right = @omni_sort_list(cmp)(right);
      @omni_merge(cmp)(sorted_left)(sorted_right)
  }(len)

// Sort - SEQUENTIAL version
// Polymorphic: List, Array, Iterator, Range
@omni_sort_seq = λcmp. λxs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&sorted. #Arr{len, sorted})(@omni_sort_list_seq(cmp)(data))
    _: λ&u_. @omni_sort_list_seq(cmp)(@omni_to_list(xs))
  }(xs)

// Helper: sort list sequential
@omni_sort_list_seq = λcmp. λxs.
  !!&len = @omni_length_fast(xs);
  λ{
    0: xs
    1: xs
    _:
      !!&mid = (len / 2);
      !!&left = @omni_take(mid)(xs);
      !!&right = @omni_drop(mid)(xs);
      @omni_merge(cmp)(@omni_sort_list_seq(cmp)(left))(@omni_sort_list_seq(cmp)(right))
  }(len)

// Merge two sorted lists
@omni_merge = λcmp. λxs. λys.
  λ{
    #NIL: ys
    #CON: λ&xh. λ&xt.
      λ{
        #NIL: xs
        #CON: λ&yh. λ&yt.
          !!&c = cmp(xh)(yh);
          λ{
            1: #CON{xh, @omni_merge(cmp)(xt)(ys)}  // xh <= yh
            _: #CON{yh, @omni_merge(cmp)(xs)(yt)}
          }((c <= 0))
      }(ys)
  }(xs)

// Sort ascending (for numbers)
// Polymorphic: delegates to @omni_sort
@omni_sort_asc = λxs.
  @omni_sort(λa. λb. (a - b))(xs)

// Sort descending
@omni_sort_desc = λxs.
  @omni_sort(λa. λb. (b - a))(xs)

// Sort by key function
@omni_sort_by = λkey_fn. λxs.
  @omni_sort(λa. λb. (key_fn(a) - key_fn(b)))(xs)

// =============================================================================
// Set Operations (Lists as Sets)
// =============================================================================

// Create set from list (remove duplicates)
@omni_set_from_list = λxs.
  @omni_foldl(λacc. λx.
    λ{
      1: acc  // Already in set
      _: #CON{x, acc}
    }(@omni_contains(x)(acc))
  )(#NIL)(xs)

// Set union
@omni_set_union = λxs. λys.
  @omni_foldl(λacc. λx.
    λ{
      1: acc
      _: #CON{x, acc}
    }(@omni_contains(x)(acc))
  )(ys)(xs)

// Set intersection
@omni_set_intersection = λxs. λys.
  @omni_filter(λx. @omni_contains(x)(ys))(xs)

// Set difference (xs - ys)
@omni_set_difference = λxs. λys.
  @omni_filter(λx.
    λ{1: 0; _: 1}(@omni_contains(x)(ys))
  )(xs)

// Symmetric difference
@omni_set_symmetric_difference = λxs. λys.
  @omni_set_union(@omni_set_difference(xs)(ys))(@omni_set_difference(ys)(xs))

// =============================================================================
// Dictionary Operations (Association Lists)
// =============================================================================

// Lookup key in dict
@omni_dict_get = λkey. λdict.
  λ{
    #NIL: #Noth{}
    #CON: λ&entry. λ&rest.
      λ{
        #CON: λ&k. λ&v_cell.
          λ{
            1: λ{#CON: λ&v. λ&_. v}(v_cell)
            _: @omni_dict_get(key)(rest)
          }((k == key))
      }(entry)
  }(dict)

// Get with default
@omni_dict_get_or = λkey. λdefault. λdict.
  !!&result = @omni_dict_get(key)(dict);
  λ{
    #Noth: default
    _: result
  }(result)

// Insert/update key
@omni_dict_assoc = λkey. λval. λdict.
  λ{
    #NIL: #CON{#CON{key, #CON{val, #NIL}}, #NIL}
    #CON: λ&entry. λ&rest.
      λ{
        #CON: λ&k. λ&_.
          λ{
            1: #CON{#CON{key, #CON{val, #NIL}}, rest}  // Replace
            _: #CON{entry, @omni_dict_assoc(key)(val)(rest)}
          }((k == key))
      }(entry)
  }(dict)

// Remove key
@omni_dict_dissoc = λkey. λdict.
  @omni_filter(λentry.
    λ{#CON: λ&k. λ&_. (k != key)}(entry)
  )(dict)

// Get all keys
@omni_dict_keys = λdict.
  @omni_map(λentry.
    λ{#CON: λ&k. λ&_. k}(entry)
  )(dict)

// Get all values
@omni_dict_vals = λdict.
  @omni_map(λentry.
    λ{#CON: λ&_. λ&v_cell. λ{#CON: λ&v. λ&_. v}(v_cell)}(entry)
  )(dict)

// Get all entries as pairs
@omni_dict_entries = λdict. dict

// Merge dictionaries (later values override earlier)
@omni_dict_merge = λd1. λd2.
  @omni_foldl(λacc. λentry.
    λ{#CON: λ&k. λ&v_cell.
      λ{#CON: λ&v. λ&_. @omni_dict_assoc(k)(v)(acc)}(v_cell)
    }(entry)
  )(d1)(d2)

// Update value at key with function
@omni_dict_update = λkey. λf. λdict.
  !!&old = @omni_dict_get(key)(dict);
  λ{
    #Noth: dict
    _: @omni_dict_assoc(key)(f(old))(dict)
  }(old)

// Check if key exists
@omni_dict_has_key = λkey. λdict.
  !!&result = @omni_dict_get(key)(dict);
  λ{
    #Noth: 0
    _: 1
  }(result)

// Map over values
@omni_dict_map_vals = λf. λdict.
  @omni_map(λentry.
    λ{#CON: λ&k. λ&v_cell.
      λ{#CON: λ&v. λ&_. #CON{k, #CON{f(v), #NIL}}}(v_cell)
    }(entry)
  )(dict)

// Filter entries
@omni_dict_filter = λp. λdict.
  @omni_filter(λentry.
    λ{#CON: λ&k. λ&v_cell.
      λ{#CON: λ&v. λ&_. p(k)(v)}(v_cell)
    }(entry)
  )(dict)

// =============================================================================
// Array Operations (HVM4 Arrays)
// =============================================================================

// Create array from list
// =============================================================================
// Array-Specific Operations (Non-Polymorphic)
// =============================================================================
// Note: Most array operations are now handled by polymorphic functions:
//   - @omni_nth (O(1) for arrays)
//   - @omni_map, @omni_filter (preserve array type)
//   - @omni_slice (preserves array type)
//   - @omni_to_list (converts any sequence to list)
//   - @omni_seq_length (O(1) for arrays)

// Create array from list
@omni_array_from_list = λxs.
  #Arr{@omni_seq_length(xs), xs}

// Set element at index (returns new array) - unique array operation
@omni_array_set = λidx. λval. λarr.
  λ{
    #Arr: λ&len. λ&elems.
      λ{
        1: arr  // Out of bounds, return unchanged
        _:
          !!&new_elems = @omni_list_set(idx)(val)(elems);
          #Arr{len, new_elems}
      }((idx >= len))
  }(arr)

@omni_list_set = λidx. λval. λxs.
  λ{
    0: λ{#CON: λ&_. λ&t. #CON{val, t}; _: xs}(xs)
    _: λ{#CON: λ&h. λ&t. #CON{h, @omni_list_set((idx - 1))(val)(t)}; _: xs}(xs)
  }(idx)


// =============================================================================
// Utility Functions
// =============================================================================

// Identity function
@omni_identity = λx. x

// Constant function
@omni_const = λx. λ_. x

// Compose two functions
@omni_compose = λf. λg. λx. f(g(x))

// Apply function to argument
@omni_apply = λf. λx. f(x)

// Flip argument order
@omni_flip = λf. λa. λb. f(b)(a)

// Create a pair
@omni_pair = λa. λb. #CON{a, #CON{b, #NIL}}

// First of pair
@omni_fst = λp.
  λ{#CON: λ&a. λ&_. a}(p)

// Second of pair
@omni_snd = λp.
  λ{#CON: λ&_. λ&b_cell. λ{#CON: λ&b. λ&_. b}(b_cell)}(p)

// Repeat value n times
@omni_repeat = λn. λval.
  λ{
    0: #NIL
    _: #CON{val, @omni_repeat((n - 1))(val)}
  }(n)

// Iterate function n times from seed
@omni_iterate = λn. λf. λseed.
  λ{
    0: #NIL
    _: #CON{seed, @omni_iterate((n - 1))(f)(f(seed))}
  }(n)

// Sum a list of numbers (PARALLEL tree reduction)
// Addition is associative, so we can reduce in parallel
// Sum of a sequence of numbers (PARALLEL tree reduction)
// Polymorphic: List, Array, Iterator, Range
@omni_sum = λ&xs.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t. λ{#NIL: h; _: @omni_reduce_tree(λa. λb. (a + b))(xs)}(t)
    #Arr: λ&len. λ&data. @omni_sum(data)
    #Iter: λ&state. λ&next_fn. @omni_sum(@omni_iter_to_list(xs))
    #Rang: λ&s. λ&e. λ&st.
      // Arithmetic series: n*(first+last)/2
      (λ&n. (n * (s + (s + ((n - 1) * st))) / 2))(((e - s) / st))
  }(xs)

// Sum - SEQUENTIAL version
// Polymorphic: delegates to foldl which is polymorphic
@omni_sum_seq = λxs. @omni_foldl(λa. λb. (a + b))(0)(xs)

// Product of a sequence of numbers (PARALLEL tree reduction)
// Polymorphic: List, Array, Iterator, Range
@omni_product = λ&xs.
  λ{
    #NIL: 1
    #CON: λ&h. λ&t. λ{#NIL: h; _: @omni_reduce_tree(λa. λb. (a * b))(xs)}(t)
    #Arr: λ&len. λ&data. @omni_product(data)
    #Iter: λ&state. λ&next_fn. @omni_product(@omni_iter_to_list(xs))
    #Rang: λ&s. λ&e. λ&st. @omni_product(@omni_iter_to_list(xs))
  }(xs)

// Product - SEQUENTIAL version
// Polymorphic: delegates to foldl which is polymorphic
@omni_product_seq = λxs. @omni_foldl(λa. λb. (a * b))(1)(xs)

// Maximum in sequence (PARALLEL tree reduction)
// Polymorphic: List, Array, Iterator, Range
@omni_maximum = λ&xs.
  λ{
    #NIL: #Err{#sym_EmptyList, #sym_maximum}
    #CON: λ&h. λ&t. λ{#NIL: h; _: @omni_reduce_tree(λa. λb. λ{1: a; _: b}((a > b)))(xs)}(t)
    #Arr: λ&len. λ&data. @omni_maximum(data)
    #Iter: λ&state. λ&next_fn. @omni_maximum(@omni_iter_to_list(xs))
    #Rang: λ&s. λ&e. λ&st. λ{1: (e - st); _: s}((st > 0))  // max is last for positive step, first for negative
  }(xs)

// Maximum - SEQUENTIAL version
// Polymorphic: List, Array, Iterator, Range
@omni_maximum_seq = λxs.
  (λ&data.
    λ{
      #NIL: #Err{#sym_EmptyList, #sym_maximum}
      #CON: λ&h. λ&t. @omni_foldl(λacc. λx. λ{1: x; _: acc}((x > acc)))(h)(t)
    }(data)
  )(@omni_to_list(xs))

// Minimum in sequence (PARALLEL tree reduction)
// Polymorphic: List, Array, Iterator, Range
@omni_minimum = λ&xs.
  λ{
    #NIL: #Err{#sym_EmptyList, #sym_minimum}
    #CON: λ&h. λ&t. λ{#NIL: h; _: @omni_reduce_tree(λa. λb. λ{1: a; _: b}((a < b)))(xs)}(t)
    #Arr: λ&len. λ&data. @omni_minimum(data)
    #Iter: λ&state. λ&next_fn. @omni_minimum(@omni_iter_to_list(xs))
    #Rang: λ&s. λ&e. λ&st. λ{1: s; _: (e - st)}((st > 0))  // min is first for positive step, last for negative
  }(xs)

// Minimum - SEQUENTIAL version
// Polymorphic: List, Array, Iterator, Range
@omni_minimum_seq = λxs.
  (λ&data.
    λ{
      #NIL: #Err{#sym_EmptyList, #sym_minimum}
      #CON: λ&h. λ&t. @omni_foldl(λacc. λx. λ{1: x; _: acc}((x < acc)))(h)(t)
    }(data)
  )(@omni_to_list(xs))

// Intersperse element between sequence elements
// Polymorphic: List, Array, Iterator, Range
@omni_intersperse = λsep. λxs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. λ{#NIL: #CON{h, #NIL}; _: #CON{h, #CON{sep, @omni_intersperse(sep)(t)}}}(t)
    #Arr: λ&len. λ&data.
      (λ&result. #Arr{@omni_seq_length(result), result})(@omni_intersperse(sep)(data))
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{xs, #CON{sep, #CON{0, #NIL}}}, @omni_intersperse_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{xs, #CON{sep, #CON{0, #NIL}}}, @omni_intersperse_iter_next}
  }(xs)

// Helper: intersperse iterator next
@omni_intersperse_iter_next = λ&state.
  λ{#CON: λ&iter. λ&rest.
    λ{#CON: λ&sep. λ&flag_cell.
      λ{#CON: λ&need_sep. λ&_.
        λ{
          0: // Don't need separator, emit element
            (λ&stepped. λ{
              #Some: λ&v. λ&r. #Some{v, #CON{r, #CON{sep, #CON{1, #NIL}}}}
              #None: #None{}
            }(stepped))(@omni_iter_step(iter))
          _: // Need separator first
            (λ&stepped. λ{
              #Some: λ&v. λ&r. #Some{sep, #CON{iter, #CON{sep, #CON{0, #NIL}}}}
              #None: #None{}
            }(stepped))(@omni_iter_step(iter))
        }(need_sep)
      }(flag_cell)
    }(rest)
  }(state)

// Take while predicate holds
// Polymorphic: List, Array, Iterator, Range
@omni_take_while = λp. λxs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. λ{1: #CON{h, @omni_take_while(p)(t)}; _: #NIL}(p(h))
    #Arr: λ&len. λ&data.
      (λ&result. #Arr{@omni_seq_length(result), result})(@omni_take_while(p)(data))
    #Iter: λ&state. λ&next_fn.
      #Iter{#CON{xs, #CON{p, #NIL}}, @omni_take_while_iter_next}
    #Rang: λ&s. λ&e. λ&st.
      #Iter{#CON{xs, #CON{p, #NIL}}, @omni_take_while_iter_next}
  }(xs)

// Helper: take_while iterator next
@omni_take_while_iter_next = λ&state.
  λ{#CON: λ&iter. λ&rest.
    λ{#CON: λ&p. λ&_.
      (λ&stepped. λ{
        #Some: λ&v. λ&r.
          λ{1: #Some{v, #CON{r, #CON{p, #NIL}}}; _: #None{}}(p(v))
        #None: #None{}
      }(stepped))(@omni_iter_step(iter))
    }(rest)
  }(state)

// Drop while predicate holds
// Polymorphic: List, Array, Iterator, Range
@omni_drop_while = λp. λxs.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. λ{1: @omni_drop_while(p)(t); _: xs}(p(h))
    #Arr: λ&len. λ&data.
      (λ&result. #Arr{@omni_seq_length(result), result})(@omni_drop_while(p)(data))
    #Iter: λ&state. λ&next_fn. @omni_drop_while_iter(p)(xs)
    #Rang: λ&s. λ&e. λ&st. @omni_drop_while_iter(p)(xs)
  }(xs)

// Helper: drop_while for iterators (materializes dropped portion)
@omni_drop_while_iter = λ&p. λ&iter.
  (λ&stepped. λ{
    #Some: λ&v. λ&rest.
      λ{1: @omni_drop_while_iter(p)(rest); _: #Iter{#CON{v, #CON{rest, #NIL}}, @omni_drop_while_emit}}(p(v))
    #None: #Iter{#NIL, λ&x. #None{}}
  }(stepped))(@omni_iter_step(iter))

// Helper: emit rest after drop_while
@omni_drop_while_emit = λ&state.
  λ{#CON: λ&v. λ&rest.
    λ{#CON: λ&iter. λ&_.
      #Some{v, iter}
    }(rest)
  }(state)

// Unique elements (preserving order)
// Polymorphic: List, Array, Iterator, Range
@omni_unique = λxs.
  λ{
    #Arr: λ&len. λ&data.
      (λ&result. #Arr{@omni_seq_length(result), result})(@omni_unique_list(data))
    _: λ&u_. @omni_unique_list(@omni_to_list(xs))
  }(xs)

// Helper: unique for lists
@omni_unique_list = λxs.
  @omni_reverse(@omni_set_from_list(@omni_reverse(xs)))

// Count occurrences satisfying predicate
// Polymorphic: delegates to foldl which is polymorphic
@omni_count = λp. λxs.
  @omni_foldl(λacc. λx. λ{1: (acc + 1); _: acc}(p(x)))(0)(xs)

