// OmniLisp Type System Library
// Type descriptors, multiple dispatch, and runtime type checking

// =============================================================================
// Type Descriptors
// =============================================================================

// Type descriptor format: #TDsc{name, parent, fields}
// - name: nick-encoded type name
// - parent: parent type descriptor (or #NIL for root types)
// - fields: list of field descriptors

// Built-in type descriptors
// Using nick-encoded numeric values instead of #sym_X to ensure NUM terms (not C00 constructors)
// HVM4 nick encoding: _ = 0, a-z = 1-26, A-Z = 27-52, 0-9 = 53-62, $ = 63
@type_Any      = #TDsc{111513, #NIL, #NIL}              // nick("Any")
@type_Nothing  = #TDsc{2134919, @type_Any, #NIL}        // nick("Nothing")
@type_Int      = #TDsc{144276, @type_Any, #NIL}         // nick("Int")
@type_Float    = #TDsc{3207252, @type_Any, #NIL}        // nick("Float")
@type_Bool     = #TDsc{7402444, @type_Any, #NIL}        // nick("Bool")
@type_Char     = #TDsc{7635026, @type_Any, #NIL}        // nick("Char")
@type_Symbol   = #TDsc{3417036, @type_Any, #NIL}        // nick("Symbol")
@type_String   = #TDsc{11879561, @type_Any, #NIL}       // nick("Stri") - parser truncates to 4 chars
@type_List     = #TDsc{9999572, @type_Any, #NIL}        // nick("List")
@type_Function = #TDsc{5280718, @type_Any, #NIL}        // nick("Function")
@type_Handle   = #TDsc{3687173, @type_Any, #NIL}        // nick("Handle")

// =============================================================================
// Type Hierarchy
// =============================================================================

// Check if type A is subtype of type B
@subtype_check = λ&type_a. λ&type_b.
  λ{
    #TDsc: λ&name_a. λ&parent_a. λ&fields_a_unused.
      λ{
        #TDsc: λ&name_b. λ&parent_b_unused. λ&fields_b_unused.
          // Same type?
          λ{
            1: #True{}
            _:
              // Check parent
              λ{
                #NIL: #Fals{}
                _: @subtype_check(parent_a)(type_b)
              }(parent_a)
          }((name_a == name_b))
      }(type_b)
  }(type_a)

// Get type name from descriptor
@type_name = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields. name
    _: #sym_Unknown
  }(type)

// Get parent type
@type_parent = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields. parent
    _: #NIL
  }(type)

// Get type fields
@type_fields = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields. fields
    _: #NIL
  }(type)

// =============================================================================
// Runtime Type Inference
// =============================================================================

// Infer the type descriptor from a runtime value
@infer_type = λval.
  λ{
    #Cst: λ&n. @type_Int
    #Fix: λ&hi. λ&lo. λ&scale. @type_Float
    #CHR: λ&c. @type_Char
    #Sym: λ&s. @type_Symbol
    #CON: λ&h. λ&t. @type_List
    #NIL: @type_List
    #Clo: λ&e. λ&b. @type_Function
    #CloR: λ&e. λ&b. @type_Function
    #Hndl: λ&idx. λ&gen. @type_Handle
    #True: @type_Bool
    #Fals: @type_Bool
    #Noth: @type_Nothing
    _: @type_Any
  }(val)

// Check if value has given type
@has_type_check = λval. λtype.
  !!&inferred = @infer_type(val);
  @subtype_check(inferred)(type)

// =============================================================================
// Multiple Dispatch
// =============================================================================

// Method table: list of #Meth{name, sig, impl}
// - name: method name (symbol)
// - sig: list of parameter types
// - impl: implementation function

// Global method registry (would be populated by define-method)
// For now, this is a stub that would be extended at runtime

// Find most specific method for given types
@dispatch_find = λ&name. λ&arg_types. λ&methods.
  λ{
    #NIL: #Noth{}  // No matching method
    #CON: λ&meth. λ&rest.
      λ{
        #Meth: λ&mname. λ&msig. λ&mimpl_unused.
          λ{
            1:
              // Check if signature matches
              !!&matches = @sig_matches_check(arg_types)(msig);
              λ{
                #True:
                  // Found a match - check if it's more specific than rest
                  !!&rest_match = @dispatch_find(name)(arg_types)(rest);
                  λ{
                    #Noth: meth
                    _:
                      // Compare specificity
                      !!&more_specific = @more_specific_check(msig)(λ{#Meth: λ&n_. λ&s. λ&i_. s}(rest_match));
                      λ{
                        #True: meth
                        _: rest_match
                      }(more_specific)
                  }(rest_match)
                _: @dispatch_find(name)(arg_types)(rest)
              }(matches)
            _: @dispatch_find(name)(arg_types)(rest)
          }((mname == name))
      }(meth)
  }(methods)

// Check if argument types match signature
@sig_matches_check = λ&arg_types. λ&sig.
  λ{
    #NIL:
      λ{
        #NIL: #True{}
        _: #Fals{}
      }(sig)
    #CON: λ&ah. λ&at.
      λ{
        #NIL: #Fals{}
        #CON: λ&sh. λ&st.
          λ{
            #True: @sig_matches_check(at)(st)
            _: #Fals{}
          }(@subtype_check(ah)(sh))
      }(sig)
  }(arg_types)

// Check if sig_a is more specific than sig_b
@more_specific_check = λ&sig_a. λ&sig_b.
  λ{
    #NIL: #Fals{}  // Empty signature - not more specific
    #CON: λ&ah. λ&at.
      λ{
        #NIL: #Fals{}
        #CON: λ&bh. λ&bt.
          λ{
            #True: #True{}  // ah is subtype of bh - more specific
            _: @more_specific_check(at)(bt)  // Check rest
          }(@subtype_check(ah)(bh))
      }(sig_b)
  }(sig_a)

// Invoke a method by name with arguments
@invoke_method = λ&name. λ&args. λ&methods.
  !!&arg_types = @map(@infer_type)(args);
  !!&meth = @dispatch_find(name)(arg_types)(methods);
  λ{
    #Noth: #Err{#sym_nomethod, name}
    #Meth: λ&mname_unused. λ&msig_unused. λ&impl.
      @apply_args(impl)(args)
  }(meth)

// Apply function to list of arguments
@apply_args = λ&f. λ&args.
  λ{
    #NIL: f
    #CON: λ&h. λ&t. @apply_args(f(h))(t)
  }(args)

// =============================================================================
// Type Constructors
// =============================================================================

// Create a new type descriptor
@make_type = λname. λparent. λfields.
  #TDsc{name, parent, fields}

// Create a method descriptor
@make_method = λname. λsig. λimpl.
  #Meth{name, sig, impl}

// =============================================================================
// Generic Function Helpers
// =============================================================================

// Create a generic function (multi-method dispatcher)
@make_generic = λname.
  λmethods. λargs.
    @invoke_method(name)(args)(methods)

// Add a method to a generic function's method list
@add_method = λmethods. λname. λsig. λimpl.
  #CON{#Meth{name, sig, impl}, methods}

// =============================================================================
// OmniLisp Dispatch Runtime (Compiler Integration)
// =============================================================================

// Global method registry - maps function names to method lists
// In a real implementation, this would be a hash table or ref cell
// For now, methods are stored directly in the #GFun node

// Create a generic function from a method list (compiler entrypoint)
// Returns a callable that dispatches based on argument types
@omni_make_generic = λname. λmethods.
  #GFun{name, methods}

// Main dispatch function (compiler entrypoint)
// Takes a generic function and argument list, finds best method and invokes
@omni_dispatch = λ&gfun. λ&args.
  λ{
    #GFun: λ&name. λ&methods.
      !!&arg_types = @omni_infer_arg_types(args);
      !!&meth = @dispatch_find(name)(arg_types)(methods);
      λ{
        #Noth: #Err{#sym_NoMethod, #CON{name, args}}
        #Meth: λ&mname_u. λ&msig_u. λ&impl.
          @omni_apply_list(impl)(args)
      }(meth)
    _: #Err{#sym_NotGeneric, gfun}
  }(gfun)

// Infer types of arguments (for dispatch)
@omni_infer_arg_types = λ&args.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. #CON{@infer_type(h), @omni_infer_arg_types(t)}
  }(args)

// Apply function to list of arguments
@omni_apply_list = λ&f. λ&args.
  λ{
    #NIL: f
    #CON: λ&h. λ&t. @omni_apply_list(f(h))(t)
  }(args)

// Convenience: Call a generic function by name (for interpreted dispatch)
@omni_call_generic = λgfun. λarg1.
  @omni_dispatch(gfun)(#CON{arg1, #NIL})

@omni_call_generic2 = λgfun. λarg1. λarg2.
  @omni_dispatch(gfun)(#CON{arg1, #CON{arg2, #NIL}})

@omni_call_generic3 = λgfun. λarg1. λarg2. λarg3.
  @omni_dispatch(gfun)(#CON{arg1, #CON{arg2, #CON{arg3, #NIL}}})

// =============================================================================
// Type Annotations (for compiler)
// =============================================================================

// Type annotation marker (erased at runtime)
// #TAnn{expr, type} - type annotation on expression
// Used by compiler for dispatch optimization

// Extract expression from annotation
@tann_expr = λ&tann.
  λ{
    #TAnn: λ&expr. λ&type_u. expr
    _: tann
  }(tann)

// Extract type from annotation
@tann_type = λ&tann.
  λ{
    #TAnn: λ&expr_u. λ&type. type
    _: @type_Any
  }(tann)

// =============================================================================
// Parameterized Types
// =============================================================================

// Type application: #TApp{base, params}
// e.g., List<Int> = #TApp{@type_List, #CON{@type_Int, #NIL}}

@make_type_app = λbase. λparams.
  #TApp{base, params}

@type_app_base = λ&tapp.
  λ{
    #TApp: λ&base. λ&params_u. base
    _: tapp
  }(tapp)

@type_app_params = λ&tapp.
  λ{
    #TApp: λ&base_u. λ&params. params
    _: #NIL
  }(tapp)

// =============================================================================
// Superposition Types
// =============================================================================

// Superposition type: #TSup{elem_type}
// Represents HVM4's non-deterministic superposition of values
// A value of type {(Sup T)} can be any value of type T simultaneously
// Used for parallel branching and probabilistic programming

@make_sup_type = λelem_type.
  #TSup{elem_type}

@sup_type_elem = λtsup.
  λ{
    #TSup: λ&elem. elem
    _: @type_Any
  }(tsup)

// Check if type is a superposition type
@sup_type_check = λtype.
  λ{
    #TSup: λ&u_. #True{}
    _: #Fals{}
  }(type)

// Weighted superposition type: #TWSup{elem_type}
// Represents superpositions with probability weights
// Used for probabilistic inference with importance sampling

@make_weighted_sup_type = λelem_type.
  #TWSup{elem_type}

@weighted_sup_type_elem = λtsup.
  λ{
    #TWSup: λ&elem. elem
    _: @type_Any
  }(tsup)

// Check if type is a weighted superposition
@weighted_sup_type_check = λtype.
  λ{
    #TWSup: λ&u_. #True{}
    _: #Fals{}
  }(type)

// =============================================================================
// Function Types
// =============================================================================

// Function type: #TFun{arg_types, ret_type}
// For backward compatibility, #TFun without effects = unknown purity
@make_fun_type = λarg_types. λret_type.
  #TFun{arg_types, ret_type}

// Function type with effects: #TFunE{arg_types, ret_type, effects}
// effects is #ERws{effect_list} or #NIL (pure)
@make_fun_type_with_effects = λarg_types. λret_type. λeffects.
  #TFunE{arg_types, ret_type, effects}

// Pure function type (shorthand)
@make_pure_fun_type = λarg_types. λret_type.
  #TFunE{arg_types, ret_type, #NIL}

@fun_type_args = λtfun.
  λ{
    #TFun: λ&args. λ&ret. args
    #TFunE: λ&args. λ&ret. λ&eff. args
    _: #NIL
  }(tfun)

@fun_type_ret = λtfun.
  λ{
    #TFun: λ&args. λ&ret. ret
    #TFunE: λ&args. λ&ret. λ&eff. ret
    _: @type_Any
  }(tfun)

// Get effects from function type (returns #NIL for pure, #ERws{list} for effectful)
@fun_type_effects = λtfun.
  λ{
    #TFunE: λ&args. λ&ret. λ&eff. eff
    #TFun: λ&args. λ&ret. #Noth{}  // Unknown purity
    _: #Noth{}
  }(tfun)

// Check if function type is known pure
@fun_type_pure_check = λtfun.
  λ{
    #TFunE: λ&args. λ&ret. λ&eff.
      λ{
        #NIL: #True{}
        _: #Fals{}
      }(eff)
    #TFun: λ&args. λ&ret. #Fals{}  // Unknown = not provably pure
    _: #Fals{}
  }(tfun)

// =============================================================================
// Type Variables
// =============================================================================

// Type variable: #TVar{name}
// Used for polymorphic types

@make_type_var = λname.
  #TVar{name}

@type_var_name = λtvar.
  λ{
    #TVar: λ&name. name
    _: #sym_Unknown
  }(tvar)

// Check if type is a type variable
@type_var_check = λtype.
  λ{
    #TVar: λ&u_. #True{}
    _: #Fals{}
  }(type)

// =============================================================================
// Type Substitution
// =============================================================================

// Apply type substitution: subst is list of #CON{tvar, type}
@subst_type = λ&subst. λ&type.
  λ{
    #TVar: λ&name.
      @lookup_subst(name)(subst)

    #TApp: λ&base. λ&params.
      #TApp{@subst_type(subst)(base), @map(@subst_type(subst))(params)}

    #TFun: λ&args. λ&ret.
      #TFun{@map(@subst_type(subst))(args), @subst_type(subst)(ret)}

    #TFunE: λ&args. λ&ret. λ&eff.
      #TFunE{@map(@subst_type(subst))(args), @subst_type(subst)(ret), eff}

    #TSup: λ&elem.
      #TSup{@subst_type(subst)(elem)}

    #TWSup: λ&elem.
      #TWSup{@subst_type(subst)(elem)}

    _: type
  }(type)

@lookup_subst = λ&name. λ&subst.
  λ{
    #NIL: #TVar{name}  // Not found - return original var
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&var. λ&rest.
          λ{
            #CON: λ&type. λ&u_l.
              λ{
                1: type
                _: @lookup_subst(name)(t)
              }((λ{#TVar: λ&n. n}(var) == name))
          }(rest)
      }(h)
  }(subst)

// =============================================================================
// Protocol/Interface Support
// =============================================================================

// Protocol: #Prot{name, methods}
// - name: protocol name
// - methods: list of #PMeth{name, sig}

@make_protocol = λname. λmethods.
  #Prot{name, methods}

// Check if type implements protocol
@implements_check = λ&type. λ&protocol. λ&method_registry.
  λ{
    #Prot: λ&pname_unused. λ&pmethods.
      @all_methods_present_check(type)(pmethods)(method_registry)
  }(protocol)

@all_methods_present_check = λ&type. λ&pmethods. λ&registry.
  λ{
    #NIL: #True{}
    #CON: λ&pm. λ&rest.
      λ{
        #PMeth: λ&mname. λ&msig_unused.
          !!&found = @find_method_for_type(mname)(type)(registry);
          λ{
            #Noth: #Fals{}
            _: @all_methods_present_check(type)(rest)(registry)
          }(found)
      }(pm)
  }(pmethods)

@find_method_for_type = λ&name. λ&type. λ&methods.
  λ{
    #NIL: #Noth{}
    #CON: λ&meth. λ&rest.
      λ{
        #Meth: λ&mname. λ&msig. λ&mimpl_u.
          λ{
            1:
              // Check if first param type matches
              λ{
                #NIL: @find_method_for_type(name)(type)(rest)
                #CON: λ&first_type. λ&u_f.
                  λ{
                    #True: meth
                    _: @find_method_for_type(name)(type)(rest)
                  }(@subtype_check(type)(first_type))
              }(msig)
            _: @find_method_for_type(name)(type)(rest)
          }((mname == name))
      }(meth)
  }(methods)

// =============================================================================
// Type Registration (Runtime)
// =============================================================================

// Global type registry - list of registered types
// In practice, this would be a mutable ref cell or use HVM4 duplication
@type_registry = #NIL

// Register an abstract type: (define {abstract Name}) or (define {abstract Name Parent})
// Returns the type descriptor for use in type annotations
@omni_register_abstract = λ&name. λ&parent.
  !!&parent_type = (λ&p.
    λ{
      #NIL: @type_Any
      _: p
    }(p)
  )(parent);
  #TDsc{name, parent_type, #NIL}

// Register a struct type: (define {struct Name} [field1 {Type1}] [field2 {Type2}] ...)
// fields is a list of #TFld{name, type} descriptors
@omni_register_struct = λ&name. λ&parent. λ&fields. λ&mutable.
  !!&parent_type = (λ&p.
    λ{
      #NIL: @type_Any
      _: p
    }(p)
  )(parent);
  #TStr{name, parent_type, fields, mutable}

// Register an enum type: (define {enum Name} Variant1 (Variant2 [field {Type}]) ...)
// variants is a list of #TVrn{name, fields} descriptors
@omni_register_enum = λname. λvariants.
  #TEnm{name, variants}

// Register a union type: (define {Name} (union [{Type1} {Type2}]))
// types is a list of type descriptors
@omni_register_union = λname. λtypes.
  #TUni{name, types}

// =============================================================================
// Struct Field Operations
// =============================================================================

// Create a field descriptor
@make_field = λname. λtype.
  #TFld{name, type}

// Get field name
@field_name = λfield.
  λ{
    #TFld: λ&name. λ&type. name
    _: #sym_Unknown
  }(field)

// Get field type
@field_type = λfield.
  λ{
    #TFld: λ&name. λ&type. type
    _: @type_Any
  }(field)

// Find field by name in struct type
@find_field = λ&struct_type. λ&field_name.
  λ{
    #TStr: λ&name_u. λ&parent_u. λ&fields. λ&mutable_u.
      @find_in_fields(fields)(field_name)
    #TDsc: λ&name_u. λ&parent_u. λ&fields.
      @find_in_fields(fields)(field_name)
    _: #Noth{}
  }(struct_type)

@find_in_fields = λ&fields. λ&name.
  λ{
    #NIL: #Noth{}
    #CON: λ&field. λ&rest.
      λ{
        #TFld: λ&fname. λ&ftype_u.
          λ{
            1: field
            _: @find_in_fields(rest)(name)
          }((fname == name))
      }(field)
  }(fields)

// =============================================================================
// Enum Variant Operations
// =============================================================================

// Create an enum variant descriptor
@make_variant = λname. λfields.
  #TVrn{name, fields}

// Get variant name
@variant_name = λvariant.
  λ{
    #TVrn: λ&name. λ&fields. name
    _: #sym_Unknown
  }(variant)

// Get variant fields
@variant_fields = λvariant.
  λ{
    #TVrn: λ&name. λ&fields. fields
    _: #NIL
  }(variant)

// Find variant by name in enum type
@find_variant = λ&enum_type. λ&variant_name.
  λ{
    #TEnm: λ&name_u. λ&variants.
      @find_in_variants(variants)(variant_name)
    _: #Noth{}
  }(enum_type)

@find_in_variants = λ&variants. λ&name.
  λ{
    #NIL: #Noth{}
    #CON: λ&variant. λ&rest.
      λ{
        #TVrn: λ&vname. λ&vfields_u.
          λ{
            1: variant
            _: @find_in_variants(rest)(name)
          }((vname == name))
      }(variant)
  }(variants)

// =============================================================================
// Union Type Operations
// =============================================================================

// Check if value matches any type in union
@union_matches_check = λ&val. λ&union_type.
  λ{
    #TUni: λ&name_u. λ&types.
      @any_type_matches_check(val)(types)
    _: #Fals{}
  }(union_type)

@any_type_matches_check = λ&val. λ&types.
  λ{
    #NIL: #Fals{}
    #CON: λ&type. λ&rest.
      λ{
        #True: #True{}
        _: @any_type_matches_check(val)(rest)
      }(@has_type_check(val)(type))
  }(types)

// =============================================================================
// Type Checking Utilities
// =============================================================================

// Check if a type is an abstract type
@abstract_type_check = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields.
      λ{
        #NIL: #True{}  // No fields = abstract
        _: #Fals{}
      }(fields)
    _: #Fals{}
  }(type)

// Check if a type is a struct type
@struct_type_check = λtype.
  λ{
    #TStr: λ&u1_. λ&u2_. λ&u3_. λ&u4_. #True{}
    _: #Fals{}
  }(type)

// Check if a type is an enum type
@enum_type_check = λtype.
  λ{
    #TEnm: λ&u1_. λ&u2_. #True{}
    _: #Fals{}
  }(type)

// Check if a type is a union type
@union_type_check = λtype.
  λ{
    #TUni: λ&u1_. λ&u2_. #True{}
    _: #Fals{}
  }(type)

// Check if a struct type is mutable
@mutable_struct_check = λtype.
  λ{
    #TStr: λ&name. λ&parent. λ&fields. λ&mutable.
      λ{
        #True: #True{}
        _: #Fals{}
      }(mutable)
    _: #Fals{}
  }(type)

// =============================================================================
// Parametric Type Support
// =============================================================================

// Instantiate a parametric type with concrete type arguments
// type_params is list of #TVar names, type_args is list of concrete types
@instantiate_type = λ&base_type. λ&type_params. λ&type_args.
  !!&subst = @build_subst(type_params)(type_args);
  @subst_type_deep(subst)(base_type)

@build_subst = λ&params. λ&args.
  λ{
    #NIL: #NIL
    #CON: λ&param. λ&rest_params.
      λ{
        #NIL: #NIL
        #CON: λ&arg. λ&rest_args.
          #CON{#CON{param, #CON{arg, #NIL}}, @build_subst(rest_params)(rest_args)}
      }(args)
  }(params)

// Deep substitution in all nested types
@subst_type_deep = λ&subst. λ&type.
  λ{
    #TVar: λ&name.
      @lookup_subst(name)(subst)

    #TApp: λ&base. λ&params.
      #TApp{@subst_type_deep(subst)(base), @map(@subst_type_deep(subst))(params)}

    #TFun: λ&args. λ&ret.
      #TFun{@map(@subst_type_deep(subst))(args), @subst_type_deep(subst)(ret)}

    #TFunE: λ&args. λ&ret. λ&eff.
      #TFunE{@map(@subst_type_deep(subst))(args), @subst_type_deep(subst)(ret), eff}

    #TSup: λ&elem.
      #TSup{@subst_type_deep(subst)(elem)}

    #TWSup: λ&elem.
      #TWSup{@subst_type_deep(subst)(elem)}

    #TStr: λ&name. λ&parent. λ&fields. λ&mutable.
      #TStr{name, @subst_type_deep(subst)(parent), @map(@subst_field(subst))(fields), mutable}

    #TDsc: λ&name. λ&parent. λ&fields.
      #TDsc{name, @subst_type_deep(subst)(parent), @map(@subst_field(subst))(fields)}

    _: type
  }(type)

@subst_field = λ&subst. λ&field.
  λ{
    #TFld: λ&name. λ&type.
      #TFld{name, @subst_type_deep(subst)(type)}
  }(field)

// =============================================================================
// Type Unification
// =============================================================================

// Unification result types:
// #USuc{subst} - success with substitution (list of #CON{tvar, type})
// #UFal{reason} - failure with reason

// Main unification function
// Returns #USuc{subst} or #UFal{reason}
@unify = λ&type_a. λ&type_b.
  @unify_with_subst(#NIL)(type_a)(type_b)

// Unify with existing substitution
@unify_with_subst = λ&subst. λ&type_a. λ&type_b.
  // Skip apply_subst for now to debug
  @unify_core(subst)(type_a)(type_b)

// Core unification (types already have substitution applied)
// Uses helper to handle nested pattern matching with linearity
@unify_core = λ&subst. λ&type_a. λ&type_b.
  // Clone all inputs for use in closures
  !!&s = subst;
  !!&ta = type_a;
  !!&tb = type_b;
  @unify_core_dispatch(s)(ta)(tb)

// Dispatch based on type_a
@unify_core_dispatch = λ&s. λ&ta. λ&tb.
  λ{
    // Type variable on left
    #TVar: λ&name_a.
      @unify_tvar_left(s)(name_a)(ta)(tb)

    // Type constructor on left
    #TCon: λ&name_a.
      @unify_tcon_left(s)(name_a)(ta)(tb)

    // Default: check equality
    _: @unify_default(s)(ta)(tb)
  }(ta)

// Handle #TVar on left side
@unify_tvar_left = λ&s. λ&name_a. λ&ta. λ&tb.
  λ{
    // Both type variables
    #TVar: λ&name_b.
      (λ&same.
        λ{
          1: #USuc{s}  // Same variable
          0: // Different variables - bind name_a to name_b
            #USuc{#CON{#CON{#TVar{name_a}, #CON{#TVar{name_b}, #NIL}}, s}}
        }(same)
      )((name_a == name_b))
    // Type constructor on right - bind variable to it
    #TCon: λ&n.
      @bind_var(s)(name_a)(tb)
    // Any other type on right - bind variable to it
    _: @bind_var(s)(name_a)(tb)
  }(tb)

// Handle #TCon on left side
@unify_tcon_left = λ&s. λ&name_a. λ&ta. λ&tb.
  λ{
    // Type variable on right - bind it to left
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)
    // Type constructor on right - check names match
    #TCon: λ&name_b.
      (λ&same.
        λ{
          1: #USuc{s}  // Same type constructor
          0: #UFal{#sym_TypeMismatch}  // Different constructors
        }(same)
      )((name_a == name_b))
    // Any other type - mismatch
    _: #UFal{#sym_TypeMismatch}
  }(tb)

// Default handler for other types
@unify_default = λ&s. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)
    _:
      // Both concrete - check equality
      (λ&same.
        λ{
          1: #USuc{s}
          0: #UFal{#sym_TypeMismatch}
        }(same)
      )((ta == tb))
  }(tb)

// Bind type variable to a type with occurs check
@bind_var = λ&subst. λ&var_name. λ&type.
  λ{
    #True: #UFal{#sym_OccursCheck}
    #Fals: #USuc{#CON{#CON{#TVar{var_name}, #CON{type, #NIL}}, subst}}
  }(@occurs_check(var_name)(type))

// Occurs check: does type variable appear in type?
// Each branch clones var_name as needed for linearity
@occurs_check = λ&var_name. λ&type.
  λ{
    #TVar: λ&name.
      !!&vn = var_name;  // Clone for this branch
      (λ&same. λ{ 1: #True{} 0: #Fals{} }(same))((vn == name))

    #TCon: λ&name.
      #Fals{}  // Type constructors don't contain type variables

    #TApp: λ&base. λ&params.
      !!&vn1 = var_name;  // Clone for base check
      !!&vn2 = var_name;  // Clone for params check
      !!&in_base = @occurs_check(vn1)(base);
      λ{
        #True: #True{}
        _: @occurs_in_list(vn2)(params)
      }(in_base)

    #TFun: λ&args. λ&ret.
      !!&vn1 = var_name;  // Clone for args
      !!&vn2 = var_name;  // Clone for ret
      !!&in_args = @occurs_in_list(vn1)(args);
      λ{
        #True: #True{}
        _: @occurs_check(vn2)(ret)
      }(in_args)

    #TFunE: λ&args. λ&ret. λ&eff_unused.
      !!&vn1 = var_name;  // Clone for args
      !!&vn2 = var_name;  // Clone for ret
      !!&in_args = @occurs_in_list(vn1)(args);
      λ{
        #True: #True{}
        _: @occurs_check(vn2)(ret)
      }(in_args)

    #TSup: λ&elem.
      !!&vn = var_name;
      @occurs_check(vn)(elem)

    #TWSup: λ&elem.
      !!&vn = var_name;
      @occurs_check(vn)(elem)

    _: #Fals{}
  }(type)

// Check if type variable occurs in any type in list
@occurs_in_list = λ&var_name. λ&types.
  λ{
    #NIL: #Fals{}
    #CON: λ&h. λ&t.
      !!&vn1 = var_name;  // Clone for head
      !!&vn2 = var_name;  // Clone for tail recursion
      !!&in_head = @occurs_check(vn1)(h);
      λ{
        #True: #True{}
        _: @occurs_in_list(vn2)(t)
      }(in_head)
  }(types)

// Unify two lists of types pairwise
@unify_lists = λ&subst. λ&types_a. λ&types_b.
  λ{
    #NIL:
      λ{
        #NIL: #USuc{subst}
        _: #UFal{#sym_ArityMismatch}
      }(types_b)
    #CON: λ&ha. λ&ta.
      λ{
        #NIL: #UFal{#sym_ArityMismatch}
        #CON: λ&hb. λ&tb.
          !!&head_result = @unify_with_subst(subst)(ha)(hb);
          λ{
            #USuc: λ&subst2.
              @unify_lists(subst2)(ta)(tb)
            _: head_result
          }(head_result)
      }(types_b)
  }(types_a)

// Unify effect rows (for now, simple equality)
@unify_effects = λ&subst. λ&eff_a. λ&eff_b.
  λ{
    #NIL:
      λ{
        #NIL: #USuc{subst}
        _: #UFal{#sym_EffectMismatch}
      }(eff_b)
    #ERws: λ&effs_a.
      λ{
        #ERws: λ&effs_b.
          // For now, require exact effect match
          // TODO: effect row polymorphism
          @unify_effect_lists(subst)(effs_a)(effs_b)
        _: #UFal{#sym_EffectMismatch}
      }(eff_b)
    _:
      λ{
        #NIL: #UFal{#sym_EffectMismatch}
        _: #USuc{subst}  // Both unknown - accept
      }(eff_b)
  }(eff_a)

// Unify effect lists (simple equality for now)
@unify_effect_lists = λ&subst. λ&effs_a. λ&effs_b.
  λ{
    #NIL:
      λ{
        #NIL: #USuc{subst}
        _: #UFal{#sym_EffectMismatch}
      }(effs_b)
    #CON: λ&ha. λ&ta.
      λ{
        #NIL: #UFal{#sym_EffectMismatch}
        #CON: λ&hb. λ&tb.
          λ{
            1: @unify_effect_lists(subst)(ta)(tb)
            _: #UFal{#sym_EffectMismatch}
          }((ha == hb))
      }(effs_b)
  }(effs_a)

// Apply substitution to a type (like subst_type but for unification)
@apply_subst = λ&subst. λ&type.
  λ{
    #TVar: λ&name.
      @apply_subst_var(subst)(name)(type)

    #TCon: λ&name.
      type  // Type constructors don't have substitutions

    #TApp: λ&base. λ&params.
      #TApp{@apply_subst(subst)(base), @map_apply_subst(subst)(params)}

    #TFun: λ&args. λ&ret.
      #TFun{@map_apply_subst(subst)(args), @apply_subst(subst)(ret)}

    #TFunE: λ&args. λ&ret. λ&eff.
      #TFunE{@map_apply_subst(subst)(args), @apply_subst(subst)(ret), eff}

    #TSup: λ&elem.
      #TSup{@apply_subst(subst)(elem)}

    #TWSup: λ&elem.
      #TWSup{@apply_subst(subst)(elem)}

    _: type
  }(type)

// Look up type variable in substitution, recursively apply
@apply_subst_var = λ&subst. λ&name. λ&original.
  λ{
    #NIL: original  // Not found
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&var. λ&rest.
          λ{
            #CON: λ&bound_type. λ&u_.
              λ{
                #TVar: λ&var_name.
                  λ{
                    1:
                      // Found binding - apply subst to bound type too
                      @apply_subst(subst)(bound_type)
                    _: @apply_subst_var(t)(name)(original)
                  }((var_name == name))
                _: @apply_subst_var(t)(name)(original)
              }(var)
          }(rest)
      }(h)
  }(subst)

// Map apply_subst over list
@map_apply_subst = λ&subst. λ&types.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{@apply_subst(subst)(h), @map_apply_subst(subst)(t)}
  }(types)

// =============================================================================
// Constraint Generation
// =============================================================================

// Constraint: #TCon{expected, actual, location}
// - expected: expected type
// - actual: inferred type
// - location: source location for error reporting

@make_constraint = λ&expected. λ&actual. λ&loc.
  #TCon{expected, actual, loc}

// Generate constraints from expression and expected type
// Returns #CON{constraints, inferred_type}
@generate_constraints = λ&expr. λ&expected. λ&env.
  λ{
    // Integer literal
    #Cst: λ&n_unused.
      #CON{#CON{@make_constraint(expected)(@type_Int)(expr), #NIL}, @type_Int}

    // Symbol reference - look up in environment
    #Sym: λ&s.
      !!&type = @env_lookup_type(env)(s);
      #CON{#CON{@make_constraint(expected)(type)(expr), #NIL}, type}

    // Lambda expression
    #Lam: λ&var. λ&body.
      // Create fresh type variable for parameter
      !!&param_type = #TVar{var};
      // Extend environment
      !!&env2 = @env_extend(env)(var)(param_type);
      // Generate constraints for body with fresh return type
      !!&ret_type = @fresh_type_var();
      !!&body_result = @generate_constraints(body)(ret_type)(env2);
      λ{
        #CON: λ&body_cons. λ&rest.
          λ{
            #CON: λ&actual_ret. λ&u1_.
              !!&fn_type = #TFun{#CON{param_type, #NIL}, actual_ret};
              !!&cons = #CON{@make_constraint(expected)(fn_type)(expr), body_cons};
              #CON{cons, fn_type}
          }(rest)
      }(body_result)

    // Application
    #App: λ&func. λ&arg.
      // Generate fresh type variable for result
      !!&result_type = @fresh_type_var();
      // Generate constraints for function (expect it to be a function)
      !!&arg_type = @fresh_type_var();
      !!&fn_type = #TFun{#CON{arg_type, #NIL}, result_type};
      !!&func_result = @generate_constraints(func)(fn_type)(env);
      !!&arg_result = @generate_constraints(arg)(arg_type)(env);
      λ{
        #CON: λ&func_cons. λ&u2_.
          λ{
            #CON: λ&arg_cons. λ&u3_.
              !!&all_cons = @append(func_cons)(arg_cons);
              !!&all_cons2 = #CON{@make_constraint(expected)(result_type)(expr), all_cons};
              #CON{all_cons2, result_type}
          }(arg_result)
      }(func_result)

    // Let binding
    #Let: λ&var. λ&val. λ&body.
      !!&val_type = @fresh_type_var();
      !!&val_result = @generate_constraints(val)(val_type)(env);
      λ{
        #CON: λ&val_cons. λ&rest.
          λ{
            #CON: λ&actual_val_type. λ&u4_.
              !!&env2 = @env_extend(env)(var)(actual_val_type);
              !!&body_result = @generate_constraints(body)(expected)(env2);
              λ{
                #CON: λ&body_cons. λ&rest2.
                  λ{
                    #CON: λ&actual_body_type. λ&u5_.
                      !!&all_cons = @append(val_cons)(body_cons);
                      #CON{all_cons, actual_body_type}
                  }(rest2)
              }(body_result)
          }(rest)
      }(val_result)

    // Default - return Any type
    _:
      #CON{#CON{@make_constraint(expected)(@type_Any)(expr), #NIL}, @type_Any}
  }(expr)

// =============================================================================
// Constraint Solving
// =============================================================================

// Solve constraints by unifying each pair
// Returns #USuc{final_subst} or #UFal{reason}
@solve_constraints = λconstraints.
  @solve_constraints_with_subst(#NIL)(constraints)

@solve_constraints_with_subst = λ&subst. λ&constraints.
  λ{
    #NIL: #USuc{subst}
    #CON: λ&con. λ&rest.
      λ{
        #TCon: λ&expected. λ&actual. λ&loc_unused.
          !!&result = @unify_with_subst(subst)(expected)(actual);
          λ{
            #USuc: λ&new_subst.
              @solve_constraints_with_subst(new_subst)(rest)
            _: result
          }(result)
      }(con)
  }(constraints)

// =============================================================================
// Type Inference
// =============================================================================

// Infer type of expression
// Returns #TRes{type, subst} or #TErr{reason}
@infer_type_expr = λ&expr. λ&env.
  !!&expected = @fresh_type_var();
  !!&gen_result = @generate_constraints(expr)(expected)(env);
  λ{
    #CON: λ&constraints. λ&rest.
      λ{
        #CON: λ&inferred. λ&u6_.
          !!&solve_result = @solve_constraints(constraints);
          λ{
            #USuc: λ&subst.
              !!&final_type = @apply_subst(subst)(inferred);
              #TRes{final_type, subst}
            #UFal: λ&reason.
              #TErr{reason}
          }(solve_result)
      }(rest)
  }(gen_result)

// =============================================================================
// Type Environment
// =============================================================================

// Environment: list of #CON{name, type}
@empty_type_env = #NIL

@env_extend = λenv. λname. λtype.
  #CON{#CON{name, type}, env}

@env_lookup_type = λ&env. λ&name.
  λ{
    #NIL: @type_Any  // Not found - default to Any
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&n. λ&ty.
          λ{
            1: ty
            _: @env_lookup_type(t)(name)
          }((n == name))
      }(h)
  }(env)

// =============================================================================
// Fresh Type Variable Generation
// =============================================================================

// Counter for generating fresh type variables
// In a real implementation, this would use a mutable ref or threading
// For now, use a simple deterministic scheme based on expression hash
@fresh_type_var_counter = 0

@fresh_type_var =
  // Generate a unique type variable name
  // This is a placeholder - real implementation needs threading or mutation
  #TVar{#sym_T}

// Append two lists
@append = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @append(t)(ys)}
  }(xs)

// =============================================================================
// Kind-Checked Type Unification
// =============================================================================

// Unify with kind checking enabled
// Returns #USuc{subst} or #UFal{reason}
@unify_with_kinds = λ&type_a. λ&type_b.
  @unify_with_kinds_subst(#NIL)(type_a)(type_b)

// Unify with existing substitution and kind checking
@unify_with_kinds_subst = λ&subst. λ&type_a. λ&type_b.
  // First check that kinds are compatible
  !!&kind_a = @infer_kind(type_a);
  !!&kind_b = @infer_kind(type_b);
  !!&kinds_ok = @kinds_equal(kind_a)(kind_b);
  λ{
    #True: @unify_core_with_kinds(subst)(type_a)(type_b)
    #Fals: #UFal{#KMis{kind_a, kind_b}}
  }(kinds_ok)

// Core kind-checked unification
@unify_core_with_kinds = λ&subst. λ&type_a. λ&type_b.
  !!&s = subst;
  !!&ta = type_a;
  !!&tb = type_b;
  @unify_dispatch_with_kinds(s)(ta)(tb)

// Dispatch based on type_a with kind checking
@unify_dispatch_with_kinds = λ&s. λ&ta. λ&tb.
  λ{
    // Type variable on left
    #TVar: λ&name_a.
      @unify_tvar_left_with_kinds(s)(name_a)(ta)(tb)

    // Type constructor variable on left (kind-aware)
    #TConVar: λ&name_a. λ&kind_a.
      @unify_tconvar_left(s)(name_a)(kind_a)(ta)(tb)

    // Type constructor on left
    #TCon: λ&name_a.
      @unify_tcon_left_with_kinds(s)(name_a)(ta)(tb)

    // Type application on left
    #TApp: λ&base_a. λ&params_a.
      @unify_tapp_left(s)(base_a)(params_a)(ta)(tb)

    // Function type on left
    #TFun: λ&args_a. λ&ret_a.
      @unify_tfun_left(s)(args_a)(ret_a)(ta)(tb)

    // Function type with effects on left
    #TFunE: λ&args_a. λ&ret_a. λ&eff_a.
      @unify_tfune_left(s)(args_a)(ret_a)(eff_a)(ta)(tb)

    // Default: check equality
    _: @unify_default_with_kinds(s)(ta)(tb)
  }(ta)

// Handle #TVar on left side with kind checking
@unify_tvar_left_with_kinds = λ&s. λ&name_a. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      (λ&same.
        λ{
          1: #USuc{s}
          0: #USuc{#CON{#CON{#TVar{name_a}, #CON{#TVar{name_b}, #NIL}}, s}}
        }(same)
      )((name_a == name_b))

    #TConVar: λ&name_b. λ&kind_b.
      // TVar has kind *, so TConVar must also have kind *
      λ{
        #True: @bind_var(s)(name_a)(tb)
        #Fals: #UFal{#KMis{@kind_star, kind_b}}
      }(@kinds_equal(@kind_star)(kind_b))

    _: @bind_var(s)(name_a)(tb)
  }(tb)

// Handle #TConVar on left side
@unify_tconvar_left = λ&s. λ&name_a. λ&kind_a. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      // TVar has kind *, so kind_a must be *
      λ{
        #True: @bind_var(s)(name_b)(ta)
        #Fals: #UFal{#KMis{kind_a, @kind_star}}
      }(@kinds_equal(kind_a)(@kind_star))

    #TConVar: λ&name_b. λ&kind_b.
      // Both are TConVar - check kinds match
      λ{
        #True:
          (λ&same.
            λ{
              1: #USuc{s}
              0: @bind_tcon_var(s)(name_a)(kind_a)(tb)
            }(same)
          )((name_a == name_b))
        #Fals: #UFal{#KMis{kind_a, kind_b}}
      }(@kinds_equal(kind_a)(kind_b))

    #TCon: λ&name_b.
      // Check that TCon's kind matches kind_a
      !!&tcon_kind = @infer_tcon_kind(name_b);
      λ{
        #True: @bind_tcon_var(s)(name_a)(kind_a)(tb)
        #Fals: #UFal{#KMis{kind_a, tcon_kind}}
      }(@kinds_equal(kind_a)(tcon_kind))

    _: @bind_tcon_var(s)(name_a)(kind_a)(tb)
  }(tb)

// Handle #TCon on left side with kind checking
@unify_tcon_left_with_kinds = λ&s. λ&name_a. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)

    #TConVar: λ&name_b. λ&kind_b.
      !!&tcon_kind = @infer_tcon_kind(name_a);
      λ{
        #True: @bind_tcon_var(s)(name_b)(kind_b)(ta)
        #Fals: #UFal{#KMis{tcon_kind, kind_b}}
      }(@kinds_equal(tcon_kind)(kind_b))

    #TCon: λ&name_b.
      (λ&same.
        λ{
          1: #USuc{s}
          0: #UFal{#sym_TypeMismatch}
        }(same)
      )((name_a == name_b))

    _: #UFal{#sym_TypeMismatch}
  }(tb)

// Handle #TApp on left side
@unify_tapp_left = λ&s. λ&base_a. λ&params_a. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)

    #TApp: λ&base_b. λ&params_b.
      // Unify bases first, then unify params
      !!&base_result = @unify_with_kinds_subst(s)(base_a)(base_b);
      λ{
        #USuc: λ&subst2.
          @unify_lists_with_kinds(subst2)(params_a)(params_b)
        _: base_result
      }(base_result)

    _: #UFal{#sym_TypeMismatch}
  }(tb)

// Handle #TFun on left side
@unify_tfun_left = λ&s. λ&args_a. λ&ret_a. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)

    #TFun: λ&args_b. λ&ret_b.
      !!&args_result = @unify_lists_with_kinds(s)(args_a)(args_b);
      λ{
        #USuc: λ&subst2.
          @unify_with_kinds_subst(subst2)(ret_a)(ret_b)
        _: args_result
      }(args_result)

    #TFunE: λ&args_b. λ&ret_b. λ&eff_b.
      // TFun can unify with TFunE if effects are unknown
      !!&args_result = @unify_lists_with_kinds(s)(args_a)(args_b);
      λ{
        #USuc: λ&subst2.
          @unify_with_kinds_subst(subst2)(ret_a)(ret_b)
        _: args_result
      }(args_result)

    _: #UFal{#sym_TypeMismatch}
  }(tb)

// Handle #TFunE on left side
@unify_tfune_left = λ&s. λ&args_a. λ&ret_a. λ&eff_a. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)

    #TFun: λ&args_b. λ&ret_b.
      !!&args_result = @unify_lists_with_kinds(s)(args_a)(args_b);
      λ{
        #USuc: λ&subst2.
          @unify_with_kinds_subst(subst2)(ret_a)(ret_b)
        _: args_result
      }(args_result)

    #TFunE: λ&args_b. λ&ret_b. λ&eff_b.
      !!&args_result = @unify_lists_with_kinds(s)(args_a)(args_b);
      λ{
        #USuc: λ&subst2.
          !!&ret_result = @unify_with_kinds_subst(subst2)(ret_a)(ret_b);
          λ{
            #USuc: λ&subst3.
              @unify_effects(subst3)(eff_a)(eff_b)
            _: ret_result
          }(ret_result)
        _: args_result
      }(args_result)

    _: #UFal{#sym_TypeMismatch}
  }(tb)

// Default handler with kind checking
@unify_default_with_kinds = λ&s. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)

    #TConVar: λ&name_b. λ&kind_b.
      !!&kind_a = @infer_kind(ta);
      λ{
        #True: @bind_tcon_var(s)(name_b)(kind_b)(ta)
        #Fals: #UFal{#KMis{kind_a, kind_b}}
      }(@kinds_equal(kind_a)(kind_b))

    _:
      (λ&same.
        λ{
          1: #USuc{s}
          0: #UFal{#sym_TypeMismatch}
        }(same)
      )((ta == tb))
  }(tb)

// Unify two lists with kind checking
@unify_lists_with_kinds = λ&subst. λ&types_a. λ&types_b.
  λ{
    #NIL:
      λ{
        #NIL: #USuc{subst}
        _: #UFal{#sym_ArityMismatch}
      }(types_b)
    #CON: λ&ha. λ&ta.
      λ{
        #NIL: #UFal{#sym_ArityMismatch}
        #CON: λ&hb. λ&tb.
          !!&head_result = @unify_with_kinds_subst(subst)(ha)(hb);
          λ{
            #USuc: λ&subst2.
              @unify_lists_with_kinds(subst2)(ta)(tb)
            _: head_result
          }(head_result)
      }(types_b)
  }(types_a)

// Bind type constructor variable to a type with kind and occurs check
@bind_tcon_var = λ&subst. λ&var_name. λ&var_kind. λ&type.
  // Check kind of type matches var_kind
  !!&type_kind = @infer_kind(type);
  λ{
    #True:
      // Kinds match, perform occurs check
      λ{
        #True: #UFal{#sym_OccursCheck}
        #Fals: #USuc{#CON{#CON{#TConVar{var_name, var_kind}, #CON{type, #NIL}}, subst}}
      }(@occurs_check_tcon(var_name)(type))
    #Fals: #UFal{#KMis{var_kind, type_kind}}
  }(@kinds_equal(var_kind)(type_kind))

// Occurs check for type constructor variables
@occurs_check_tcon = λ&var_name. λ&type.
  λ{
    #TConVar: λ&name. λ&kind.
      !!&vn = var_name;
      (λ&same. λ{ 1: #True{} 0: #Fals{} }(same))((vn == name))

    #TCon: λ&name.
      #Fals{}

    #TVar: λ&name.
      #Fals{}

    #TApp: λ&base. λ&params.
      !!&vn1 = var_name;
      !!&vn2 = var_name;
      !!&in_base = @occurs_check_tcon(vn1)(base);
      λ{
        #True: #True{}
        _: @occurs_in_list_tcon(vn2)(params)
      }(in_base)

    #TFun: λ&args. λ&ret.
      !!&vn1 = var_name;
      !!&vn2 = var_name;
      !!&in_args = @occurs_in_list_tcon(vn1)(args);
      λ{
        #True: #True{}
        _: @occurs_check_tcon(vn2)(ret)
      }(in_args)

    #TFunE: λ&args. λ&ret. λ&eff_unused.
      !!&vn1 = var_name;
      !!&vn2 = var_name;
      !!&in_args = @occurs_in_list_tcon(vn1)(args);
      λ{
        #True: #True{}
        _: @occurs_check_tcon(vn2)(ret)
      }(in_args)

    _: #Fals{}
  }(type)

// Check if type constructor variable occurs in any type in list
@occurs_in_list_tcon = λ&var_name. λ&types.
  λ{
    #NIL: #Fals{}
    #CON: λ&h. λ&t.
      !!&vn1 = var_name;
      !!&vn2 = var_name;
      !!&in_head = @occurs_check_tcon(vn1)(h);
      λ{
        #True: #True{}
        _: @occurs_in_list_tcon(vn2)(t)
      }(in_head)
  }(types)

// =============================================================================
// Kind-Checked Constraint Solving
// =============================================================================

// Solve constraints with kind checking
@solve_constraints_with_kinds = λconstraints.
  @solve_constraints_with_kinds_subst(#NIL)(constraints)

@solve_constraints_with_kinds_subst = λ&subst. λ&constraints.
  λ{
    #NIL: #USuc{subst}
    #CON: λ&con. λ&rest.
      λ{
        #TCon: λ&expected. λ&actual. λ&loc_unused.
          !!&result = @unify_with_kinds_subst(subst)(expected)(actual);
          λ{
            #USuc: λ&new_subst.
              @solve_constraints_with_kinds_subst(new_subst)(rest)
            _: result
          }(result)
      }(con)
  }(constraints)

// =============================================================================
// Kind-Checked Type Inference
// =============================================================================

// Infer type of expression with kind checking
@infer_type_expr_with_kinds = λ&expr. λ&env.
  !!&expected = @fresh_type_var();
  !!&gen_result = @generate_constraints(expr)(expected)(env);
  λ{
    #CON: λ&constraints. λ&rest.
      λ{
        #CON: λ&inferred. λ&u6_.
          !!&solve_result = @solve_constraints_with_kinds(constraints);
          λ{
            #USuc: λ&subst.
              !!&final_type = @apply_subst(subst)(inferred);
              // Verify final type has valid kind
              !!&final_kind = @infer_kind(final_type);
              #TRes{final_type, subst, final_kind}
            #UFal: λ&reason.
              #TErr{reason}
          }(solve_result)
      }(rest)
  }(gen_result)

// =============================================================================
// Kind Error Helpers
// =============================================================================

// Check if unification result is a kind error
@is_kind_error = λ&result.
  λ{
    #UFal: λ&reason.
      λ{
        #KMis: λ&k1. λ&k2. #True{}
        _: #Fals{}
      }(reason)
    _: #Fals{}
  }(result)

// Extract kind mismatch info from error
@get_kind_error_info = λ&result.
  λ{
    #UFal: λ&reason.
      λ{
        #KMis: λ&expected. λ&actual.
          #CON{expected, #CON{actual, #NIL}}
        _: #NIL
      }(reason)
    _: #NIL
  }(result)

// =============================================================================
// Phase 3.1: Effect Row Types
// =============================================================================
//
// Effect rows track which effects a computation may perform.
// They extend the type system to statically verify effect handling.
//
// Representation:
//   #ERow{effects, rest}
//     effects: sorted list of effect names (nick-encoded)
//     rest: #ENil (closed/pure) or #EVar{id} (open/polymorphic)
//
// Examples:
//   #ERow{#NIL, #ENil}                     = {} (pure)
//   #ERow{#CON{ask, #NIL}, #ENil}          = {Ask}
//   #ERow{#CON{ask, #CON{log, #NIL}}, #ENil} = {Ask, Log}
//   #ERow{#CON{io, #NIL}, #EVar{42}}       = {IO | ε₄₂}

// --- Construction ---

// Empty effect row (pure computation)
@effect_row_empty = #ERow{#NIL, #ENil}

// Single effect row
@effect_row_single = λ&name. #ERow{#CON{name, #NIL}, #ENil}

// Open effect row with variable (for polymorphism)
@effect_row_open = λ&name. λ&var_id. #ERow{#CON{name, #NIL}, #EVar{var_id}}

// --- Predicates ---

// Check if effect row is pure (no effects)
@effect_row_is_pure = λ&row.
  λ{
    #ERow: λ&effs. λ&rest.
      λ{
        #NIL:
          λ{
            #ENil: 1
            _: λ&u_. 0  // Has variable tail, not proven pure
          }(rest)
        _: λ&u_. 0  // Has effects
      }(effs)
    _: λ&u_. 0
  }(row)

// Check if effect row contains a specific effect
@effect_row_contains = λ&row. λ&effect_name.
  λ{
    #ERow: λ&effs. λ&rest.
      @effect_list_contains(effs)(effect_name)
    _: λ&u_. 0
  }(row)

// Check if an effect is in a list
@effect_list_contains = λ&lst. λ&name.
  λ{
    #NIL: 0
    #CON: λ&h. λ&t.
      !!&eq = (h == name);
      λ{
        1: 1
        _: λ&u_. @effect_list_contains(t)(name)
      }(eq)
  }(lst)

// --- Operations ---

// Union of two effect rows: merge effect lists, combine tails
@effect_row_union = λ&e1. λ&e2.
  λ{
    #ERow: λ&effs1. λ&rest1.
      λ{
        #ERow: λ&effs2. λ&rest2.
          !!&merged = @effect_list_merge(effs1)(effs2);
          !!&tail   = @effect_rest_merge(rest1)(rest2);
          #ERow{merged, tail}
        _: λ&u_. e1
      }(e2)
    _: λ&u_. e2
  }(e1)

// Merge two sorted effect lists (union, no duplicates)
@effect_list_merge = λ&l1. λ&l2.
  λ{
    #NIL: l2
    #CON: λ&h1. λ&t1.
      @effect_list_insert(h1)(@effect_list_merge(t1)(l2))
  }(l1)

// Insert an effect name into a sorted list (no duplicates)
@effect_list_insert = λ&name. λ&lst.
  λ{
    #NIL: #CON{name, #NIL}
    #CON: λ&h. λ&t.
      !!&eq  = (name == h);
      !!&lt_ = (name < h);
      λ{
        1: lst  // Already present
        _: λ&u_.
          λ{
            1: #CON{name, lst}  // Insert before
            _: λ&u_. #CON{h, @effect_list_insert(name)(t)}  // Continue
          }(lt_)
      }(eq)
  }(lst)

// Merge effect row tails
@effect_rest_merge = λ&r1. λ&r2.
  λ{
    #ENil: r2
    #EVar: λ&id1.
      λ{
        #ENil: r1
        #EVar: λ&id2.
          !!&same = (id1 == id2);
          λ{
            1: r1  // Same variable
            _: λ&u_. r1  // Keep first (unification resolves later)
          }(same)
        _: λ&u_. r1
      }(r2)
    _: λ&u_. r1
  }(r1)

// Remove a specific effect from a row
@effect_row_remove = λ&row. λ&effect_name.
  λ{
    #ERow: λ&effs. λ&rest.
      #ERow{@effect_list_remove(effs)(effect_name), rest}
    _: λ&u_. row
  }(row)

// Remove an element from a sorted list
@effect_list_remove = λ&lst. λ&name.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      !!&eq = (h == name);
      λ{
        1: t  // Found, remove it (skip rest since sorted, no dups)
        _: λ&u_. #CON{h, @effect_list_remove(t)(name)}
      }(eq)
  }(lst)

// Remove all effects covered by a handler list from an effect row
// handlers is a list of #Hdlr{tag, fn} or #HDef{tag, fn_expr}
@effect_row_remove_handled = λ&row. λ&handlers.
  λ{
    #NIL: row
    #CON: λ&h. λ&t.
      !!&tag = @handler_get_tag(h);
      @effect_row_remove_handled(@effect_row_remove(row)(tag))(t)
  }(handlers)

// Extract tag from handler definition
@handler_get_tag = λ&handler.
  λ{
    #HDef: λ&tag. λ&fn. tag
    #Hdlr: λ&tag. λ&fn. tag
    _: λ&u_. 0
  }(handler)

// --- Subset check ---

// Check if all effects in row1 are handled by row2
// Returns 1 if row1 ⊆ row2
@effect_row_subset = λ&row1. λ&row2.
  λ{
    #ERow: λ&effs1. λ&rest1.
      λ{
        #ERow: λ&effs2. λ&rest2.
          @effect_list_subset(effs1)(effs2)
        _: λ&u_. 0
      }(row2)
    _: λ&u_. 1  // Non-row is trivially subset
  }(row1)

@effect_list_subset = λ&l1. λ&l2.
  λ{
    #NIL: 1  // Empty is subset of anything
    #CON: λ&h. λ&t.
      !!&found = @effect_list_contains(l2)(h);
      λ{
        1: @effect_list_subset(t)(l2)
        _: λ&u_. 0  // Not found in l2
      }(found)
  }(l1)

// --- Unification ---

// Unify two effect rows during type checking
// Returns #UOk{substitution} or #UFal{reason}
@effect_row_unify = λ&e1. λ&e2. λ&subst.
  λ{
    #ERow: λ&effs1. λ&rest1.
      λ{
        #ERow: λ&effs2. λ&rest2.
          // First check if effect lists match
          !!&lists_eq = @effect_list_eq(effs1)(effs2);
          λ{
            1: // Lists match, unify tails
              @effect_rest_unify(rest1)(rest2)(subst)
            _: λ&u_.
              // Lists differ — try to unify via row variable
              @effect_row_unify_diff(effs1)(rest1)(effs2)(rest2)(subst)
          }(lists_eq)
        _: λ&u_. #UFal{#EfMismatch}
      }(e2)
    _: λ&u_.
      // e1 is not an ERow — could be an effect variable
      #UFal{#EfMismatch}
  }(e1)

// Unify effect row tails
@effect_rest_unify = λ&r1. λ&r2. λ&subst.
  λ{
    #ENil:
      λ{
        #ENil: #UOk{subst}
        #EVar: λ&id. #UOk{@subst_add(subst)(id)(#ERow{#NIL, #ENil})}
        _: λ&u_. #UFal{#EfTailMismatch}
      }(r2)
    #EVar: λ&id1.
      λ{
        #ENil: #UOk{@subst_add(subst)(id1)(#ERow{#NIL, #ENil})}
        #EVar: λ&id2.
          !!&same = (id1 == id2);
          λ{
            1: #UOk{subst}  // Same variable
            _: λ&u_. #UOk{@subst_add(subst)(id1)(#ERow{#NIL, r2})}
          }(same)
        _: λ&u_. #UFal{#EfTailMismatch}
      }(r2)
    _: λ&u_. #UFal{#EfTailMismatch}
  }(r1)

// Unify when effect lists differ — one side may have a variable tail
@effect_row_unify_diff = λ&effs1. λ&rest1. λ&effs2. λ&rest2. λ&subst.
  λ{
    #EVar: λ&id1.
      // rest1 is variable — it absorbs the difference
      !!&diff = @effect_list_diff(effs2)(effs1);
      #UOk{@subst_add(subst)(id1)(#ERow{diff, rest2})}
    _: λ&u_.
      λ{
        #EVar: λ&id2.
          // rest2 is variable — it absorbs the difference
          !!&diff = @effect_list_diff(effs1)(effs2);
          #UOk{@subst_add(subst)(id2)(#ERow{diff, rest1})}
        _: λ&u_. #UFal{#EfMismatch}
      }(rest2)
  }(rest1)

// List equality check
@effect_list_eq = λ&l1. λ&l2.
  λ{
    #NIL:
      λ{
        #NIL: 1
        _: λ&u_. 0
      }(l2)
    #CON: λ&h1. λ&t1.
      λ{
        #CON: λ&h2. λ&t2.
          !!&eq = (h1 == h2);
          λ{
            1: @effect_list_eq(t1)(t2)
            _: λ&u_. 0
          }(eq)
        _: λ&u_. 0
      }(l2)
  }(l1)

// List difference: elements in l1 not in l2
@effect_list_diff = λ&l1. λ&l2.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      !!&found = @effect_list_contains(l2)(h);
      λ{
        1: @effect_list_diff(t)(l2)  // Skip — in l2
        _: λ&u_. #CON{h, @effect_list_diff(t)(l2)}  // Keep — not in l2
      }(found)
  }(l1)

// --- Inference ---

// Infer the effect row of an expression
// Returns #ERow{effects, rest}
@effect_infer = λ&menv. λ&exp.
  λ{
    #Lit:  λ&n. @effect_row_empty
    #Cst:  λ&n. @effect_row_empty
    #Var:  λ&i. @effect_row_empty
    #Sym:  λ&s. @effect_row_empty
    #Lam:  λ&body. @effect_row_empty  // Effects are in the function type
    #LamR: λ&body. @effect_row_empty

    #App: λ&fn. λ&arg.
      @effect_row_union(@effect_infer(menv)(fn))(@effect_infer(menv)(arg))

    #Perf: λ&tag. λ&payload.
      // Perform adds the named effect
      !!&tag_name = @effect_resolve_tag(menv)(tag);
      @effect_row_union(@effect_row_single(tag_name))(@effect_infer(menv)(payload))

    #Hdle: λ&handlers. λ&body.
      // Handle removes effects covered by its handlers
      @effect_row_remove_handled(@effect_infer(menv)(body))(handlers)

    #Do: λ&first. λ&rest.
      @effect_row_union(@effect_infer(menv)(first))(@effect_infer(menv)(rest))

    #If: λ&cond. λ&then. λ&else_.
      @effect_row_union(@effect_infer(menv)(cond))(
        @effect_row_union(@effect_infer(menv)(then))(@effect_infer(menv)(else_)))

    #Let: λ&val. λ&body.
      @effect_row_union(@effect_infer(menv)(val))(@effect_infer(menv)(body))

    _: λ&u_. @effect_row_empty  // Unknown forms are pure by default
  }(exp)

// Resolve effect tag to its name
// Tags in perform are usually #Sym{nick} or #Cod{#Sym{nick}}
@effect_resolve_tag = λ&menv. λ&tag.
  λ{
    #Sym: λ&n. n
    #Cod: λ&inner. @effect_resolve_tag(menv)(inner)
    #Lit: λ&n. n
    #Cst: λ&n. n
    _: λ&u_. 0  // Unknown tag
  }(tag)
