// OmniLisp Type System Library
// Type descriptors, multiple dispatch, and runtime type checking

// =============================================================================
// Type Descriptors
// =============================================================================

// Type descriptor format: #TDsc{name, parent, fields}
// - name: nick-encoded type name
// - parent: parent type descriptor (or #NIL for root types)
// - fields: list of field descriptors

// Built-in type descriptors
// Using nick-encoded numeric values instead of #sym_X to ensure NUM terms (not C00 constructors)
// HVM4 nick encoding: _ = 0, a-z = 1-26, A-Z = 27-52, 0-9 = 53-62, $ = 63
@type_Any      = #TDsc{111513, #NIL, #NIL}              // nick("Any")
@type_Nothing  = #TDsc{2134919, @type_Any, #NIL}        // nick("Nothing")
@type_Int      = #TDsc{144276, @type_Any, #NIL}         // nick("Int")
@type_Float    = #TDsc{3207252, @type_Any, #NIL}        // nick("Float")
@type_Bool     = #TDsc{7402444, @type_Any, #NIL}        // nick("Bool")
@type_Char     = #TDsc{7635026, @type_Any, #NIL}        // nick("Char")
@type_Symbol   = #TDsc{3417036, @type_Any, #NIL}        // nick("Symbol")
@type_String   = #TDsc{11879561, @type_Any, #NIL}       // nick("Stri") - parser truncates to 4 chars
@type_List     = #TDsc{9999572, @type_Any, #NIL}        // nick("List")
@type_Function = #TDsc{5280718, @type_Any, #NIL}        // nick("Function")
@type_Handle   = #TDsc{3687173, @type_Any, #NIL}        // nick("Handle")

// =============================================================================
// Type Hierarchy
// =============================================================================

// Check if type A is subtype of type B
@subtype_check = λ&type_a. λ&type_b.
  λ{
    #TDsc: λ&name_a. λ&parent_a. λ&fields_a_unused.
      λ{
        #TDsc: λ&name_b. λ&parent_b_unused. λ&fields_b_unused.
          // Same type?
          λ{
            1: #True{}
            _:
              // Check parent
              λ{
                #NIL: #Fals{}
                _: @subtype_check(parent_a)(type_b)
              }(parent_a)
          }((name_a == name_b))
      }(type_b)
  }(type_a)

// Get type name from descriptor
@type_name = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields. name
    _: #sym_Unknown
  }(type)

// Get parent type
@type_parent = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields. parent
    _: #NIL
  }(type)

// Get type fields
@type_fields = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields. fields
    _: #NIL
  }(type)

// =============================================================================
// Runtime Type Inference
// =============================================================================

// Infer the type descriptor from a runtime value
@infer_type = λval.
  λ{
    #Cst: λ&n. @type_Int
    #Fix: λ&hi. λ&lo. λ&scale. @type_Float
    #CHR: λ&c. @type_Char
    #Sym: λ&s. @type_Symbol
    #CON: λ&h. λ&t. @type_List
    #NIL: @type_List
    #Clo: λ&e. λ&b. @type_Function
    #CloR: λ&e. λ&b. @type_Function
    #Hndl: λ&idx. λ&gen. @type_Handle
    #True: @type_Bool
    #Fals: @type_Bool
    #Noth: @type_Nothing
    _: @type_Any
  }(val)

// Check if value has given type
@has_type_check = λval. λtype.
  !!&inferred = @infer_type(val);
  @subtype_check(inferred)(type)

// =============================================================================
// Multiple Dispatch
// =============================================================================

// Method table: list of #Meth{name, sig, impl}
// - name: method name (symbol)
// - sig: list of parameter types
// - impl: implementation function

// Global method registry (would be populated by define-method)
// For now, this is a stub that would be extended at runtime

// Find most specific method for given types
@dispatch_find = λ&name. λ&arg_types. λ&methods.
  λ{
    #NIL: #Noth{}  // No matching method
    #CON: λ&meth. λ&rest.
      λ{
        #Meth: λ&mname. λ&msig. λ&mimpl_unused.
          λ{
            1:
              // Check if signature matches
              !!&matches = @sig_matches_check(arg_types)(msig);
              λ{
                #True:
                  // Found a match - check if it's more specific than rest
                  !!&rest_match = @dispatch_find(name)(arg_types)(rest);
                  λ{
                    #Noth: meth
                    _:
                      // Compare specificity
                      !!&more_specific = @more_specific_check(msig)(λ{#Meth: λ&n_. λ&s. λ&i_. s}(rest_match));
                      λ{
                        #True: meth
                        _: rest_match
                      }(more_specific)
                  }(rest_match)
                _: @dispatch_find(name)(arg_types)(rest)
              }(matches)
            _: @dispatch_find(name)(arg_types)(rest)
          }((mname == name))
      }(meth)
  }(methods)

// Check if argument types match signature
@sig_matches_check = λ&arg_types. λ&sig.
  λ{
    #NIL:
      λ{
        #NIL: #True{}
        _: #Fals{}
      }(sig)
    #CON: λ&ah. λ&at.
      λ{
        #NIL: #Fals{}
        #CON: λ&sh. λ&st.
          λ{
            #True: @sig_matches_check(at)(st)
            _: #Fals{}
          }(@subtype_check(ah)(sh))
      }(sig)
  }(arg_types)

// Check if sig_a is more specific than sig_b
@more_specific_check = λ&sig_a. λ&sig_b.
  λ{
    #NIL: #Fals{}  // Empty signature - not more specific
    #CON: λ&ah. λ&at.
      λ{
        #NIL: #Fals{}
        #CON: λ&bh. λ&bt.
          λ{
            #True: #True{}  // ah is subtype of bh - more specific
            _: @more_specific_check(at)(bt)  // Check rest
          }(@subtype_check(ah)(bh))
      }(sig_b)
  }(sig_a)

// Invoke a method by name with arguments
@invoke_method = λ&name. λ&args. λ&methods.
  !!&arg_types = @map(@infer_type)(args);
  !!&meth = @dispatch_find(name)(arg_types)(methods);
  λ{
    #Noth: #Err{#sym_nomethod, name}
    #Meth: λ&mname_unused. λ&msig_unused. λ&impl.
      @apply_args(impl)(args)
  }(meth)

// Apply function to list of arguments
@apply_args = λ&f. λ&args.
  λ{
    #NIL: f
    #CON: λ&h. λ&t. @apply_args(f(h))(t)
  }(args)

// =============================================================================
// Type Constructors
// =============================================================================

// Create a new type descriptor
@make_type = λname. λparent. λfields.
  #TDsc{name, parent, fields}

// Create a method descriptor
@make_method = λname. λsig. λimpl.
  #Meth{name, sig, impl}

// =============================================================================
// Generic Function Helpers
// =============================================================================

// Create a generic function (multi-method dispatcher)
@make_generic = λname.
  λmethods. λargs.
    @invoke_method(name)(args)(methods)

// Add a method to a generic function's method list
@add_method = λmethods. λname. λsig. λimpl.
  #CON{#Meth{name, sig, impl}, methods}

// =============================================================================
// OmniLisp Dispatch Runtime (Compiler Integration)
// =============================================================================

// Global method registry - maps function names to method lists
// In a real implementation, this would be a hash table or ref cell
// For now, methods are stored directly in the #GFun node

// Create a generic function from a method list (compiler entrypoint)
// Returns a callable that dispatches based on argument types
@omni_make_generic = λname. λmethods.
  #GFun{name, methods}

// Main dispatch function (compiler entrypoint)
// Takes a generic function and argument list, finds best method and invokes
@omni_dispatch = λ&gfun. λ&args.
  λ{
    #GFun: λ&name. λ&methods.
      !!&arg_types = @omni_infer_arg_types(args);
      !!&meth = @dispatch_find(name)(arg_types)(methods);
      λ{
        #Noth: #Err{#sym_NoMethod, #CON{name, args}}
        #Meth: λ&mname_u. λ&msig_u. λ&impl.
          @omni_apply_list(impl)(args)
      }(meth)
    _: #Err{#sym_NotGeneric, gfun}
  }(gfun)

// Infer types of arguments (for dispatch)
@omni_infer_arg_types = λ&args.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t. #CON{@infer_type(h), @omni_infer_arg_types(t)}
  }(args)

// Apply function to list of arguments
@omni_apply_list = λ&f. λ&args.
  λ{
    #NIL: f
    #CON: λ&h. λ&t. @omni_apply_list(f(h))(t)
  }(args)

// Convenience: Call a generic function by name (for interpreted dispatch)
@omni_call_generic = λgfun. λarg1.
  @omni_dispatch(gfun)(#CON{arg1, #NIL})

@omni_call_generic2 = λgfun. λarg1. λarg2.
  @omni_dispatch(gfun)(#CON{arg1, #CON{arg2, #NIL}})

@omni_call_generic3 = λgfun. λarg1. λarg2. λarg3.
  @omni_dispatch(gfun)(#CON{arg1, #CON{arg2, #CON{arg3, #NIL}}})

// =============================================================================
// Type Annotations (for compiler)
// =============================================================================

// Type annotation marker (erased at runtime)
// #TAnn{expr, type} - type annotation on expression
// Used by compiler for dispatch optimization

// Extract expression from annotation
@tann_expr = λ&tann.
  λ{
    #TAnn: λ&expr. λ&type_u. expr
    _: tann
  }(tann)

// Extract type from annotation
@tann_type = λ&tann.
  λ{
    #TAnn: λ&expr_u. λ&type. type
    _: @type_Any
  }(tann)

// =============================================================================
// Parameterized Types
// =============================================================================

// Type application: #TApp{base, params}
// e.g., List<Int> = #TApp{@type_List, #CON{@type_Int, #NIL}}

@make_type_app = λbase. λparams.
  #TApp{base, params}

@type_app_base = λ&tapp.
  λ{
    #TApp: λ&base. λ&params_u. base
    _: tapp
  }(tapp)

@type_app_params = λ&tapp.
  λ{
    #TApp: λ&base_u. λ&params. params
    _: #NIL
  }(tapp)

// =============================================================================
// Superposition Types
// =============================================================================

// Superposition type: #TSup{elem_type}
// Represents HVM4's non-deterministic superposition of values
// A value of type {(Sup T)} can be any value of type T simultaneously
// Used for parallel branching and probabilistic programming

@make_sup_type = λelem_type.
  #TSup{elem_type}

@sup_type_elem = λtsup.
  λ{
    #TSup: λ&elem. elem
    _: @type_Any
  }(tsup)

// Check if type is a superposition type
@sup_type_check = λtype.
  λ{
    #TSup: λ&u_. #True{}
    _: #Fals{}
  }(type)

// Weighted superposition type: #TWSup{elem_type}
// Represents superpositions with probability weights
// Used for probabilistic inference with importance sampling

@make_weighted_sup_type = λelem_type.
  #TWSup{elem_type}

@weighted_sup_type_elem = λtsup.
  λ{
    #TWSup: λ&elem. elem
    _: @type_Any
  }(tsup)

// Check if type is a weighted superposition
@weighted_sup_type_check = λtype.
  λ{
    #TWSup: λ&u_. #True{}
    _: #Fals{}
  }(type)

// =============================================================================
// Function Types
// =============================================================================

// Function type: #TFun{arg_types, ret_type}
// For backward compatibility, #TFun without effects = unknown purity
@make_fun_type = λarg_types. λret_type.
  #TFun{arg_types, ret_type}

// Function type with effects: #TFunE{arg_types, ret_type, effects}
// effects is #ERws{effect_list} or #NIL (pure)
@make_fun_type_with_effects = λarg_types. λret_type. λeffects.
  #TFunE{arg_types, ret_type, effects}

// Pure function type (shorthand)
@make_pure_fun_type = λarg_types. λret_type.
  #TFunE{arg_types, ret_type, #NIL}

@fun_type_args = λtfun.
  λ{
    #TFun: λ&args. λ&ret. args
    #TFunE: λ&args. λ&ret. λ&eff. args
    _: #NIL
  }(tfun)

@fun_type_ret = λtfun.
  λ{
    #TFun: λ&args. λ&ret. ret
    #TFunE: λ&args. λ&ret. λ&eff. ret
    _: @type_Any
  }(tfun)

// Get effects from function type (returns #NIL for pure, #ERws{list} for effectful)
@fun_type_effects = λtfun.
  λ{
    #TFunE: λ&args. λ&ret. λ&eff. eff
    #TFun: λ&args. λ&ret. #Noth{}  // Unknown purity
    _: #Noth{}
  }(tfun)

// Check if function type is known pure
@fun_type_pure_check = λtfun.
  λ{
    #TFunE: λ&args. λ&ret. λ&eff.
      λ{
        #NIL: #True{}
        _: #Fals{}
      }(eff)
    #TFun: λ&args. λ&ret. #Fals{}  // Unknown = not provably pure
    _: #Fals{}
  }(tfun)

// =============================================================================
// Type Variables
// =============================================================================

// Type variable: #TVar{name}
// Used for polymorphic types

@make_type_var = λname.
  #TVar{name}

@type_var_name = λtvar.
  λ{
    #TVar: λ&name. name
    _: #sym_Unknown
  }(tvar)

// Check if type is a type variable
@type_var_check = λtype.
  λ{
    #TVar: λ&u_. #True{}
    _: #Fals{}
  }(type)

// =============================================================================
// Type Substitution
// =============================================================================

// Apply type substitution: subst is list of #CON{tvar, type}
@subst_type = λ&subst. λ&type.
  λ{
    #TVar: λ&name.
      @lookup_subst(name)(subst)

    #TApp: λ&base. λ&params.
      #TApp{@subst_type(subst)(base), @map(@subst_type(subst))(params)}

    #TFun: λ&args. λ&ret.
      #TFun{@map(@subst_type(subst))(args), @subst_type(subst)(ret)}

    #TFunE: λ&args. λ&ret. λ&eff.
      #TFunE{@map(@subst_type(subst))(args), @subst_type(subst)(ret), eff}

    #TSup: λ&elem.
      #TSup{@subst_type(subst)(elem)}

    #TWSup: λ&elem.
      #TWSup{@subst_type(subst)(elem)}

    _: type
  }(type)

@lookup_subst = λ&name. λ&subst.
  λ{
    #NIL: #TVar{name}  // Not found - return original var
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&var. λ&rest.
          λ{
            #CON: λ&type. λ&u_l.
              λ{
                1: type
                _: @lookup_subst(name)(t)
              }((λ{#TVar: λ&n. n}(var) == name))
          }(rest)
      }(h)
  }(subst)

// =============================================================================
// Protocol/Interface Support
// =============================================================================

// Protocol: #Prot{name, methods}
// - name: protocol name
// - methods: list of #PMeth{name, sig}

@make_protocol = λname. λmethods.
  #Prot{name, methods}

// Check if type implements protocol
@implements_check = λ&type. λ&protocol. λ&method_registry.
  λ{
    #Prot: λ&pname_unused. λ&pmethods.
      @all_methods_present_check(type)(pmethods)(method_registry)
  }(protocol)

@all_methods_present_check = λ&type. λ&pmethods. λ&registry.
  λ{
    #NIL: #True{}
    #CON: λ&pm. λ&rest.
      λ{
        #PMeth: λ&mname. λ&msig_unused.
          !!&found = @find_method_for_type(mname)(type)(registry);
          λ{
            #Noth: #Fals{}
            _: @all_methods_present_check(type)(rest)(registry)
          }(found)
      }(pm)
  }(pmethods)

@find_method_for_type = λ&name. λ&type. λ&methods.
  λ{
    #NIL: #Noth{}
    #CON: λ&meth. λ&rest.
      λ{
        #Meth: λ&mname. λ&msig. λ&mimpl_u.
          λ{
            1:
              // Check if first param type matches
              λ{
                #NIL: @find_method_for_type(name)(type)(rest)
                #CON: λ&first_type. λ&u_f.
                  λ{
                    #True: meth
                    _: @find_method_for_type(name)(type)(rest)
                  }(@subtype_check(type)(first_type))
              }(msig)
            _: @find_method_for_type(name)(type)(rest)
          }((mname == name))
      }(meth)
  }(methods)

// =============================================================================
// Type Registration (Runtime)
// =============================================================================

// Global type registry - list of registered types
// In practice, this would be a mutable ref cell or use HVM4 duplication
@type_registry = #NIL

// Register an abstract type: (define {abstract Name}) or (define {abstract Name Parent})
// Returns the type descriptor for use in type annotations
@omni_register_abstract = λ&name. λ&parent.
  !!&parent_type = (λ&p.
    λ{
      #NIL: @type_Any
      _: p
    }(p)
  )(parent);
  #TDsc{name, parent_type, #NIL}

// Register a struct type: (define {struct Name} [field1 {Type1}] [field2 {Type2}] ...)
// fields is a list of #TFld{name, type} descriptors
@omni_register_struct = λ&name. λ&parent. λ&fields. λ&mutable.
  !!&parent_type = (λ&p.
    λ{
      #NIL: @type_Any
      _: p
    }(p)
  )(parent);
  #TStr{name, parent_type, fields, mutable}

// Register an enum type: (define {enum Name} Variant1 (Variant2 [field {Type}]) ...)
// variants is a list of #TVrn{name, fields} descriptors
@omni_register_enum = λname. λvariants.
  #TEnm{name, variants}

// Register a union type: (define {Name} (union [{Type1} {Type2}]))
// types is a list of type descriptors
@omni_register_union = λname. λtypes.
  #TUni{name, types}

// =============================================================================
// Struct Field Operations
// =============================================================================

// Create a field descriptor
@make_field = λname. λtype.
  #TFld{name, type}

// Get field name
@field_name = λfield.
  λ{
    #TFld: λ&name. λ&type. name
    _: #sym_Unknown
  }(field)

// Get field type
@field_type = λfield.
  λ{
    #TFld: λ&name. λ&type. type
    _: @type_Any
  }(field)

// Find field by name in struct type
@find_field = λ&struct_type. λ&field_name.
  λ{
    #TStr: λ&name_u. λ&parent_u. λ&fields. λ&mutable_u.
      @find_in_fields(fields)(field_name)
    #TDsc: λ&name_u. λ&parent_u. λ&fields.
      @find_in_fields(fields)(field_name)
    _: #Noth{}
  }(struct_type)

@find_in_fields = λ&fields. λ&name.
  λ{
    #NIL: #Noth{}
    #CON: λ&field. λ&rest.
      λ{
        #TFld: λ&fname. λ&ftype_u.
          λ{
            1: field
            _: @find_in_fields(rest)(name)
          }((fname == name))
      }(field)
  }(fields)

// =============================================================================
// Enum Variant Operations
// =============================================================================

// Create an enum variant descriptor
@make_variant = λname. λfields.
  #TVrn{name, fields}

// Get variant name
@variant_name = λvariant.
  λ{
    #TVrn: λ&name. λ&fields. name
    _: #sym_Unknown
  }(variant)

// Get variant fields
@variant_fields = λvariant.
  λ{
    #TVrn: λ&name. λ&fields. fields
    _: #NIL
  }(variant)

// Find variant by name in enum type
@find_variant = λ&enum_type. λ&variant_name.
  λ{
    #TEnm: λ&name_u. λ&variants.
      @find_in_variants(variants)(variant_name)
    _: #Noth{}
  }(enum_type)

@find_in_variants = λ&variants. λ&name.
  λ{
    #NIL: #Noth{}
    #CON: λ&variant. λ&rest.
      λ{
        #TVrn: λ&vname. λ&vfields_u.
          λ{
            1: variant
            _: @find_in_variants(rest)(name)
          }((vname == name))
      }(variant)
  }(variants)

// =============================================================================
// Union Type Operations
// =============================================================================

// Check if value matches any type in union
@union_matches_check = λ&val. λ&union_type.
  λ{
    #TUni: λ&name_u. λ&types.
      @any_type_matches_check(val)(types)
    _: #Fals{}
  }(union_type)

@any_type_matches_check = λ&val. λ&types.
  λ{
    #NIL: #Fals{}
    #CON: λ&type. λ&rest.
      λ{
        #True: #True{}
        _: @any_type_matches_check(val)(rest)
      }(@has_type_check(val)(type))
  }(types)

// =============================================================================
// Type Checking Utilities
// =============================================================================

// Check if a type is an abstract type
@abstract_type_check = λtype.
  λ{
    #TDsc: λ&name. λ&parent. λ&fields.
      λ{
        #NIL: #True{}  // No fields = abstract
        _: #Fals{}
      }(fields)
    _: #Fals{}
  }(type)

// Check if a type is a struct type
@struct_type_check = λtype.
  λ{
    #TStr: λ&u1_. λ&u2_. λ&u3_. λ&u4_. #True{}
    _: #Fals{}
  }(type)

// Check if a type is an enum type
@enum_type_check = λtype.
  λ{
    #TEnm: λ&u1_. λ&u2_. #True{}
    _: #Fals{}
  }(type)

// Check if a type is a union type
@union_type_check = λtype.
  λ{
    #TUni: λ&u1_. λ&u2_. #True{}
    _: #Fals{}
  }(type)

// Check if a struct type is mutable
@mutable_struct_check = λtype.
  λ{
    #TStr: λ&name. λ&parent. λ&fields. λ&mutable.
      λ{
        #True: #True{}
        _: #Fals{}
      }(mutable)
    _: #Fals{}
  }(type)

// =============================================================================
// Parametric Type Support
// =============================================================================

// Instantiate a parametric type with concrete type arguments
// type_params is list of #TVar names, type_args is list of concrete types
@instantiate_type = λ&base_type. λ&type_params. λ&type_args.
  !!&subst = @build_subst(type_params)(type_args);
  @subst_type_deep(subst)(base_type)

@build_subst = λ&params. λ&args.
  λ{
    #NIL: #NIL
    #CON: λ&param. λ&rest_params.
      λ{
        #NIL: #NIL
        #CON: λ&arg. λ&rest_args.
          #CON{#CON{param, #CON{arg, #NIL}}, @build_subst(rest_params)(rest_args)}
      }(args)
  }(params)

// Deep substitution in all nested types
@subst_type_deep = λ&subst. λ&type.
  λ{
    #TVar: λ&name.
      @lookup_subst(name)(subst)

    #TApp: λ&base. λ&params.
      #TApp{@subst_type_deep(subst)(base), @map(@subst_type_deep(subst))(params)}

    #TFun: λ&args. λ&ret.
      #TFun{@map(@subst_type_deep(subst))(args), @subst_type_deep(subst)(ret)}

    #TFunE: λ&args. λ&ret. λ&eff.
      #TFunE{@map(@subst_type_deep(subst))(args), @subst_type_deep(subst)(ret), eff}

    #TSup: λ&elem.
      #TSup{@subst_type_deep(subst)(elem)}

    #TWSup: λ&elem.
      #TWSup{@subst_type_deep(subst)(elem)}

    #TStr: λ&name. λ&parent. λ&fields. λ&mutable.
      #TStr{name, @subst_type_deep(subst)(parent), @map(@subst_field(subst))(fields), mutable}

    #TDsc: λ&name. λ&parent. λ&fields.
      #TDsc{name, @subst_type_deep(subst)(parent), @map(@subst_field(subst))(fields)}

    _: type
  }(type)

@subst_field = λ&subst. λ&field.
  λ{
    #TFld: λ&name. λ&type.
      #TFld{name, @subst_type_deep(subst)(type)}
  }(field)

// =============================================================================
// Type Unification
// =============================================================================

// Unification result types:
// #USuc{subst} - success with substitution (list of #CON{tvar, type})
// #UFal{reason} - failure with reason

// Main unification function
// Returns #USuc{subst} or #UFal{reason}
@unify = λ&type_a. λ&type_b.
  @unify_with_subst(#NIL)(type_a)(type_b)

// Unify with existing substitution
@unify_with_subst = λ&subst. λ&type_a. λ&type_b.
  // Skip apply_subst for now to debug
  @unify_core(subst)(type_a)(type_b)

// Core unification (types already have substitution applied)
// Uses helper to handle nested pattern matching with linearity
@unify_core = λ&subst. λ&type_a. λ&type_b.
  // Clone all inputs for use in closures
  !!&s = subst;
  !!&ta = type_a;
  !!&tb = type_b;
  @unify_core_dispatch(s)(ta)(tb)

// Dispatch based on type_a
@unify_core_dispatch = λ&s. λ&ta. λ&tb.
  λ{
    // Type variable on left
    #TVar: λ&name_a.
      @unify_tvar_left(s)(name_a)(ta)(tb)

    // Type constructor on left
    #TCon: λ&name_a.
      @unify_tcon_left(s)(name_a)(ta)(tb)

    // Default: check equality
    _: @unify_default(s)(ta)(tb)
  }(ta)

// Handle #TVar on left side
@unify_tvar_left = λ&s. λ&name_a. λ&ta. λ&tb.
  λ{
    // Both type variables
    #TVar: λ&name_b.
      (λ&same.
        λ{
          1: #USuc{s}  // Same variable
          0: // Different variables - bind name_a to name_b
            #USuc{#CON{#CON{#TVar{name_a}, #CON{#TVar{name_b}, #NIL}}, s}}
        }(same)
      )((name_a == name_b))
    // Type constructor on right - bind variable to it
    #TCon: λ&n.
      @bind_var(s)(name_a)(tb)
    // Any other type on right - bind variable to it
    _: @bind_var(s)(name_a)(tb)
  }(tb)

// Handle #TCon on left side
@unify_tcon_left = λ&s. λ&name_a. λ&ta. λ&tb.
  λ{
    // Type variable on right - bind it to left
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)
    // Type constructor on right - check names match
    #TCon: λ&name_b.
      (λ&same.
        λ{
          1: #USuc{s}  // Same type constructor
          0: #UFal{#sym_TypeMismatch}  // Different constructors
        }(same)
      )((name_a == name_b))
    // Any other type - mismatch
    _: #UFal{#sym_TypeMismatch}
  }(tb)

// Default handler for other types
@unify_default = λ&s. λ&ta. λ&tb.
  λ{
    #TVar: λ&name_b.
      @bind_var(s)(name_b)(ta)
    _:
      // Both concrete - check equality
      (λ&same.
        λ{
          1: #USuc{s}
          0: #UFal{#sym_TypeMismatch}
        }(same)
      )((ta == tb))
  }(tb)

// Bind type variable to a type with occurs check
@bind_var = λ&subst. λ&var_name. λ&type.
  λ{
    #True: #UFal{#sym_OccursCheck}
    #Fals: #USuc{#CON{#CON{#TVar{var_name}, #CON{type, #NIL}}, subst}}
  }(@occurs_check(var_name)(type))

// Occurs check: does type variable appear in type?
// Each branch clones var_name as needed for linearity
@occurs_check = λ&var_name. λ&type.
  λ{
    #TVar: λ&name.
      !!&vn = var_name;  // Clone for this branch
      (λ&same. λ{ 1: #True{} 0: #Fals{} }(same))((vn == name))

    #TCon: λ&name.
      #Fals{}  // Type constructors don't contain type variables

    #TApp: λ&base. λ&params.
      !!&vn1 = var_name;  // Clone for base check
      !!&vn2 = var_name;  // Clone for params check
      !!&in_base = @occurs_check(vn1)(base);
      λ{
        #True: #True{}
        _: @occurs_in_list(vn2)(params)
      }(in_base)

    #TFun: λ&args. λ&ret.
      !!&vn1 = var_name;  // Clone for args
      !!&vn2 = var_name;  // Clone for ret
      !!&in_args = @occurs_in_list(vn1)(args);
      λ{
        #True: #True{}
        _: @occurs_check(vn2)(ret)
      }(in_args)

    #TFunE: λ&args. λ&ret. λ&eff_unused.
      !!&vn1 = var_name;  // Clone for args
      !!&vn2 = var_name;  // Clone for ret
      !!&in_args = @occurs_in_list(vn1)(args);
      λ{
        #True: #True{}
        _: @occurs_check(vn2)(ret)
      }(in_args)

    #TSup: λ&elem.
      !!&vn = var_name;
      @occurs_check(vn)(elem)

    #TWSup: λ&elem.
      !!&vn = var_name;
      @occurs_check(vn)(elem)

    _: #Fals{}
  }(type)

// Check if type variable occurs in any type in list
@occurs_in_list = λ&var_name. λ&types.
  λ{
    #NIL: #Fals{}
    #CON: λ&h. λ&t.
      !!&vn1 = var_name;  // Clone for head
      !!&vn2 = var_name;  // Clone for tail recursion
      !!&in_head = @occurs_check(vn1)(h);
      λ{
        #True: #True{}
        _: @occurs_in_list(vn2)(t)
      }(in_head)
  }(types)

// Unify two lists of types pairwise
@unify_lists = λ&subst. λ&types_a. λ&types_b.
  λ{
    #NIL:
      λ{
        #NIL: #USuc{subst}
        _: #UFal{#sym_ArityMismatch}
      }(types_b)
    #CON: λ&ha. λ&ta.
      λ{
        #NIL: #UFal{#sym_ArityMismatch}
        #CON: λ&hb. λ&tb.
          !!&head_result = @unify_with_subst(subst)(ha)(hb);
          λ{
            #USuc: λ&subst2.
              @unify_lists(subst2)(ta)(tb)
            _: head_result
          }(head_result)
      }(types_b)
  }(types_a)

// Unify effect rows (for now, simple equality)
@unify_effects = λ&subst. λ&eff_a. λ&eff_b.
  λ{
    #NIL:
      λ{
        #NIL: #USuc{subst}
        _: #UFal{#sym_EffectMismatch}
      }(eff_b)
    #ERws: λ&effs_a.
      λ{
        #ERws: λ&effs_b.
          // For now, require exact effect match
          // TODO: effect row polymorphism
          @unify_effect_lists(subst)(effs_a)(effs_b)
        _: #UFal{#sym_EffectMismatch}
      }(eff_b)
    _:
      λ{
        #NIL: #UFal{#sym_EffectMismatch}
        _: #USuc{subst}  // Both unknown - accept
      }(eff_b)
  }(eff_a)

// Unify effect lists (simple equality for now)
@unify_effect_lists = λ&subst. λ&effs_a. λ&effs_b.
  λ{
    #NIL:
      λ{
        #NIL: #USuc{subst}
        _: #UFal{#sym_EffectMismatch}
      }(effs_b)
    #CON: λ&ha. λ&ta.
      λ{
        #NIL: #UFal{#sym_EffectMismatch}
        #CON: λ&hb. λ&tb.
          λ{
            1: @unify_effect_lists(subst)(ta)(tb)
            _: #UFal{#sym_EffectMismatch}
          }((ha == hb))
      }(effs_b)
  }(effs_a)

// Apply substitution to a type (like subst_type but for unification)
@apply_subst = λ&subst. λ&type.
  λ{
    #TVar: λ&name.
      @apply_subst_var(subst)(name)(type)

    #TCon: λ&name.
      type  // Type constructors don't have substitutions

    #TApp: λ&base. λ&params.
      #TApp{@apply_subst(subst)(base), @map_apply_subst(subst)(params)}

    #TFun: λ&args. λ&ret.
      #TFun{@map_apply_subst(subst)(args), @apply_subst(subst)(ret)}

    #TFunE: λ&args. λ&ret. λ&eff.
      #TFunE{@map_apply_subst(subst)(args), @apply_subst(subst)(ret), eff}

    #TSup: λ&elem.
      #TSup{@apply_subst(subst)(elem)}

    #TWSup: λ&elem.
      #TWSup{@apply_subst(subst)(elem)}

    _: type
  }(type)

// Look up type variable in substitution, recursively apply
@apply_subst_var = λ&subst. λ&name. λ&original.
  λ{
    #NIL: original  // Not found
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&var. λ&rest.
          λ{
            #CON: λ&bound_type. λ&u_.
              λ{
                #TVar: λ&var_name.
                  λ{
                    1:
                      // Found binding - apply subst to bound type too
                      @apply_subst(subst)(bound_type)
                    _: @apply_subst_var(t)(name)(original)
                  }((var_name == name))
                _: @apply_subst_var(t)(name)(original)
              }(var)
          }(rest)
      }(h)
  }(subst)

// Map apply_subst over list
@map_apply_subst = λ&subst. λ&types.
  λ{
    #NIL: #NIL
    #CON: λ&h. λ&t.
      #CON{@apply_subst(subst)(h), @map_apply_subst(subst)(t)}
  }(types)

// =============================================================================
// Constraint Generation
// =============================================================================

// Constraint: #TCon{expected, actual, location}
// - expected: expected type
// - actual: inferred type
// - location: source location for error reporting

@make_constraint = λ&expected. λ&actual. λ&loc.
  #TCon{expected, actual, loc}

// Generate constraints from expression and expected type
// Returns #CON{constraints, inferred_type}
@generate_constraints = λ&expr. λ&expected. λ&env.
  λ{
    // Integer literal
    #Cst: λ&n_unused.
      #CON{#CON{@make_constraint(expected)(@type_Int)(expr), #NIL}, @type_Int}

    // Symbol reference - look up in environment
    #Sym: λ&s.
      !!&type = @env_lookup_type(env)(s);
      #CON{#CON{@make_constraint(expected)(type)(expr), #NIL}, type}

    // Lambda expression
    #Lam: λ&var. λ&body.
      // Create fresh type variable for parameter
      !!&param_type = #TVar{var};
      // Extend environment
      !!&env2 = @env_extend(env)(var)(param_type);
      // Generate constraints for body with fresh return type
      !!&ret_type = @fresh_type_var();
      !!&body_result = @generate_constraints(body)(ret_type)(env2);
      λ{
        #CON: λ&body_cons. λ&rest.
          λ{
            #CON: λ&actual_ret. λ&u1_.
              !!&fn_type = #TFun{#CON{param_type, #NIL}, actual_ret};
              !!&cons = #CON{@make_constraint(expected)(fn_type)(expr), body_cons};
              #CON{cons, fn_type}
          }(rest)
      }(body_result)

    // Application
    #App: λ&func. λ&arg.
      // Generate fresh type variable for result
      !!&result_type = @fresh_type_var();
      // Generate constraints for function (expect it to be a function)
      !!&arg_type = @fresh_type_var();
      !!&fn_type = #TFun{#CON{arg_type, #NIL}, result_type};
      !!&func_result = @generate_constraints(func)(fn_type)(env);
      !!&arg_result = @generate_constraints(arg)(arg_type)(env);
      λ{
        #CON: λ&func_cons. λ&u2_.
          λ{
            #CON: λ&arg_cons. λ&u3_.
              !!&all_cons = @append(func_cons)(arg_cons);
              !!&all_cons2 = #CON{@make_constraint(expected)(result_type)(expr), all_cons};
              #CON{all_cons2, result_type}
          }(arg_result)
      }(func_result)

    // Let binding
    #Let: λ&var. λ&val. λ&body.
      !!&val_type = @fresh_type_var();
      !!&val_result = @generate_constraints(val)(val_type)(env);
      λ{
        #CON: λ&val_cons. λ&rest.
          λ{
            #CON: λ&actual_val_type. λ&u4_.
              !!&env2 = @env_extend(env)(var)(actual_val_type);
              !!&body_result = @generate_constraints(body)(expected)(env2);
              λ{
                #CON: λ&body_cons. λ&rest2.
                  λ{
                    #CON: λ&actual_body_type. λ&u5_.
                      !!&all_cons = @append(val_cons)(body_cons);
                      #CON{all_cons, actual_body_type}
                  }(rest2)
              }(body_result)
          }(rest)
      }(val_result)

    // Default - return Any type
    _:
      #CON{#CON{@make_constraint(expected)(@type_Any)(expr), #NIL}, @type_Any}
  }(expr)

// =============================================================================
// Constraint Solving
// =============================================================================

// Solve constraints by unifying each pair
// Returns #USuc{final_subst} or #UFal{reason}
@solve_constraints = λconstraints.
  @solve_constraints_with_subst(#NIL)(constraints)

@solve_constraints_with_subst = λ&subst. λ&constraints.
  λ{
    #NIL: #USuc{subst}
    #CON: λ&con. λ&rest.
      λ{
        #TCon: λ&expected. λ&actual. λ&loc_unused.
          !!&result = @unify_with_subst(subst)(expected)(actual);
          λ{
            #USuc: λ&new_subst.
              @solve_constraints_with_subst(new_subst)(rest)
            _: result
          }(result)
      }(con)
  }(constraints)

// =============================================================================
// Type Inference
// =============================================================================

// Infer type of expression
// Returns #TRes{type, subst} or #TErr{reason}
@infer_type_expr = λ&expr. λ&env.
  !!&expected = @fresh_type_var();
  !!&gen_result = @generate_constraints(expr)(expected)(env);
  λ{
    #CON: λ&constraints. λ&rest.
      λ{
        #CON: λ&inferred. λ&u6_.
          !!&solve_result = @solve_constraints(constraints);
          λ{
            #USuc: λ&subst.
              !!&final_type = @apply_subst(subst)(inferred);
              #TRes{final_type, subst}
            #UFal: λ&reason.
              #TErr{reason}
          }(solve_result)
      }(rest)
  }(gen_result)

// =============================================================================
// Type Environment
// =============================================================================

// Environment: list of #CON{name, type}
@empty_type_env = #NIL

@env_extend = λenv. λname. λtype.
  #CON{#CON{name, type}, env}

@env_lookup_type = λ&env. λ&name.
  λ{
    #NIL: @type_Any  // Not found - default to Any
    #CON: λ&h. λ&t.
      λ{
        #CON: λ&n. λ&ty.
          λ{
            1: ty
            _: @env_lookup_type(t)(name)
          }((n == name))
      }(h)
  }(env)

// =============================================================================
// Fresh Type Variable Generation
// =============================================================================

// Counter for generating fresh type variables
// In a real implementation, this would use a mutable ref or threading
// For now, use a simple deterministic scheme based on expression hash
@fresh_type_var_counter = 0

@fresh_type_var =
  // Generate a unique type variable name
  // This is a placeholder - real implementation needs threading or mutation
  #TVar{#sym_T}

// Append two lists
@append = λ&xs. λ&ys.
  λ{
    #NIL: ys
    #CON: λ&h. λ&t. #CON{h, @append(t)(ys)}
  }(xs)

