;; test_list_reverse.lisp - Tests for reverse

;; Reverse using accumulator
(define reverse-acc [lst] [acc]
  (match lst
    ()       acc
    (h .. t) (reverse-acc t (cons h acc))))

(define reverse [lst]
  (reverse-acc lst '()))

;; TEST: reverse non-empty list
;; EXPECT: (5 4 3 2 1)
(reverse '(1 2 3 4 5))

;; TEST: reverse empty list
;; EXPECT: ()
(reverse '())

;; TEST: reverse single element
;; EXPECT: (42)
(reverse '(42))

;; TEST: reverse preserves all elements
;; EXPECT: (1 2 3 4 5)
(reverse (reverse '(1 2 3 4 5)))

;; Reverse with nested lists (shallow)
;; TEST: reverse doesn't recurse into nested lists
;; EXPECT: ((4 5 6) (1 2 3))
(reverse '((1 2 3) (4 5 6)))

;; Build list with reverse
(define iota-helper [n] [acc]
  (if (< n 0)
    acc
    (iota-helper (- n 1) (cons n acc))))

(define iota [n] (iota-helper (- n 1) '()))

;; TEST: iota builds list 0 to n-1
;; EXPECT: (0 1 2 3 4)
(iota 5)
