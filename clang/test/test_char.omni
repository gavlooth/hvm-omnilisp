;; test_char.lisp - Tests for character operations

;; Char->int converts character to its code point
;; TEST: char->int lowercase a
;; EXPECT: 97
(char->int "a")

;; TEST: char->int uppercase A
;; EXPECT: 65
(char->int "A")

;; TEST: char->int digit 0
;; EXPECT: 48
(char->int "0")

;; TEST: char->int space
;; EXPECT: 32
(char->int " ")

;; TEST: char->int newline
;; EXPECT: 10
(char->int "\n")

;; Int->char converts code point to character
;; TEST: int->char lowercase a
;; EXPECT: "a"
(int->char 97)

;; TEST: int->char uppercase A
;; EXPECT: "A"
(int->char 65)

;; TEST: int->char digit 0
;; EXPECT: "0"
(int->char 48)

;; TEST: int->char space
;; EXPECT: " "
(int->char 32)

;; Character predicates
(define char-digit? [c]
  (let [code (char->int c)]
    (and (>= code 48) (<= code 57))))

(define char-alpha? [c]
  (let [code (char->int c)]
    (or (and (>= code 65) (<= code 90))
        (and (>= code 97) (<= code 122)))))

(define char-upper? [c]
  (let [code (char->int c)]
    (and (>= code 65) (<= code 90))))

(define char-lower? [c]
  (let [code (char->int c)]
    (and (>= code 97) (<= code 122))))

;; TEST: char-digit? true
;; EXPECT: true
(char-digit? "5")

;; TEST: char-digit? false
;; EXPECT: false
(char-digit? "a")

;; TEST: char-alpha? true
;; EXPECT: true
(char-alpha? "z")

;; TEST: char-alpha? false
;; EXPECT: false
(char-alpha? "5")

;; TEST: char-upper?
;; EXPECT: true
(char-upper? "Z")

;; TEST: char-lower?
;; EXPECT: true
(char-lower? "z")
