;; test_effects_exception.omni - Tests for exception-like patterns
;; Using handle/perform for error handling

;; TEST: simple effect catch
;; EXPECT: "caught"
(handle
  (perform error-signal)
  (error-signal [resume] "caught"))

;; TEST: effect with value
;; EXPECT: "error: oops"
(handle
  (perform raise "oops")
  (raise [msg resume] (str-concat "error: " msg)))

;; TEST: computation then effect
;; EXPECT: 42
(handle
  (do
    (+ 1 2)
    (perform get-val))
  (get-val [resume] (resume 42)))

;; TEST: conditional effect
;; EXPECT: "negative"
(handle
  (let [x -5]
    (if (< x 0)
      (perform signal "negative")
      "positive"))
  (signal [msg resume] msg))

;; TEST: no effect - normal return
;; EXPECT: 10
(handle
  (let [x 5]
    (if (< x 0)
      (perform signal "negative")
      (* x 2)))
  (signal [msg resume] msg))

;; Safe divide with effect
(define safe-div [a] [b]
  (handle
    (if (= b 0)
      (perform div-error)
      (/ a b))
    (div-error [resume] 0)))

;; TEST: safe divide success
;; EXPECT: 5
(safe-div 10 2)

;; TEST: safe divide by zero
;; EXPECT: 0
(safe-div 10 0)

;; TEST: effect with dict payload
;; EXPECT: 404
(handle
  (perform error-data #{"code" 404 "msg" "not found"})
  (error-data [err resume] (get err "code")))

;; EXPECT: true
(= (safe-div 20 4) 5)
