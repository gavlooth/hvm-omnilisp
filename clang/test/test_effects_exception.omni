;; test_effects_exception.omni - Tests for exception-like patterns
;; Using handle/perform for error handling

;; TEST: simple effect catch
;; EXPECT: 999
(handle
  (perform error-signal nil)
  (error-signal [_ resume] 999))

;; TEST: effect with value - numeric version
;; EXPECT: 100
(handle
  (perform raise 10)
  (raise [msg resume] (* msg 10)))

;; TEST: computation then effect
;; EXPECT: 42
(handle
  (do
    (+ 1 2)
    (perform get-val nil))
  (get-val [_ resume] (resume 42)))

;; TEST: conditional effect - numeric
;; EXPECT: -1
(handle
  (let [x -5]
    (if (< x 0)
      (perform signal -1)
      1))
  (signal [msg resume] msg))

;; TEST: no effect - normal return
;; EXPECT: 10
(handle
  (let [x 5]
    (if (< x 0)
      (perform signal -1)
      (* x 2)))
  (signal [msg resume] msg))

;; TEST: safe divide success
;; EXPECT: 5
(do
  (define safe-div [a] [b]
    (handle
      (if (= b 0)
        (perform div-error nil)
        (/ a b))
      (div-error [_ resume] 0)))
  (safe-div 10 2))

;; TEST: safe divide by zero
;; EXPECT: 0
(do
  (define safe-div [a] [b]
    (handle
      (if (= b 0)
        (perform div-error nil)
        (/ a b))
      (div-error [_ resume] 0)))
  (safe-div 10 0))

;; TEST: effect with payload, extract value
;; EXPECT: 404
(handle
  (perform error-data 404)
  (error-data [err resume] err))

;; EXPECT: true
(do
  (define safe-div [a] [b]
    (handle
      (if (= b 0)
        (perform div-error nil)
        (/ a b))
      (div-error [_ resume] 0)))
  (= (safe-div 20 4) 5))
