        -:    0:Source:../hvm4/clang/wnf/eql_ctr.c
        -:    0:Graph:main-cov-main.gcno
        -:    0:Data:main-cov-main.gcda
        -:    0:Runs:9
        -:    1:// (#K{a0,a1...} === #K{b0,b1...})  (same tag)
        -:    2:// --------------------------------------- EQL-CTR-MAT
        -:    3:// For SUC (1n+): ↑(pred === pred)
        -:    4:// For CON (<>): ↑((head === head) & ↑(tail === tail))
        -:    5:// Others: (a0 === b0) & (a1 === b1) & ...
        -:    6://
        -:    7:// (#K{...} === #L{...})  (different tag)
        -:    8:// ------------------------------------- EQL-CTR-MIS
        -:    9:// #0
    #####:   10:fn Term wnf_eql_ctr(Term a, Term b) {
    #####:   11:  ITRS++;
    #####:   12:  u32 a_tag = term_tag(a);
    #####:   13:  u32 b_tag = term_tag(b);
    #####:   14:  u32 a_ext = term_ext(a);
    #####:   15:  u32 b_ext = term_ext(b);
        -:   16:
        -:   17:  // Different constructor tags or names -> #0
    #####:   18:  if (a_tag != b_tag || a_ext != b_ext) {
    #####:   19:    return term_new_num(0);
        -:   20:  }
        -:   21:
    #####:   22:  u32 arity = a_tag - C00;
        -:   23:
        -:   24:  // Arity 0: equal
    #####:   25:  if (arity == 0) {
    #####:   26:    return term_new_num(1);
        -:   27:  }
        -:   28:
    #####:   29:  u32  a_loc = term_val(a);
    #####:   30:  u32  b_loc = term_val(b);
        -:   31:
        -:   32:  // SUC (1n+): recursive natural - wrap in INC for priority
    #####:   33:  if (a_ext == NAM_SUC && arity == 1) {
    #####:   34:    Term eq = term_new_eql(heap_read(a_loc), heap_read(b_loc));
    #####:   35:    return term_new_inc(eq);
        -:   36:  }
        -:   37:
        -:   38:  // CON (<>): recursive list - wrap tail and whole in INC
    #####:   39:  if (a_ext == NAM_CON && arity == 2) {
    #####:   40:    Term eq_h = term_new_eql(heap_read(a_loc), heap_read(b_loc));
    #####:   41:    Term eq_t = term_new_inc(term_new_eql(heap_read(a_loc + 1), heap_read(b_loc + 1)));
    #####:   42:    return term_new_inc(term_new_and(eq_h, eq_t));
        -:   43:  }
        -:   44:
        -:   45:  // Other constructors: no INC, just AND chain
    #####:   46:  Term result = term_new_eql(heap_read(a_loc), heap_read(b_loc));
    #####:   47:  for (u32 i = 1; i < arity; i++) {
    #####:   48:    Term eq_i = term_new_eql(heap_read(a_loc + i), heap_read(b_loc + i));
    #####:   49:    result = term_new_and(result, eq_i);
        -:   50:  }
    #####:   51:  return result;
        -:   52:}
