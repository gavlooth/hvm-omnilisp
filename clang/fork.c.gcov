        -:    0:Source:../hvm4/clang/parse/term/fork.c
        -:    0:Graph:main-cov-main.gcno
        -:    0:Data:main-cov-main.gcda
        -:    0:Runs:422
        -:    1:fn Term parse_term(PState *s, u32 depth);
        -:    2:
        -:    3:// Fork: &Lλx,y,z{A;B} or &(L)λx,y,z{A;B}
        -:    4:// Desugars to: λx&L.λy&L.λz&L.&L{A';B'}
        -:    5:// where A' uses x₀,y₀,z₀ and B' uses x₁,y₁,z₁
    #####:    6:fn Term parse_term_fork(PState *s, int dyn, Term lab_term, u32 lab, u32 depth) {
        -:    7:  u32 names[16];
    #####:    8:  u32 n = 0;
    #####:    9:  names[n++] = parse_name(s);
    #####:   10:  parse_skip(s);
    #####:   11:  while (parse_peek(s) != '{') {
    #####:   12:    parse_match(s, ",");  // optional comma between names
    #####:   13:    parse_skip(s);
    #####:   14:    if (parse_peek(s) == '{') break;
    #####:   15:    names[n++] = parse_name(s);
    #####:   16:    parse_skip(s);
        -:   17:  }
    #####:   18:  parse_consume(s, "{");
    #####:   19:  u32 d = dyn ? 3 : 2;
    #####:   20:  for (u32 i = 0; i < n; i++) {
    #####:   21:    parse_bind_push(names[i], depth + i * d + 1, dyn ? 0xFFFFFF : lab, PBIND_DUP, 0);
        -:   22:  }
    #####:   23:  u32 body_depth = depth + n * d;
        -:   24:  // Optional &₀: before left branch
    #####:   25:  parse_match(s, "&₀:");
    #####:   26:  PARSE_FORK_SIDE = 0;
    #####:   27:  Term left = parse_term(s, body_depth);
    #####:   28:  parse_skip(s);
    #####:   29:  parse_match(s, ";");  // optional semicolon between branches
    #####:   30:  parse_skip(s);
        -:   31:  // Optional &₁: before right branch
    #####:   32:  parse_match(s, "&₁:");
    #####:   33:  PARSE_FORK_SIDE = 1;
    #####:   34:  Term right = parse_term(s, body_depth);
    #####:   35:  PARSE_FORK_SIDE = -1;
    #####:   36:  parse_skip(s);
    #####:   37:  parse_match(s, ";");  // optional trailing semicolon
    #####:   38:  parse_consume(s, "}");
    #####:   39:  for (u32 i = 0; i < n; i++) {
    #####:   40:    parse_bind_pop();
        -:   41:  }
        -:   42:  // Build body: DSU or SUP
        -:   43:  Term body;
    #####:   44:  if (dyn) {
    #####:   45:    body = term_new_dsu(lab_term, left, right);
        -:   46:  } else {
    #####:   47:    body = term_new_sup(lab, left, right);
        -:   48:  }
        -:   49:  // Wrap with λ&L or λ&(L) for each arg (reverse order)
    #####:   50:  for (int i = n - 1; i >= 0; i--) {
    #####:   51:    u32 dd = depth + i * d;
    #####:   52:    if (dyn) {
    #####:   53:      u64 loc1 = heap_alloc(1);
    #####:   54:      HEAP[loc1] = body;
    #####:   55:      u64 loc0 = heap_alloc(1);
    #####:   56:      HEAP[loc0] = term_new(0, LAM, dd + 3, loc1);
    #####:   57:      Term ddu = term_new_ddu(lab_term, term_new(0, BJV, 0, dd + 1), term_new(0, LAM, dd + 2, loc0));
    #####:   58:      u64 lam_loc = heap_alloc(1);
    #####:   59:      HEAP[lam_loc] = ddu;
    #####:   60:      body = term_new(0, LAM, dd + 1, lam_loc);
        -:   61:    } else {
    #####:   62:      u64 dup_term_loc = heap_alloc(2);
    #####:   63:      HEAP[dup_term_loc + 0] = term_new(0, BJV, 0, dd + 1);
    #####:   64:      HEAP[dup_term_loc + 1] = body;
    #####:   65:      u64 lam_loc = heap_alloc(1);
    #####:   66:      HEAP[lam_loc] = term_new(0, DUP, lab, dup_term_loc);
    #####:   67:      body = term_new(0, LAM, dd + 1, lam_loc);
        -:   68:    }
        -:   69:  }
    #####:   70:  return body;
        -:   71:}
