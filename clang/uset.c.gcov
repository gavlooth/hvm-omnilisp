        -:    0:Source:../hvm4/clang/data/uset.c
        -:    0:Graph:main-cov-main.gcno
        -:    0:Data:main-cov-main.gcda
        -:    0:Runs:422
        -:    1:// data/uset.c - open-addressing set for non-zero u32 keys.
        -:    2://
        -:    3:// Context
        -:    4:// - Used by parallel normalization to track visited heap locations cheaply.
        -:    5:// - Optimized for insert/contains; there is no deletion.
        -:    6://
        -:    7:// Design
        -:    8:// - Linear probing over a power-of-two table.
        -:    9:// - Key 0 is reserved as the empty slot sentinel.
        -:   10:// - Hash is multiplicative; index is masked by (cap - 1).
        -:   11:// - Grows by doubling when load exceeds ~70%.
        -:   12://
        -:   13:// Notes
        -:   14:// - Not thread-safe; callers must synchronize externally.
        -:   15:// - cap_hint is rounded up to a power of two (minimum 2).
        -:   16:// - On allocation failure, the process exits with an error.
        -:   17:// - Because 0 is reserved, 0 is always reported as "not present".
        -:   18:
        -:   19:// Uset stores the open-addressing table and its load metadata.
        -:   20:typedef struct {
        -:   21:  u32 *table;
        -:   22:  u32 cap;
        -:   23:  u32 mask;
        -:   24:  u32 len;
        -:   25:} Uset;
        -:   26:
        -:   27:// Multiplicative hash for u32 keys (unmasked).
  8750128:   28:static inline u32 uset_hash(u32 key) {
  8750128:   29:  return key * 2654435761u;
        -:   30:}
        -:   31:
        -:   32:// Round up to next power of two (minimum 2) for mask arithmetic.
      282:   33:static inline u32 uset_next_pow2(u32 x) {
      282:   34:  if (x < 2u) {
    #####:   35:    return 2u;
        -:   36:  }
      282:   37:  x--;
      282:   38:  x |= x >> 1;
      282:   39:  x |= x >> 2;
      282:   40:  x |= x >> 4;
      282:   41:  x |= x >> 8;
      282:   42:  x |= x >> 16;
      282:   43:  return x + 1;
        -:   44:}
        -:   45:
        -:   46:// Initialize the set with a capacity >= cap_hint.
      282:   47:static inline void uset_init(Uset *set, u32 cap_hint) {
      282:   48:  u32 cap = uset_next_pow2(cap_hint);
      282:   49:  set->table = (u32 *)calloc(cap, sizeof(u32));
      282:   50:  if (!set->table) {
    #####:   51:    fprintf(stderr, "uset: allocation failed\n");
    #####:   52:    exit(1);
        -:   53:  }
      282:   54:  set->cap  = cap;
      282:   55:  set->mask = cap - 1;
      282:   56:  set->len  = 0;
      282:   57:}
        -:   58:
        -:   59:// Release the backing table and reset the set state.
      144:   60:static inline void uset_free(Uset *set) {
      144:   61:  if (set->table) {
      144:   62:    free(set->table);
      144:   63:    set->table = NULL;
        -:   64:  }
      144:   65:  set->cap = 0;
      144:   66:  set->mask = 0;
      144:   67:  set->len = 0;
      144:   68:}
        -:   69:
        -:   70:// Resize to new_cap and reinsert all keys.
        3:   71:static inline void uset_rehash(Uset *set, u32 new_cap) {
        3:   72:  u32 *old = set->table;
        3:   73:  u32 old_cap = set->cap;
        -:   74:
        3:   75:  set->table = (u32 *)calloc(new_cap, sizeof(u32));
        3:   76:  if (!set->table) {
    #####:   77:    fprintf(stderr, "uset: allocation failed\n");
    #####:   78:    exit(1);
        -:   79:  }
        3:   80:  set->cap  = new_cap;
        3:   81:  set->mask = new_cap - 1;
        3:   82:  set->len  = 0;
        -:   83:
  7340035:   84:  for (u32 i = 0; i < old_cap; i++) {
  7340032:   85:    u32 key = old[i];
  7340032:   86:    if (key == 0) {
  2202011:   87:      continue;
        -:   88:    }
  5138021:   89:    u32 idx = uset_hash(key) & set->mask;
  6510185:   90:    while (set->table[idx] != 0) {
  1372164:   91:      idx = (idx + 1) & set->mask;
        -:   92:    }
  5138021:   93:    set->table[idx] = key;
  5138021:   94:    set->len++;
        -:   95:  }
        -:   96:
        3:   97:  free(old);
        3:   98:}
        -:   99:
        -:  100:// Check whether key is present (0 is never present).
        -:  101:static inline u8 uset_has(Uset *set, u32 key) {
        -:  102:  if (key == 0) {
        -:  103:    return 0;
        -:  104:  }
        -:  105:  u32 idx = uset_hash(key) & set->mask;
        -:  106:  for (u32 i = 0; i < set->cap; i++) {
        -:  107:    u32 cur = set->table[idx];
        -:  108:    if (cur == 0) {
        -:  109:      return 0;
        -:  110:    }
        -:  111:    if (cur == key) {
        -:  112:      return 1;
        -:  113:    }
        -:  114:    idx = (idx + 1) & set->mask;
        -:  115:  }
        -:  116:  return 0;
        -:  117:}
        -:  118:
        -:  119:// Insert key if missing; returns 1 if inserted, 0 if already present.
  3612107:  120:static inline u8 uset_add(Uset *set, u32 key) {
  3612107:  121:  if (key == 0) {
    #####:  122:    return 0;
        -:  123:  }
  3612107:  124:  if ((set->len + 1) * 10 >= set->cap * 7) {
        3:  125:    u32 new_cap = set->cap << 1;
        3:  126:    if (new_cap < set->cap) {
    #####:  127:      fprintf(stderr, "uset: allocation failed\n");
    #####:  128:      exit(1);
        -:  129:    }
        3:  130:    uset_rehash(set, new_cap);
        -:  131:  }
  3612107:  132:  u32 idx = uset_hash(key) & set->mask;
  9450485:  133:  for (u32 i = 0; i < set->cap; i++) {
  9450485:  134:    u32 cur = set->table[idx];
  9450485:  135:    if (cur == key) {
     3710:  136:      return 0;
        -:  137:    }
  9446775:  138:    if (cur == 0) {
  3608397:  139:      set->table[idx] = key;
  3608397:  140:      set->len++;
  3608397:  141:      return 1;
        -:  142:    }
  5838378:  143:    idx = (idx + 1) & set->mask;
        -:  144:  }
    #####:  145:  uset_rehash(set, set->cap << 1);
    #####:  146:  return uset_add(set, key);
        -:  147:}
