        -:    0:Source:../hvm4/clang/data/uset.c
        -:    0:Graph:hvm4-cov-main.gcno
        -:    0:Data:hvm4-cov-main.gcda
        -:    0:Runs:22
        -:    1:// data/uset.c - open-addressing set for non-zero u32 keys.
        -:    2://
        -:    3:// Context
        -:    4:// - Used by parallel normalization to track visited heap locations cheaply.
        -:    5:// - Optimized for insert/contains; there is no deletion.
        -:    6://
        -:    7:// Design
        -:    8:// - Linear probing over a power-of-two table.
        -:    9:// - Key 0 is reserved as the empty slot sentinel.
        -:   10:// - Hash is multiplicative; index is masked by (cap - 1).
        -:   11:// - Grows by doubling when load exceeds ~70%.
        -:   12://
        -:   13:// Notes
        -:   14:// - Not thread-safe; callers must synchronize externally.
        -:   15:// - cap_hint is rounded up to a power of two (minimum 2).
        -:   16:// - On allocation failure, the process exits with an error.
        -:   17:// - Because 0 is reserved, 0 is always reported as "not present".
        -:   18:
        -:   19:// Uset stores the open-addressing table and its load metadata.
        -:   20:typedef struct {
        -:   21:  u32 *table;
        -:   22:  u32 cap;
        -:   23:  u32 mask;
        -:   24:  u32 len;
        -:   25:} Uset;
        -:   26:
        -:   27:// Multiplicative hash for u32 keys (unmasked).
      215:   28:static inline u32 uset_hash(u32 key) {
      215:   29:  return key * 2654435761u;
        -:   30:}
        -:   31:
        -:   32:// Round up to next power of two (minimum 2) for mask arithmetic.
       22:   33:static inline u32 uset_next_pow2(u32 x) {
       22:   34:  if (x < 2u) {
    #####:   35:    return 2u;
        -:   36:  }
       22:   37:  x--;
       22:   38:  x |= x >> 1;
       22:   39:  x |= x >> 2;
       22:   40:  x |= x >> 4;
       22:   41:  x |= x >> 8;
       22:   42:  x |= x >> 16;
       22:   43:  return x + 1;
        -:   44:}
        -:   45:
        -:   46:// Initialize the set with a capacity >= cap_hint.
       22:   47:static inline void uset_init(Uset *set, u32 cap_hint) {
       22:   48:  u32 cap = uset_next_pow2(cap_hint);
       22:   49:  set->table = (u32 *)calloc(cap, sizeof(u32));
       22:   50:  if (!set->table) {
    #####:   51:    fprintf(stderr, "uset: allocation failed\n");
    #####:   52:    exit(1);
        -:   53:  }
       22:   54:  set->cap  = cap;
       22:   55:  set->mask = cap - 1;
       22:   56:  set->len  = 0;
       22:   57:}
        -:   58:
        -:   59:// Release the backing table and reset the set state.
       22:   60:static inline void uset_free(Uset *set) {
       22:   61:  if (set->table) {
       22:   62:    free(set->table);
       22:   63:    set->table = NULL;
        -:   64:  }
       22:   65:  set->cap = 0;
       22:   66:  set->mask = 0;
       22:   67:  set->len = 0;
       22:   68:}
        -:   69:
        -:   70:// Resize to new_cap and reinsert all keys.
    #####:   71:static inline void uset_rehash(Uset *set, u32 new_cap) {
    #####:   72:  u32 *old = set->table;
    #####:   73:  u32 old_cap = set->cap;
        -:   74:
    #####:   75:  set->table = (u32 *)calloc(new_cap, sizeof(u32));
    #####:   76:  if (!set->table) {
    #####:   77:    fprintf(stderr, "uset: allocation failed\n");
    #####:   78:    exit(1);
        -:   79:  }
    #####:   80:  set->cap  = new_cap;
    #####:   81:  set->mask = new_cap - 1;
    #####:   82:  set->len  = 0;
        -:   83:
    #####:   84:  for (u32 i = 0; i < old_cap; i++) {
    #####:   85:    u32 key = old[i];
    #####:   86:    if (key == 0) {
    #####:   87:      continue;
        -:   88:    }
    #####:   89:    u32 idx = uset_hash(key) & set->mask;
    #####:   90:    while (set->table[idx] != 0) {
    #####:   91:      idx = (idx + 1) & set->mask;
        -:   92:    }
    #####:   93:    set->table[idx] = key;
    #####:   94:    set->len++;
        -:   95:  }
        -:   96:
    #####:   97:  free(old);
    #####:   98:}
        -:   99:
        -:  100:// Check whether key is present (0 is never present).
        -:  101:static inline u8 uset_has(Uset *set, u32 key) {
        -:  102:  if (key == 0) {
        -:  103:    return 0;
        -:  104:  }
        -:  105:  u32 idx = uset_hash(key) & set->mask;
        -:  106:  for (u32 i = 0; i < set->cap; i++) {
        -:  107:    u32 cur = set->table[idx];
        -:  108:    if (cur == 0) {
        -:  109:      return 0;
        -:  110:    }
        -:  111:    if (cur == key) {
        -:  112:      return 1;
        -:  113:    }
        -:  114:    idx = (idx + 1) & set->mask;
        -:  115:  }
        -:  116:  return 0;
        -:  117:}
        -:  118:
        -:  119:// Insert key if missing; returns 1 if inserted, 0 if already present.
      215:  120:static inline u8 uset_add(Uset *set, u32 key) {
      215:  121:  if (key == 0) {
    #####:  122:    return 0;
        -:  123:  }
      215:  124:  if ((set->len + 1) * 10 >= set->cap * 7) {
    #####:  125:    u32 new_cap = set->cap << 1;
    #####:  126:    if (new_cap < set->cap) {
    #####:  127:      fprintf(stderr, "uset: allocation failed\n");
    #####:  128:      exit(1);
        -:  129:    }
    #####:  130:    uset_rehash(set, new_cap);
        -:  131:  }
      215:  132:  u32 idx = uset_hash(key) & set->mask;
     215*:  133:  for (u32 i = 0; i < set->cap; i++) {
      215:  134:    u32 cur = set->table[idx];
      215:  135:    if (cur == key) {
    #####:  136:      return 0;
        -:  137:    }
      215:  138:    if (cur == 0) {
      215:  139:      set->table[idx] = key;
      215:  140:      set->len++;
      215:  141:      return 1;
        -:  142:    }
    #####:  143:    idx = (idx + 1) & set->mask;
        -:  144:  }
    #####:  145:  uset_rehash(set, set->cap << 1);
    #####:  146:  return uset_add(set, key);
        -:  147:}
