        -:    0:Source:../hvm4/clang/parse/auto_dup.c
        -:    0:Graph:hvm4-cov-main.gcno
        -:    0:Data:hvm4-cov-main.gcda
        -:    0:Runs:22
        -:    1:// Auto-dup: rewrites a cloned binder with N uses into N-1 nested DUP nodes.
        -:    2:// Example: [x,x,x] becomes !d0&=x; !d1&=d0₁; [d0₀,d1₀,d1₁]
        -:    3://
        -:    4:// The transformation is purely structural and does not evaluate anything.
        -:    5:// It must preserve binding structure and linearity:
        -:    6:// - Every occurrence of the target ref is replaced by exactly one occurrence
        -:    7://   of either a BJ0 or BJ1 that belongs to the newly created DUP chain.
        -:    8:// - The chain ensures that the two sides of each DUP are consumed exactly once.
        -:    9://
        -:   10:// The key correctness invariant is that the chain length matches the number
        -:   11:// of target occurrences in the (already desugared) body. We compute that
        -:   12:// count by traversing the term.
        -:   13://
        -:   14:// We traverse all children and sum uses. This keeps every occurrence unique
        -:   15:// across the whole term, which is required because SNF will traverse every
        -:   16:// branch (including matcher chains).
        -:   17://
        -:   18:// Works for both BJV refs (let/lambda bindings) and BJ refs (dup bindings).
        -:   19:// - Target is identified by tag + level (and ext for BJ mode).
        -:   20:// - Outer refs (level > base depth) are shifted by n to account for new dup terms.
        -:   21:
        -:   22:fn u32 auto_dup_count_go(u64 loc, u32 lvl, u8 tgt, u32 ext);
        -:   23:
       18:   24:fn u32 auto_dup_count_term(Term t, u32 lvl, u8 tgt, u32 ext) {
       18:   25:  u8  tg = term_tag(t);
       18:   26:  u32 vl = term_val(t);
        -:   27:
      18*:   28:  if (tg == tgt && vl == lvl && (tgt == BJV || term_ext(t) == ext)) {
        8:   29:    return 1;
        -:   30:  }
        -:   31:
       10:   32:  u32 ari = term_arity(t);
       10:   33:  if (ari == 0) {
        3:   34:    return 0;
        -:   35:  }
        -:   36:
        7:   37:  u32 sum = 0;
       21:   38:  for (u32 i = 0; i < ari; i++) {
       14:   39:    sum += auto_dup_count_go(vl + i, lvl, tgt, ext);
        -:   40:  }
        7:   41:  return sum;
        -:   42:}
        -:   43:
       14:   44:fn u32 auto_dup_count_go(u64 loc, u32 lvl, u8 tgt, u32 ext) {
       14:   45:  return auto_dup_count_term(HEAP[loc], lvl, tgt, ext);
        -:   46:}
        -:   47:
       12:   48:fn void auto_dup_go(u64 loc, u32 lvl, u32 base, u32 *use, u32 n, u32 lab, u8 tgt, u32 ext) {
       12:   49:  Term t = HEAP[loc];
       12:   50:  u8  tg = term_tag(t);
       12:   51:  u32 vl = term_val(t);
        -:   52:
        -:   53:  // Replace target ref with BJ0/BJ1 chain
      12*:   54:  if (tg == tgt && vl == lvl && (tgt == BJV || term_ext(t) == ext)) {
        7:   55:    u32 i = (*use)++;
        7:   56:    if (i < n) {
        4:   57:      HEAP[loc] = term_new(0, BJ0, lab + i, base + 1 + i);
        -:   58:    } else {
        3:   59:      HEAP[loc] = term_new(0, BJ1, lab + n - 1, base + n);
        -:   60:    }
        7:   61:    return;
        -:   62:  }
        -:   63:
        -:   64:  // Shift outer refs
       5*:   65:  if ((tg == BJV || tg == BJ0 || tg == BJ1 || tg == BJM) && vl > base) {
    #####:   66:    HEAP[loc] = term_new(0, tg, term_ext(t), vl + n);
    #####:   67:    return;
        -:   68:  }
        -:   69:
        -:   70:  // Recurse into children
        5:   71:  switch (tg) {
    #####:   72:    case LAM: {
    #####:   73:      auto_dup_go(vl, lvl, base, use, n, lab, tgt, ext);
    #####:   74:      return;
        -:   75:    }
    #####:   76:    case DUP: {
    #####:   77:      auto_dup_go(vl + 0, lvl, base, use, n, lab, tgt, ext);
    #####:   78:      auto_dup_go(vl + 1, lvl, base, use, n, lab, tgt, ext);
    #####:   79:      return;
        -:   80:    }
        5:   81:    default: {
        5:   82:      u32 ari = term_arity(t);
       11:   83:      for (u32 i = 0; i < ari; i++) {
        6:   84:        auto_dup_go(vl + i, lvl, base, use, n, lab, tgt, ext);
        -:   85:      }
        -:   86:    }
        -:   87:  }
        -:   88:}
        -:   89:
        4:   90:fn Term parse_auto_dup(Term body, u32 lvl, u32 base, u8 tgt, u32 ext) {
        4:   91:  u32 uses = auto_dup_count_term(body, lvl, tgt, ext);
        4:   92:  if (uses <= 1) {
        1:   93:    return body;
        -:   94:  }
        -:   95:
        3:   96:  u32 n   = uses - 1;
        3:   97:  u32 lab = PARSE_FRESH_LAB;
        3:   98:  PARSE_FRESH_LAB += n;
        -:   99:
        -:  100:  // Walk body's children
        3:  101:  u8  tg  = term_tag(body);
        3:  102:  u32 vl  = term_val(body);
        3:  103:  u32 use = 0;
        -:  104:
        3:  105:  switch (tg) {
    #####:  106:    case LAM: {
    #####:  107:      auto_dup_go(vl, lvl, base, &use, n, lab, tgt, ext);
    #####:  108:      break;
        -:  109:    }
    #####:  110:    case DUP: {
    #####:  111:      auto_dup_go(vl + 0, lvl, base, &use, n, lab, tgt, ext);
    #####:  112:      auto_dup_go(vl + 1, lvl, base, &use, n, lab, tgt, ext);
    #####:  113:      break;
        -:  114:    }
        3:  115:    default: {
        3:  116:      u32 ari = term_arity(body);
        9:  117:      for (u32 i = 0; i < ari; i++) {
        6:  118:        auto_dup_go(vl + i, lvl, base, &use, n, lab, tgt, ext);
        -:  119:      }
        -:  120:    }
        -:  121:  }
        -:  122:
        -:  123:  // Build dup chain: !d0&=x; !d1&=d0₁; ... body
        3:  124:  Term result = body;
        7:  125:  for (int i = n - 1; i >= 0; i--) {
        4:  126:    Term v   = (i == 0) ? term_new(0, tgt, ext, lvl) : term_new(0, BJ1, lab + i - 1, base + i);
        4:  127:    u64  loc = heap_alloc(2);
        4:  128:    HEAP[loc + 0] = v;
        4:  129:    HEAP[loc + 1] = result;
        4:  130:    result = term_new(0, DUP, lab + i, loc);
        -:  131:  }
        -:  132:
        3:  133:  return result;
        -:  134:}
