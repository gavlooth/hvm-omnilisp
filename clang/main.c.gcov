        -:    0:Source:../hvm4/clang/main.c
        -:    0:Graph:hvm4-cov-main.gcno
        -:    0:Data:hvm4-cov-main.gcda
        -:    0:Runs:22
        -:    1:// HVM4 CLI Entry Point
        -:    2:// ====================
        -:    3://
        -:    4:// This file provides the command-line interface for the HVM4 runtime,
        -:    5:// mirroring the structure of main.hs for the Haskell implementation.
        -:    6://
        -:    7:// Usage: ./main <file.hvm4> [-s] [-S] [-C[N]] [-T<N>]
        -:    8://   -s:  Show statistics (interactions, time, performance)
        -:    9://   -S:  Silent output (omit term printing)
        -:   10://   -C:  Collapse and flatten (enumerate all superposition branches)
        -:   11://   -CN: Collapse and flatten, limit to N results
        -:   12://   -T:  Use N threads (e.g. -T4)
        -:   13:
        -:   14:#include "hvm4.c"
        -:   15:
        -:   16:// CLI
        -:   17:// ===
        -:   18:
        -:   19:typedef struct {
        -:   20:  int   stats;
        -:   21:  int   silent;
        -:   22:  int   do_collapse;
        -:   23:  int   collapse_limit;  // -1 means no limit
        -:   24:  int   debug;
        -:   25:  int   threads;
        -:   26:  char *file;
        -:   27:} CliOpts;
        -:   28:
       22:   29:fn CliOpts parse_opts(int argc, char **argv) {
       22:   30:  CliOpts opts = {
        -:   31:    .stats = 0,
        -:   32:    .silent = 0,
        -:   33:    .do_collapse = 0,
        -:   34:    .collapse_limit = -1,
        -:   35:    .debug = 0,
        -:   36:    .threads = 0,
        -:   37:    .file = NULL
        -:   38:  };
        -:   39:
       66:   40:  for (int i = 1; i < argc; i++) {
       44:   41:    if (strcmp(argv[i], "-s") == 0) {
       22:   42:      opts.stats = 1;
       22:   43:    } else if (strcmp(argv[i], "-S") == 0) {
    #####:   44:      opts.silent = 1;
       22:   45:    } else if (strncmp(argv[i], "-C", 2) == 0) {
    #####:   46:      opts.do_collapse = 1;
    #####:   47:      if (argv[i][2] != '\0') {
    #####:   48:        opts.collapse_limit = atoi(&argv[i][2]);
        -:   49:      }
       22:   50:    } else if (strncmp(argv[i], "-T", 2) == 0) {
    #####:   51:      const char *num = argv[i] + 2;
    #####:   52:      if (num[0] == '\0') {
    #####:   53:        if (i + 1 >= argc) {
    #####:   54:          fprintf(stderr, "Error: missing thread count after -T\n");
    #####:   55:          exit(1);
        -:   56:        }
    #####:   57:        num = argv[++i];
        -:   58:      }
    #####:   59:      opts.threads = atoi(num);
       22:   60:    } else if (strcmp(argv[i], "-d") == 0) {
    #####:   61:      opts.debug = 1;
       22:   62:    } else if (argv[i][0] != '-') {
       22:   63:      if (opts.file == NULL) {
       22:   64:        opts.file = argv[i];
        -:   65:      } else {
    #####:   66:        fprintf(stderr, "Error: multiple input files specified\n");
    #####:   67:        exit(1);
        -:   68:      }
        -:   69:    } else {
    #####:   70:      fprintf(stderr, "Unknown option: %s\n", argv[i]);
    #####:   71:      exit(1);
        -:   72:    }
        -:   73:  }
        -:   74:
       22:   75:  return opts;
        -:   76:}
        -:   77:
        -:   78:// Prelude
        -:   79:// =======
        -:   80:
        -:   81:#include "prelude/_.c"
        -:   82:
        -:   83:// Main
        -:   84:// ====
        -:   85:
       22:   86:int main(int argc, char **argv) {
        -:   87:  // Parse command line
       22:   88:  CliOpts opts = parse_opts(argc, argv);
        -:   89:
       22:   90:  if (opts.file == NULL) {
    #####:   91:    fprintf(stderr, "Usage: ./main <file.hvm4> [-s] [-S] [-C[N]] [-T<N>]\n");
    #####:   92:    return 1;
        -:   93:  }
        -:   94:
        -:   95:  // Configure threads (default: 1)
      22*:   96:  u32 threads = opts.threads > 0 ? (u32)opts.threads : 1;
       22:   97:  thread_set_count(threads);
       22:   98:  wnf_set_tid(0);
        -:   99:
        -:  100:  // Allocate memory
       22:  101:  BOOK  = calloc(BOOK_CAP, sizeof(u32));
       22:  102:  HEAP  = calloc(HEAP_CAP, sizeof(Term));
       22:  103:  TABLE = calloc(BOOK_CAP, sizeof(char*));
        -:  104:
       22:  105:  if (!BOOK || !HEAP || !TABLE) {
    #####:  106:    sys_error("Memory allocation failed");
        -:  107:  }
       22:  108:  heap_init_slices();
        -:  109:
        -:  110:  // Set debug mode
       22:  111:  DEBUG = opts.debug;
        -:  112:
        -:  113:  // Parse prelude
       22:  114:  PState ps = {
        -:  115:    .file = "<prelude>",
        -:  116:    .src  = (char*)PRELUDE,
        -:  117:    .pos  = 0,
       22:  118:    .len  = strlen(PRELUDE),
        -:  119:    .line = 1,
        -:  120:    .col  = 1
        -:  121:  };
       22:  122:  parse_def(&ps);
        -:  123:
        -:  124:  // Read and parse user file
       22:  125:  char *src = sys_file_read(opts.file);
       22:  126:  if (!src) {
    #####:  127:    fprintf(stderr, "Error: could not open '%s'\n", opts.file);
    #####:  128:    return 1;
        -:  129:  }
        -:  130:
        -:  131:  // Add file to seen list
       22:  132:  char *abs_path = realpath(opts.file, NULL);
       22:  133:  if (abs_path) {
       22:  134:    PARSE_SEEN_FILES[PARSE_SEEN_FILES_LEN++] = abs_path;
        -:  135:  }
        -:  136:
       22:  137:  PState s = {
      22*:  138:    .file = abs_path ? abs_path : opts.file,
        -:  139:    .src  = src,
        -:  140:    .pos  = 0,
       22:  141:    .len  = strlen(src),
        -:  142:    .line = 1,
        -:  143:    .col  = 1
        -:  144:  };
       22:  145:  parse_def(&s);
       22:  146:  free(src);
        -:  147:
        -:  148:  // Get @main id
       22:  149:  u32 main_id = table_find("main", 4);
        -:  150:
        -:  151:  // Check @main exists
       22:  152:  if (BOOK[main_id] == 0) {
    #####:  153:    fprintf(stderr, "Error: @main not defined\n");
    #####:  154:    return 1;
        -:  155:  }
        -:  156:
        -:  157:  // Evaluate
        -:  158:  struct timespec start, end;
       22:  159:  clock_gettime(CLOCK_MONOTONIC, &start);
        -:  160:
       22:  161:  Term main_ref = term_new_ref(main_id);
        -:  162:
       22:  163:  if (opts.do_collapse) {
        -:  164:    // Lazy collapse + flatten: handles infinite structures
    #####:  165:    eval_collapse(main_ref, opts.collapse_limit, opts.stats, opts.silent);
        -:  166:  } else {
        -:  167:    // Standard evaluation to strong normal form
       22:  168:    Term result = eval_normalize(main_ref);
       22:  169:    if (!opts.silent) {
       22:  170:      print_term(result);
       22:  171:      printf("\n");
        -:  172:    }
        -:  173:  }
        -:  174:
       22:  175:  clock_gettime(CLOCK_MONOTONIC, &end);
        -:  176:
       22:  177:  wnf_itrs_flush(0);
        -:  178:
        -:  179:  // Print stats if requested
       22:  180:  u64 total_itrs = wnf_itrs_total();
       22:  181:  if (opts.stats) {
       22:  182:    double dt  = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
       22:  183:    double ips = total_itrs / dt;
       22:  184:    printf("- Itrs: %llu interactions\n", total_itrs);
       22:  185:    if (thread_get_count() > 1) {
    #####:  186:      for (u32 t = 0; t < thread_get_count(); t++) {
    #####:  187:        printf("- Itrs[%u]: %llu interactions\n", t, wnf_itrs_thread(t));
        -:  188:      }
        -:  189:    }
       22:  190:    printf("- Time: %.3f seconds\n", dt);
       22:  191:    printf("- Perf: %.2f M interactions/s\n", ips / 1e6);
    #####:  192:  } else if (opts.silent) {
    #####:  193:    printf("- Itrs: %llu interactions\n", total_itrs);
        -:  194:  }
        -:  195:
        -:  196:  // Cleanup
       22:  197:  free(HEAP);
       22:  198:  free(BOOK);
       22:  199:  free(TABLE);
       22:  200:  wnf_stack_free_all();
        -:  201:
       22:  202:  return 0;
        -:  203:}
