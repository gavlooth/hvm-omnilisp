        -:    0:Source:main.c
        -:    0:Graph:main-cov-main.gcno
        -:    0:Data:main-cov-main.gcda
        -:    0:Runs:17
        -:    1:// OmniLisp Main Entry Point
        -:    2:// Command-line interface for parsing, compiling, and running OmniLisp code
        -:    3:
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <string.h>
        -:    7:#include <getopt.h>
        -:    8:#include <signal.h>
        -:    9:#include <errno.h>
        -:   10:
        -:   11:// Socket support
        -:   12:#include <sys/socket.h>
        -:   13:#include <sys/un.h>
        -:   14:#include <netinet/in.h>
        -:   15:#include <arpa/inet.h>
        -:   16:#include <unistd.h>
        -:   17:#include <poll.h>
        -:   18:
        -:   19:// Include HVM4 runtime first
        -:   20:#include "../hvm4/clang/hvm4.c"
        -:   21:
        -:   22:// Include OmniLisp components
        -:   23:#include "omnilisp/nick/omnilisp.c"
        -:   24:#include "omnilisp/ffi/handle.c"
        -:   25:#include "omnilisp/ffi/thread_pool.c"
        -:   26:#include "omnilisp/parse/_.c"
        -:   27:#include "omnilisp/compile/_.c"
        -:   28:
        -:   29:// =============================================================================
        -:   30:// Command Line Options
        -:   31:// =============================================================================
        -:   32:
        -:   33:typedef struct {
        -:   34:  int help;
        -:   35:  int version;
        -:   36:  int parse_only;      // -p: Just parse and print AST
        -:   37:  int compile_only;    // -c: Compile but don't run
        -:   38:  int debug;           // -d: Debug mode
        -:   39:  int stats;           // -s: Show statistics
        -:   40:  int collapse;        // -C: Collapse limit
        -:   41:  int eval_mode;       // -e: Evaluate expression directly
        -:   42:  int interactive;     // -i: Interactive REPL
        -:   43:  int server_port;     // -S: Socket server port (0 = disabled)
        -:   44:  int hvm4_print;      // -T: Use HVM4's print_term for output
        -:   45:  const char *file;    // Input file
        -:   46:  const char *expr;    // Expression to evaluate
        -:   47:  const char *output;  // -o: Output file
        -:   48:} OmniOptions;
        -:   49:
        -:   50:// Global flag for graceful shutdown
        -:   51:static volatile int g_running = 1;
        -:   52:
    #####:   53:fn void signal_handler(int sig) {
        -:   54:  (void)sig;
    #####:   55:  g_running = 0;
    #####:   56:}
        -:   57:
    #####:   58:fn void print_usage(const char *prog) {
    #####:   59:  printf("OmniLisp - A Lisp dialect for HVM4\n");
    #####:   60:  printf("\n");
    #####:   61:  printf("Usage: %s [options] [file.ol]\n", prog);
    #####:   62:  printf("       %s -e \"(+ 1 2)\"\n", prog);
    #####:   63:  printf("       %s -i                    (interactive REPL)\n", prog);
    #####:   64:  printf("       %s -S 5555               (socket server)\n", prog);
    #####:   65:  printf("\n");
    #####:   66:  printf("Options:\n");
    #####:   67:  printf("  -h, --help        Show this help message\n");
    #####:   68:  printf("  -v, --version     Show version information\n");
    #####:   69:  printf("  -p, --parse       Parse only (print AST)\n");
    #####:   70:  printf("  -c, --compile     Compile only (emit HVM4)\n");
    #####:   71:  printf("  -e, --eval EXPR   Evaluate expression\n");
    #####:   72:  printf("  -i, --interactive Interactive REPL\n");
    #####:   73:  printf("  -S, --server PORT Start socket server on PORT\n");
    #####:   74:  printf("  -o, --output FILE Output file for compilation\n");
    #####:   75:  printf("  -d, --debug       Enable debug output\n");
    #####:   76:  printf("  -s, --stats       Show execution statistics\n");
    #####:   77:  printf("  -C, --collapse N  Set collapse limit (default: 10)\n");
    #####:   78:  printf("\n");
    #####:   79:  printf("Examples:\n");
    #####:   80:  printf("  %s program.ol           Run OmniLisp program\n", prog);
    #####:   81:  printf("  %s -e \"(+ 1 2)\"         Evaluate expression\n", prog);
    #####:   82:  printf("  %s -i                   Start interactive REPL\n", prog);
    #####:   83:  printf("  %s -S 5555              Start server on port 5555\n", prog);
    #####:   84:  printf("  %s -c -o out.hvm4 in.ol Compile to HVM4\n", prog);
    #####:   85:  printf("  %s -p program.ol        Show parse tree\n", prog);
    #####:   86:  printf("\n");
    #####:   87:  printf("Socket Protocol (for editor integration):\n");
    #####:   88:  printf("  Send: expression followed by newline\n");
    #####:   89:  printf("  Recv: result followed by \\x00\\n (null + newline)\n");
    #####:   90:  printf("  Test: echo '(+ 1 2)' | nc localhost 5555\n");
    #####:   91:  printf("\n");
    #####:   92:}
        -:   93:
    #####:   94:fn void print_version(void) {
    #####:   95:  printf("OmniLisp version 0.1.0\n");
    #####:   96:  printf("Built on HVM4 runtime\n");
    #####:   97:}
        -:   98:
       17:   99:fn OmniOptions parse_options(int argc, char *argv[]) {
       17:  100:  OmniOptions opts = {0};
       17:  101:  opts.collapse = 10;
        -:  102:
        -:  103:  static struct option long_options[] = {
        -:  104:    {"help",        no_argument,       0, 'h'},
        -:  105:    {"version",     no_argument,       0, 'v'},
        -:  106:    {"parse",       no_argument,       0, 'p'},
        -:  107:    {"compile",     no_argument,       0, 'c'},
        -:  108:    {"eval",        required_argument, 0, 'e'},
        -:  109:    {"interactive", no_argument,       0, 'i'},
        -:  110:    {"server",      required_argument, 0, 'S'},
        -:  111:    {"output",      required_argument, 0, 'o'},
        -:  112:    {"debug",       no_argument,       0, 'd'},
        -:  113:    {"stats",       no_argument,       0, 's'},
        -:  114:    {"collapse",    required_argument, 0, 'C'},
        -:  115:    {"term-print",  no_argument,       0, 'T'},
        -:  116:    {0, 0, 0, 0}
        -:  117:  };
        -:  118:
        -:  119:  int opt;
       17:  120:  int opt_index = 0;
        -:  121:
       51:  122:  while ((opt = getopt_long(argc, argv, "hvpce:iS:o:dsC:T", long_options, &opt_index)) != -1) {
       34:  123:    switch (opt) {
    #####:  124:      case 'h': opts.help = 1; break;
    #####:  125:      case 'v': opts.version = 1; break;
    #####:  126:      case 'p': opts.parse_only = 1; break;
    #####:  127:      case 'c': opts.compile_only = 1; break;
       17:  128:      case 'e': opts.eval_mode = 1; opts.expr = optarg; break;
    #####:  129:      case 'i': opts.interactive = 1; break;
    #####:  130:      case 'S': opts.server_port = atoi(optarg); break;
    #####:  131:      case 'o': opts.output = optarg; break;
    #####:  132:      case 'd': opts.debug = 1; break;
    #####:  133:      case 's': opts.stats = 1; break;
    #####:  134:      case 'C': opts.collapse = atoi(optarg); break;
       17:  135:      case 'T': opts.hvm4_print = 1; break;
    #####:  136:      default: opts.help = 1; break;
        -:  137:    }
        -:  138:  }
        -:  139:
       17:  140:  if (optind < argc) {
    #####:  141:    opts.file = argv[optind];
        -:  142:  }
        -:  143:
       17:  144:  return opts;
        -:  145:}
        -:  146:
        -:  147:// =============================================================================
        -:  148:// File Reading
        -:  149:// =============================================================================
        -:  150:
    #####:  151:fn char* read_file(const char *path) {
    #####:  152:  FILE *f = fopen(path, "r");
    #####:  153:  if (!f) {
    #####:  154:    fprintf(stderr, "Error: Cannot open file '%s'\n", path);
    #####:  155:    return NULL;
        -:  156:  }
        -:  157:
    #####:  158:  fseek(f, 0, SEEK_END);
    #####:  159:  long size = ftell(f);
    #####:  160:  fseek(f, 0, SEEK_SET);
        -:  161:
    #####:  162:  char *buf = (char*)malloc(size + 1);
    #####:  163:  if (!buf) {
    #####:  164:    fclose(f);
    #####:  165:    return NULL;
        -:  166:  }
        -:  167:
    #####:  168:  size_t read = fread(buf, 1, size, f);
    #####:  169:  buf[read] = '\0';
    #####:  170:  fclose(f);
        -:  171:
    #####:  172:  return buf;
        -:  173:}
        -:  174:
        -:  175:// =============================================================================
        -:  176:// AST Printing
        -:  177:// =============================================================================
        -:  178:
        -:  179:fn void print_term_indent(Term t, int indent);
        -:  180:
    #####:  181:fn void print_indent(int n) {
    #####:  182:  for (int i = 0; i < n; i++) printf("  ");
    #####:  183:}
        -:  184:
    #####:  185:fn void print_term_indent(Term t, int indent) {
    #####:  186:  u32 tag = term_tag(t);
    #####:  187:  u32 ext = term_ext(t);
    #####:  188:  u32 val = term_val(t);
        -:  189:
    #####:  190:  print_indent(indent);
        -:  191:
    #####:  192:  switch (tag) {
    #####:  193:    case C00: case C01: case C02: case C03: case C04:
        -:  194:    case C05: case C06: case C07: case C08: case C09:
        -:  195:    case C10: case C11: case C12: case C13: case C14:
        -:  196:    case C15: case C16: {
        -:  197:      // Print constructor name
        -:  198:      char name[16];
    #####:  199:      nick_to_str(ext, name, sizeof(name));
    #####:  200:      printf("#%s{\n", name);
        -:  201:
        -:  202:      // Print children based on arity (tag - C00)
    #####:  203:      u32 arity = tag - C00;
    #####:  204:      for (u32 i = 0; i < arity; i++) {
    #####:  205:        print_term_indent(HEAP[val + i], indent + 1);
    #####:  206:        if (i < arity - 1) printf(",");
    #####:  207:        printf("\n");
        -:  208:      }
        -:  209:
    #####:  210:      print_indent(indent);
    #####:  211:      printf("}");
    #####:  212:      break;
        -:  213:    }
        -:  214:
    #####:  215:    case NUM:
    #####:  216:      printf("%u", val);
    #####:  217:      break;
        -:  218:
    #####:  219:    case LAM:
    #####:  220:      printf("λ. ...");
    #####:  221:      break;
        -:  222:
    #####:  223:    case VAR:
    #####:  224:      printf("v%u", val);
    #####:  225:      break;
        -:  226:
    #####:  227:    case REF:
    #####:  228:      printf("@%u", ext);
    #####:  229:      break;
        -:  230:
    #####:  231:    default:
    #####:  232:      printf("<%u:%u:%u>", tag, ext, val);
    #####:  233:      break;
        -:  234:  }
    #####:  235:}
        -:  236:
    #####:  237:fn void print_ast(Term t) {
    #####:  238:  print_term_indent(t, 0);
    #####:  239:  printf("\n");
    #####:  240:}
        -:  241:
        -:  242:// =============================================================================
        -:  243:// User-Friendly Value Printing for REPL
        -:  244:// =============================================================================
        -:  245:
        -:  246:fn void omni_print_value_to(FILE *out, Term t);
        -:  247:
    #####:  248:fn void omni_print_list_to(FILE *out, Term t) {
    #####:  249:  fprintf(out, "(");
    #####:  250:  int first = 1;
    #####:  251:  while (term_tag(t) == C02 && term_ext(t) == OMNI_NAM_CON) {
    #####:  252:    u32 loc = term_val(t);
    #####:  253:    if (!first) fprintf(out, " ");
    #####:  254:    first = 0;
    #####:  255:    omni_print_value_to(out, HEAP[loc]);
    #####:  256:    t = HEAP[loc + 1];
        -:  257:  }
        -:  258:  // Check for improper list
    #####:  259:  if (!(term_tag(t) == C00 && term_ext(t) == OMNI_NAM_NIL)) {
    #####:  260:    fprintf(out, " . ");
    #####:  261:    omni_print_value_to(out, t);
        -:  262:  }
    #####:  263:  fprintf(out, ")");
    #####:  264:}
        -:  265:
    #####:  266:fn void omni_print_value_to(FILE *out, Term t) {
    #####:  267:  u32 tag = term_tag(t);
    #####:  268:  u32 ext = term_ext(t);
    #####:  269:  u32 val = term_val(t);
        -:  270:
        -:  271:  // Raw number
    #####:  272:  if (tag == NUM) {
    #####:  273:    fprintf(out, "%u", val);
    #####:  274:    return;
        -:  275:  }
        -:  276:
        -:  277:  // Constructors
    #####:  278:  if (tag >= C00 && tag <= C16) {
        -:  279:    // #Cst{n} or #Lit{n} - integer literal
    #####:  280:    if (ext == OMNI_NAM_CST || ext == OMNI_NAM_LIT) {
    #####:  281:      Term inner = HEAP[val];
    #####:  282:      if (term_tag(inner) == NUM) {
    #####:  283:        fprintf(out, "%u", term_val(inner));
        -:  284:      } else {
    #####:  285:        omni_print_value_to(out, inner);
        -:  286:      }
    #####:  287:      return;
        -:  288:    }
        -:  289:
        -:  290:    // #True{} - boolean true
    #####:  291:    if (ext == OMNI_NAM_TRUE) {
    #####:  292:      fprintf(out, "true");
    #####:  293:      return;
        -:  294:    }
        -:  295:
        -:  296:    // #Fals{} - boolean false
    #####:  297:    if (ext == OMNI_NAM_FALS) {
    #####:  298:      fprintf(out, "false");
    #####:  299:      return;
        -:  300:    }
        -:  301:
        -:  302:    // #Noth{} - nothing
    #####:  303:    if (ext == OMNI_NAM_NOTH) {
    #####:  304:      fprintf(out, "nothing");
    #####:  305:      return;
        -:  306:    }
        -:  307:
        -:  308:    // #NIL{} - empty list
    #####:  309:    if (ext == OMNI_NAM_NIL) {
    #####:  310:      fprintf(out, "()");
    #####:  311:      return;
        -:  312:    }
        -:  313:
        -:  314:    // #CON{h, t} - cons cell (list)
    #####:  315:    if (ext == OMNI_NAM_CON) {
    #####:  316:      omni_print_list_to(out, t);
    #####:  317:      return;
        -:  318:    }
        -:  319:
        -:  320:    // #Sym{nick} - symbol
    #####:  321:    if (ext == OMNI_NAM_SYM) {
        -:  322:      char name[64];
    #####:  323:      Term nick_term = HEAP[val];
    #####:  324:      u32 nick = term_tag(nick_term) == NUM ? term_val(nick_term) : term_ext(nick_term);
    #####:  325:      nick_to_str(nick, name, sizeof(name));
    #####:  326:      fprintf(out, "%s", name);
    #####:  327:      return;
        -:  328:    }
        -:  329:
        -:  330:    // #Str{...} - string (nick-encoded)
    #####:  331:    if (ext == OMNI_NAM_STR) {
    #####:  332:      Term str_nick = HEAP[val];
    #####:  333:      if (term_tag(str_nick) == NUM) {
        -:  334:        char str[256];
    #####:  335:        nick_to_str(term_val(str_nick), str, sizeof(str));
    #####:  336:        fprintf(out, "\"%s\"", str);
        -:  337:      } else {
    #####:  338:        fprintf(out, "\"...\"");
        -:  339:      }
    #####:  340:      return;
        -:  341:    }
        -:  342:
        -:  343:    // #Lam{body} - lambda
    #####:  344:    if (ext == OMNI_NAM_LAM) {
    #####:  345:      fprintf(out, "<lambda>");
    #####:  346:      return;
        -:  347:    }
        -:  348:
        -:  349:    // #Clo{env, body} - closure
    #####:  350:    if (ext == OMNI_NAM_CLO) {
    #####:  351:      fprintf(out, "<closure>");
    #####:  352:      return;
        -:  353:    }
        -:  354:
        -:  355:    // #CloR{marker, body} - recursive closure
    #####:  356:    if (ext == OMNI_NAM_CLOR) {
    #####:  357:      fprintf(out, "<function>");
    #####:  358:      return;
        -:  359:    }
        -:  360:
        -:  361:    // #Meth{...} - method
    #####:  362:    if (ext == OMNI_NAM_METH) {
    #####:  363:      fprintf(out, "<method>");
    #####:  364:      return;
        -:  365:    }
        -:  366:
        -:  367:    // #GFun{name, methods} - generic function
    #####:  368:    if (ext == OMNI_NAM_GFUN) {
    #####:  369:      fprintf(out, "<function>");
    #####:  370:      return;
        -:  371:    }
        -:  372:
        -:  373:    // #Prnt{msg} - print result (show the value)
    #####:  374:    if (ext == OMNI_NAM_PRNT || ext == OMNI_NAM_PRNL) {
    #####:  375:      omni_print_value_to(out, HEAP[val]);
    #####:  376:      return;
        -:  377:    }
        -:  378:
        -:  379:    // #Err{msg} - error
    #####:  380:    if (ext == OMNI_NAM_ERR) {
    #####:  381:      fprintf(out, "Error: ");
    #####:  382:      omni_print_value_to(out, HEAP[val]);
    #####:  383:      return;
        -:  384:    }
        -:  385:
        -:  386:    // Default: show as #Name{...}
        -:  387:    char name[16];
    #####:  388:    nick_to_str(ext, name, sizeof(name));
    #####:  389:    fprintf(out, "#%s", name);
    #####:  390:    if (tag > C00) {
    #####:  391:      fprintf(out, "{");
    #####:  392:      u32 arity = tag - C00;
    #####:  393:      for (u32 i = 0; i < arity && i < 3; i++) {
    #####:  394:        if (i > 0) fprintf(out, ", ");
    #####:  395:        omni_print_value_to(out, HEAP[val + i]);
        -:  396:      }
    #####:  397:      if (arity > 3) fprintf(out, ", ...");
    #####:  398:      fprintf(out, "}");
        -:  399:    }
    #####:  400:    return;
        -:  401:  }
        -:  402:
        -:  403:  // References
    #####:  404:  if (tag == REF) {
    #####:  405:    char *name = TABLE[ext];
    #####:  406:    if (name) {
    #####:  407:      fprintf(out, "%s", name);
        -:  408:    } else {
    #####:  409:      fprintf(out, "@%u", ext);
        -:  410:    }
    #####:  411:    return;
        -:  412:  }
        -:  413:
        -:  414:  // Variables
    #####:  415:  if (tag == VAR) {
    #####:  416:    fprintf(out, "v%u", val);
    #####:  417:    return;
        -:  418:  }
        -:  419:
        -:  420:  // Default
    #####:  421:  fprintf(out, "<%u:%u:%u>", tag, ext, val);
        -:  422:}
        -:  423:
    #####:  424:fn void omni_print_value(Term t) {
    #####:  425:  omni_print_value_to(stdout, t);
    #####:  426:}
        -:  427:
        -:  428:// =============================================================================
        -:  429:// Runtime Initialization
        -:  430:// =============================================================================
        -:  431:
        -:  432:// Track if runtime.hvm4 has been loaded
        -:  433:static int g_runtime_loaded = 0;
        -:  434:
        -:  435:// Helper to find runtime file in multiple locations
       32:  436:fn char* omni_find_runtime_file(const char *filename) {
        -:  437:  static char path_buf[512];
        -:  438:
        -:  439:  // Try 1: Current directory (lib/filename)
       32:  440:  snprintf(path_buf, sizeof(path_buf), "lib/%s", filename);
      32*:  441:  if (access(path_buf, R_OK) == 0) return path_buf;
        -:  442:
        -:  443:  // Try 2: Parent directory (../lib/filename) - when running from clang/
       32:  444:  snprintf(path_buf, sizeof(path_buf), "../lib/%s", filename);
       32:  445:  if (access(path_buf, R_OK) == 0) return path_buf;
        -:  446:
        -:  447:  // Try 3: Executable directory (for installed builds)
        -:  448:  // Use /proc/self/exe on Linux to get executable path
        -:  449:  char exe_path[256];
    #####:  450:  ssize_t len = readlink("/proc/self/exe", exe_path, sizeof(exe_path) - 1);
    #####:  451:  if (len > 0) {
    #####:  452:    exe_path[len] = '\0';
        -:  453:    // Find last / and truncate to get directory
    #####:  454:    char *last_slash = strrchr(exe_path, '/');
    #####:  455:    if (last_slash) {
    #####:  456:      *last_slash = '\0';
    #####:  457:      snprintf(path_buf, sizeof(path_buf), "%s/../lib/%s", exe_path, filename);
    #####:  458:      if (access(path_buf, R_OK) == 0) return path_buf;
        -:  459:    }
        -:  460:  }
        -:  461:
    #####:  462:  return NULL;
        -:  463:}
        -:  464:
        -:  465:// Load runtime.hvm4 into the HVM4 book
        -:  466:// Loads lib/prelude.hvm4 and lib/runtime.hvm4 definitions
       16:  467:fn int omni_load_runtime(void) {
      16*:  468:  if (g_runtime_loaded) return 0;  // Already loaded
        -:  469:
        -:  470:  // Find and load prelude.hvm4
       16:  471:  char *prelude_path = omni_find_runtime_file("prelude.hvm4");
       16:  472:  if (!prelude_path) {
    #####:  473:    fprintf(stderr, "Warning: Could not find lib/prelude.hvm4, using C interpreter\n");
    #####:  474:    return 1;
        -:  475:  }
        -:  476:
       16:  477:  char *prelude_src = sys_file_read(prelude_path);
       16:  478:  if (!prelude_src) {
    #####:  479:    fprintf(stderr, "Warning: Could not read %s, using C interpreter\n", prelude_path);
    #####:  480:    return 1;
        -:  481:  }
        -:  482:
       16:  483:  PState ps = {
        -:  484:    .file = prelude_path,
        -:  485:    .src  = prelude_src,
        -:  486:    .pos  = 0,
       16:  487:    .len  = (u32)strlen(prelude_src),
        -:  488:    .line = 1,
        -:  489:    .col  = 1
        -:  490:  };
       16:  491:  parse_def(&ps);
       16:  492:  free(prelude_src);
        -:  493:
        -:  494:  // Find and load runtime.hvm4
       16:  495:  char *runtime_path = omni_find_runtime_file("runtime.hvm4");
       16:  496:  if (!runtime_path) {
    #####:  497:    fprintf(stderr, "Warning: Could not find lib/runtime.hvm4, using C interpreter\n");
    #####:  498:    return 1;
        -:  499:  }
        -:  500:
       16:  501:  char *runtime_src = sys_file_read(runtime_path);
       16:  502:  if (!runtime_src) {
    #####:  503:    fprintf(stderr, "Warning: Could not read %s, using C interpreter\n", runtime_path);
    #####:  504:    return 1;
        -:  505:  }
        -:  506:
       16:  507:  PState rs = {
        -:  508:    .file = runtime_path,
        -:  509:    .src  = runtime_src,
        -:  510:    .pos  = 0,
       16:  511:    .len  = (u32)strlen(runtime_src),
        -:  512:    .line = 1,
        -:  513:    .col  = 1
        -:  514:  };
       16:  515:  parse_def(&rs);
       16:  516:  free(runtime_src);
        -:  517:
        -:  518:  // Verify critical functions are loaded
       16:  519:  u32 eval_id = table_find("omni_eval", 9);
       16:  520:  u32 menv_id = table_find("omni_menv_empty", 15);
        -:  521:
       16:  522:  if (BOOK[eval_id] == 0 || BOOK[menv_id] == 0) {
    #####:  523:    fprintf(stderr, "Warning: runtime.hvm4 missing required definitions, using C interpreter\n");
    #####:  524:    return 1;
        -:  525:  }
        -:  526:
       16:  527:  g_runtime_loaded = 1;
       16:  528:  return 0;
        -:  529:}
        -:  530:
       17:  531:fn void omni_runtime_init(void) {
        -:  532:  // Initialize HVM4 runtime
       17:  533:  thread_set_count(1);
       17:  534:  wnf_set_tid(0);
        -:  535:
        -:  536:  // Allocate global memory
       17:  537:  BOOK  = calloc(BOOK_CAP, sizeof(u32));
       17:  538:  HEAP  = calloc(HEAP_CAP, sizeof(Term));
       17:  539:  TABLE = calloc(BOOK_CAP, sizeof(char*));
        -:  540:
       17:  541:  if (!BOOK || !HEAP || !TABLE) {
    #####:  542:    fprintf(stderr, "Error: Memory allocation failed\n");
    #####:  543:    exit(1);
        -:  544:  }
       17:  545:  heap_init_slices();
        -:  546:
        -:  547:  // Initialize OmniLisp names
       17:  548:  omni_names_init();
        -:  549:
        -:  550:  // Initialize FFI
       17:  551:  omni_ffi_handle_init();
       17:  552:  omni_ffi_register_stdlib();
       17:  553:}
        -:  554:
       15:  555:fn void omni_runtime_cleanup(void) {
        -:  556:  // Cleanup FFI
       15:  557:  omni_ffi_pool_shutdown();
       15:  558:  omni_ffi_handle_cleanup();
       15:  559:}
        -:  560:
        -:  561:// =============================================================================
        -:  562:// Reduction with FFI Interception
        -:  563:// =============================================================================
        -:  564:
        -:  565:fn Term omni_reduce_with_ffi(Term t) {
        -:  566:  // Reduce to weak normal form
        -:  567:  Term result = wnf(t);
        -:  568:
        -:  569:  // Check if it's an FFI node (#FFI{name, args} has 2 args = C02)
        -:  570:  if (term_tag(result) == C02 && term_ext(result) == OMNI_NAM_FFI) {
        -:  571:    // Dispatch FFI call
        -:  572:    result = omni_ffi_dispatch(result);
        -:  573:  }
        -:  574:
        -:  575:  return result;
        -:  576:}
        -:  577:
        -:  578:// Full normalization with FFI
        -:  579:fn Term omni_normalize(Term t) {
        -:  580:  Term wnf_result = omni_reduce_with_ffi(t);
        -:  581:
        -:  582:  // Continue normalization if needed
        -:  583:  u32 tag = term_tag(wnf_result);
        -:  584:
        -:  585:  // Check if it's a constructor (C00-C16)
        -:  586:  if (tag >= C00 && tag <= C16) {
        -:  587:    u32 val = term_val(wnf_result);
        -:  588:    u32 arity = tag - C00;
        -:  589:
        -:  590:    for (u32 i = 0; i < arity; i++) {
        -:  591:      Term child = HEAP[val + i];
        -:  592:      Term normalized = omni_normalize(child);
        -:  593:      HEAP[val + i] = normalized;
        -:  594:    }
        -:  595:  }
        -:  596:
        -:  597:  return wnf_result;
        -:  598:}
        -:  599:
        -:  600:// =============================================================================
        -:  601:// Main Entry Points
        -:  602:// =============================================================================
        -:  603:
    #####:  604:fn int run_parse_only(const char *source, int debug) {
        -:  605:  OmniParse parse;
    #####:  606:  omni_parse_init(&parse, source);
        -:  607:
    #####:  608:  Term ast = omni_parse(&parse);
        -:  609:
    #####:  610:  if (parse.error) {
    #####:  611:    fprintf(stderr, "Parse error at line %u, col %u: %s\n",
        -:  612:            parse.line, parse.col, parse.error);
    #####:  613:    return 1;
        -:  614:  }
        -:  615:
    #####:  616:  print_ast(ast);
    #####:  617:  return 0;
        -:  618:}
        -:  619:
    #####:  620:fn int run_compile_only(const char *source, const char *output, int debug) {
        -:  621:  OmniParse parse;
    #####:  622:  omni_parse_init(&parse, source);
        -:  623:
    #####:  624:  Term ast = omni_parse(&parse);
        -:  625:
    #####:  626:  if (parse.error) {
    #####:  627:    fprintf(stderr, "Parse error at line %u, col %u: %s\n",
        -:  628:            parse.line, parse.col, parse.error);
    #####:  629:    return 1;
        -:  630:  }
        -:  631:
    #####:  632:  FILE *out = stdout;
    #####:  633:  if (output) {
    #####:  634:    out = fopen(output, "w");
    #####:  635:    if (!out) {
    #####:  636:      fprintf(stderr, "Error: Cannot create output file '%s'\n", output);
    #####:  637:      return 1;
        -:  638:    }
        -:  639:  }
        -:  640:
        -:  641:  // Emit HVM4 code
    #####:  642:  fprintf(out, "// Generated HVM4 code from OmniLisp\n\n");
    #####:  643:  omni_compile_emit(out, ast);
    #####:  644:  fprintf(out, "\n// Entry point\n");
    #####:  645:  fprintf(out, "@main = @omni_run(@omni_main)\n");
        -:  646:
    #####:  647:  if (output) {
    #####:  648:    fclose(out);
    #####:  649:    printf("Compiled to: %s\n", output);
        -:  650:  }
        -:  651:
    #####:  652:  return 0;
        -:  653:}
        -:  654:
       17:  655:fn int run_evaluate(const char *source, int collapse_limit, int stats, int debug, int hvm4_print) {
        -:  656:  OmniParse parse;
       17:  657:  omni_parse_init(&parse, source);
        -:  658:
       17:  659:  Term ast = omni_parse(&parse);
        -:  660:
       16:  661:  if (parse.error) {
    #####:  662:    fprintf(stderr, "Parse error at line %u, col %u: %s\n",
        -:  663:            parse.line, parse.col, parse.error);
    #####:  664:    return 1;
        -:  665:  }
        -:  666:
       16:  667:  if (debug) {
    #####:  668:    printf("AST:\n");
    #####:  669:    print_ast(ast);
    #####:  670:    printf("\nEvaluating...\n\n");
        -:  671:  }
        -:  672:
        -:  673:  // Load runtime.hvm4 if not already loaded
       16:  674:  int runtime_err = omni_load_runtime();
        -:  675:
        -:  676:  Term result;
        -:  677:
       31:  678:  if (runtime_err == 0 && g_runtime_loaded) {
        -:  679:    // Use the HVM4-based interpreter from runtime.hvm4
        -:  680:
        -:  681:    // Look up @omni_eval and @omni_menv_empty
       16:  682:    u32 eval_id = table_find("omni_eval", 9);
       16:  683:    u32 menv_id = table_find("omni_menv_empty", 15);
        -:  684:
       16:  685:    if (BOOK[eval_id] == 0 || BOOK[menv_id] == 0) {
    #####:  686:      fprintf(stderr, "Error: runtime.hvm4 missing required definitions\n");
    #####:  687:      return 1;
        -:  688:    }
        -:  689:
        -:  690:    // Build: @omni_eval(@omni_menv_empty)(ast)
       16:  691:    Term eval_ref = term_new_ref(eval_id);
       16:  692:    Term menv_ref = term_new_ref(menv_id);
        -:  693:
        -:  694:    // @omni_eval(@omni_menv_empty)
       16:  695:    Term eval_with_menv = term_new_app(eval_ref, menv_ref);
        -:  696:
        -:  697:    // @omni_eval(@omni_menv_empty)(ast)
       16:  698:    Term eval_expr = term_new_app(eval_with_menv, ast);
        -:  699:
        -:  700:    // Evaluate to normal form
       16:  701:    result = eval_normalize(eval_expr);
        -:  702:  } else {
        -:  703:    // Runtime is required - no fallback interpreter
    #####:  704:    fprintf(stderr, "Error: runtime.hvm4 failed to load - cannot evaluate\n");
    #####:  705:    return 1;
        -:  706:  }
        -:  707:
       15:  708:  printf("Result: ");
       15:  709:  if (hvm4_print) {
        -:  710:    // Use HVM4's print_term for coverage testing
       15:  711:    print_term(result);
        -:  712:  } else {
    #####:  713:    omni_print_value(result);
        -:  714:  }
       15:  715:  printf("\n");
        -:  716:
       15:  717:  if (stats) {
    #####:  718:    printf("\nStatistics:\n");
    #####:  719:    printf("  Handles allocated: %u\n", omni_ffi_handle_count());
    #####:  720:    printf("  Interactions: %llu\n", (unsigned long long)wnf_itrs_total());
        -:  721:  }
        -:  722:
       15:  723:  return 0;
        -:  724:}
        -:  725:
        -:  726:// =============================================================================
        -:  727:// REPL - Interactive Read-Eval-Print Loop
        -:  728:// =============================================================================
        -:  729:
        -:  730:#define REPL_BUFFER_SIZE 4096
        -:  731:
        -:  732:// Evaluate a single expression and write result to output
        -:  733:// Returns result string (caller must free) or NULL on error
    #####:  734:fn char* eval_to_string(const char *source, int debug) {
        -:  735:  OmniParse parse;
    #####:  736:  omni_parse_init(&parse, source);
        -:  737:
    #####:  738:  Term ast = omni_parse(&parse);
        -:  739:
    #####:  740:  if (parse.error) {
    #####:  741:    char *err = (char*)malloc(256);
    #####:  742:    snprintf(err, 256, "Parse error at line %u, col %u: %s",
        -:  743:             parse.line, parse.col, parse.error);
    #####:  744:    return err;
        -:  745:  }
        -:  746:
        -:  747:  // Load runtime if not loaded
    #####:  748:  omni_load_runtime();
        -:  749:
        -:  750:  Term result;
        -:  751:
    #####:  752:  if (!g_runtime_loaded) {
    #####:  753:    return strdup("Error: runtime.hvm4 failed to load");
        -:  754:  }
        -:  755:
        -:  756:  // Use the HVM4 interpreter
    #####:  757:  u32 eval_id = table_find("omni_eval", 9);
    #####:  758:  u32 menv_id = table_find("omni_menv_empty", 15);
        -:  759:
    #####:  760:  if (BOOK[eval_id] == 0 || BOOK[menv_id] == 0) {
    #####:  761:    return strdup("Error: runtime.hvm4 missing required definitions");
        -:  762:  }
        -:  763:
    #####:  764:  Term eval_ref = term_new_ref(eval_id);
    #####:  765:  Term menv_ref = term_new_ref(menv_id);
    #####:  766:  Term eval_with_menv = term_new_app(eval_ref, menv_ref);
    #####:  767:  Term eval_expr = term_new_app(eval_with_menv, ast);
    #####:  768:  result = eval_normalize(eval_expr);
        -:  769:
        -:  770:  // Convert result to string using user-friendly printer
    #####:  771:  char *buf = (char*)malloc(REPL_BUFFER_SIZE);
    #####:  772:  FILE *memstream = fmemopen(buf, REPL_BUFFER_SIZE - 1, "w");
    #####:  773:  if (!memstream) {
    #####:  774:    free(buf);
    #####:  775:    return strdup("Error: failed to create output stream");
        -:  776:  }
        -:  777:
    #####:  778:  omni_print_value_to(memstream, result);
    #####:  779:  fclose(memstream);
        -:  780:
    #####:  781:  return buf;
        -:  782:}
        -:  783:
    #####:  784:fn int run_repl(int debug) {
        -:  785:  char input[REPL_BUFFER_SIZE];
        -:  786:  char *line;
        -:  787:
    #####:  788:  printf("OmniLisp REPL v0.1.0\n");
    #####:  789:  printf("Type expressions to evaluate. Ctrl+D to exit.\n\n");
        -:  790:
    #####:  791:  while (g_running) {
    #####:  792:    printf("λ> ");
    #####:  793:    fflush(stdout);
        -:  794:
    #####:  795:    line = fgets(input, REPL_BUFFER_SIZE, stdin);
    #####:  796:    if (!line) {
        -:  797:      // EOF (Ctrl+D)
    #####:  798:      printf("\nBye!\n");
    #####:  799:      break;
        -:  800:    }
        -:  801:
        -:  802:    // Skip empty lines
    #####:  803:    size_t len = strlen(line);
    #####:  804:    if (len == 0 || (len == 1 && line[0] == '\n')) {
    #####:  805:      continue;
        -:  806:    }
        -:  807:
        -:  808:    // Remove trailing newline
    #####:  809:    if (len > 0 && line[len-1] == '\n') {
    #####:  810:      line[len-1] = '\0';
        -:  811:    }
        -:  812:
        -:  813:    // Special commands
    #####:  814:    if (strcmp(line, ":q") == 0 || strcmp(line, ":quit") == 0) {
    #####:  815:      printf("Bye!\n");
    #####:  816:      break;
        -:  817:    }
    #####:  818:    if (strcmp(line, ":h") == 0 || strcmp(line, ":help") == 0) {
    #####:  819:      printf("Commands:\n");
    #####:  820:      printf("  :q, :quit   Exit REPL\n");
    #####:  821:      printf("  :h, :help   Show this help\n");
    #####:  822:      printf("  :c, :clear  Clear screen\n");
    #####:  823:      printf("\n");
    #####:  824:      continue;
        -:  825:    }
    #####:  826:    if (strcmp(line, ":c") == 0 || strcmp(line, ":clear") == 0) {
    #####:  827:      printf("\033[2J\033[H");  // ANSI clear screen
    #####:  828:      continue;
        -:  829:    }
        -:  830:
        -:  831:    // Evaluate expression
    #####:  832:    char *result = eval_to_string(line, debug);
    #####:  833:    if (result) {
    #####:  834:      printf("%s\n", result);
    #####:  835:      free(result);
        -:  836:    }
        -:  837:  }
        -:  838:
    #####:  839:  return 0;
        -:  840:}
        -:  841:
        -:  842:// =============================================================================
        -:  843:// Socket Server - For Editor Integration (neovim, etc.)
        -:  844:// =============================================================================
        -:  845://
        -:  846:// Protocol:
        -:  847://   Client sends: <expression>\n
        -:  848://   Server sends: <result>\x00\n  (null byte marks end of result)
        -:  849://
        -:  850:// The null byte allows multi-line results while still having a clear delimiter.
        -:  851:// Neovim/editors can read until they see \x00\n to know the response is complete.
        -:  852:
    #####:  853:fn int handle_client(int client_fd, int debug) {
        -:  854:  char buffer[REPL_BUFFER_SIZE];
        -:  855:  ssize_t bytes_read;
        -:  856:
    #####:  857:  while (g_running) {
    #####:  858:    bytes_read = recv(client_fd, buffer, REPL_BUFFER_SIZE - 1, 0);
    #####:  859:    if (bytes_read <= 0) {
        -:  860:      // Client disconnected or error
    #####:  861:      break;
        -:  862:    }
        -:  863:
    #####:  864:    buffer[bytes_read] = '\0';
        -:  865:
        -:  866:    // Remove trailing newline
    #####:  867:    if (bytes_read > 0 && buffer[bytes_read - 1] == '\n') {
    #####:  868:      buffer[bytes_read - 1] = '\0';
        -:  869:    }
        -:  870:
        -:  871:    // Skip empty input
    #####:  872:    if (strlen(buffer) == 0) {
    #####:  873:      continue;
        -:  874:    }
        -:  875:
        -:  876:    // Special: :ping for keepalive
    #####:  877:    if (strcmp(buffer, ":ping") == 0) {
    #####:  878:      send(client_fd, "pong\0\n", 6, 0);
    #####:  879:      continue;
        -:  880:    }
        -:  881:
        -:  882:    // Evaluate and send result
    #####:  883:    char *result = eval_to_string(buffer, debug);
    #####:  884:    if (result) {
    #####:  885:      send(client_fd, result, strlen(result), 0);
    #####:  886:      free(result);
        -:  887:    } else {
    #####:  888:      send(client_fd, "Error: evaluation failed", 24, 0);
        -:  889:    }
        -:  890:
        -:  891:    // Send delimiter: null byte + newline
    #####:  892:    send(client_fd, "\0\n", 2, 0);
        -:  893:  }
        -:  894:
    #####:  895:  close(client_fd);
    #####:  896:  return 0;
        -:  897:}
        -:  898:
    #####:  899:fn int run_server(int port, int debug) {
        -:  900:  int server_fd, client_fd;
        -:  901:  struct sockaddr_in address;
    #####:  902:  int opt = 1;
    #####:  903:  socklen_t addrlen = sizeof(address);
        -:  904:
        -:  905:  // Create socket
    #####:  906:  server_fd = socket(AF_INET, SOCK_STREAM, 0);
    #####:  907:  if (server_fd < 0) {
    #####:  908:    perror("socket failed");
    #####:  909:    return 1;
        -:  910:  }
        -:  911:
        -:  912:  // Allow address reuse
    #####:  913:  if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
    #####:  914:    perror("setsockopt failed");
    #####:  915:    close(server_fd);
    #####:  916:    return 1;
        -:  917:  }
        -:  918:
        -:  919:  // Bind to port
    #####:  920:  address.sin_family = AF_INET;
    #####:  921:  address.sin_addr.s_addr = INADDR_ANY;
    #####:  922:  address.sin_port = htons(port);
        -:  923:
    #####:  924:  if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
    #####:  925:    perror("bind failed");
    #####:  926:    close(server_fd);
    #####:  927:    return 1;
        -:  928:  }
        -:  929:
        -:  930:  // Listen
    #####:  931:  if (listen(server_fd, 3) < 0) {
    #####:  932:    perror("listen failed");
    #####:  933:    close(server_fd);
    #####:  934:    return 1;
        -:  935:  }
        -:  936:
    #####:  937:  printf("OmniLisp server listening on port %d\n", port);
    #####:  938:  printf("Connect with: nc localhost %d\n", port);
    #####:  939:  printf("Or from neovim: :lua vim.fn.sockconnect('tcp', 'localhost:%d')\n", port);
    #####:  940:  printf("Press Ctrl+C to stop.\n\n");
        -:  941:
        -:  942:  // Setup signal handler for graceful shutdown
    #####:  943:  signal(SIGINT, signal_handler);
    #####:  944:  signal(SIGTERM, signal_handler);
        -:  945:
    #####:  946:  while (g_running) {
        -:  947:    // Use poll to allow checking g_running periodically
    #####:  948:    struct pollfd pfd = {server_fd, POLLIN, 0};
    #####:  949:    int poll_result = poll(&pfd, 1, 1000);  // 1 second timeout
        -:  950:
    #####:  951:    if (poll_result < 0) {
    #####:  952:      if (errno == EINTR) continue;  // Interrupted by signal
    #####:  953:      perror("poll failed");
    #####:  954:      break;
        -:  955:    }
        -:  956:
    #####:  957:    if (poll_result == 0) {
    #####:  958:      continue;  // Timeout, check g_running and loop
        -:  959:    }
        -:  960:
        -:  961:    // Accept connection
    #####:  962:    client_fd = accept(server_fd, (struct sockaddr*)&address, &addrlen);
    #####:  963:    if (client_fd < 0) {
    #####:  964:      if (errno == EINTR) continue;
    #####:  965:      perror("accept failed");
    #####:  966:      continue;
        -:  967:    }
        -:  968:
    #####:  969:    printf("Client connected from %s:%d\n",
    #####:  970:           inet_ntoa(address.sin_addr), ntohs(address.sin_port));
        -:  971:
        -:  972:    // Handle client (single-threaded for simplicity)
    #####:  973:    handle_client(client_fd, debug);
        -:  974:
    #####:  975:    printf("Client disconnected\n");
        -:  976:  }
        -:  977:
    #####:  978:  printf("\nShutting down server...\n");
    #####:  979:  close(server_fd);
    #####:  980:  return 0;
        -:  981:}
        -:  982:
        -:  983:// =============================================================================
        -:  984:// Main
        -:  985:// =============================================================================
        -:  986:
       17:  987:int main(int argc, char *argv[]) {
       17:  988:  OmniOptions opts = parse_options(argc, argv);
        -:  989:
       17:  990:  if (opts.help) {
    #####:  991:    print_usage(argv[0]);
    #####:  992:    return 0;
        -:  993:  }
        -:  994:
       17:  995:  if (opts.version) {
    #####:  996:    print_version();
    #####:  997:    return 0;
        -:  998:  }
        -:  999:
        -: 1000:  // Initialize runtime
       17: 1001:  omni_runtime_init();
        -: 1002:
       17: 1003:  int result = 0;
        -: 1004:
       17: 1005:  if (opts.server_port > 0) {
        -: 1006:    // Socket server mode
    #####: 1007:    result = run_server(opts.server_port, opts.debug);
       17: 1008:  } else if (opts.interactive) {
        -: 1009:    // Interactive REPL mode
    #####: 1010:    result = run_repl(opts.debug);
       17: 1011:  } else if (opts.eval_mode && opts.expr) {
        -: 1012:    // Evaluate expression
       17: 1013:    if (opts.parse_only) {
    #####: 1014:      result = run_parse_only(opts.expr, opts.debug);
       17: 1015:    } else if (opts.compile_only) {
    #####: 1016:      result = run_compile_only(opts.expr, opts.output, opts.debug);
        -: 1017:    } else {
       17: 1018:      result = run_evaluate(opts.expr, opts.collapse, opts.stats, opts.debug, opts.hvm4_print);
        -: 1019:    }
    #####: 1020:  } else if (opts.file) {
        -: 1021:    // Process file
    #####: 1022:    char *source = read_file(opts.file);
    #####: 1023:    if (!source) {
    #####: 1024:      result = 1;
        -: 1025:    } else {
    #####: 1026:      if (opts.parse_only) {
    #####: 1027:        result = run_parse_only(source, opts.debug);
    #####: 1028:      } else if (opts.compile_only) {
    #####: 1029:        result = run_compile_only(source, opts.output, opts.debug);
        -: 1030:      } else {
    #####: 1031:        result = run_evaluate(source, opts.collapse, opts.stats, opts.debug, opts.hvm4_print);
        -: 1032:      }
    #####: 1033:      free(source);
        -: 1034:    }
        -: 1035:  } else {
        -: 1036:    // No input - start interactive REPL by default
    #####: 1037:    result = run_repl(opts.debug);
        -: 1038:  }
        -: 1039:
        -: 1040:  // Cleanup
       15: 1041:  omni_runtime_cleanup();
        -: 1042:
       15: 1043:  return result;
        -: 1044:}
        -: 1045:
