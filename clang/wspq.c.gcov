        -:    0:Source:../hvm4/clang/data/wspq.c
        -:    0:Graph:main-cov-main.gcno
        -:    0:Data:main-cov-main.gcda
        -:    0:Runs:422
        -:    1:// data/wspq.c - work-stealing key queue built on wsq buckets.
        -:    2://
        -:    3:// Context
        -:    4:// - Used by eval_collapse for parallel CNF enumeration.
        -:    5:// - Lower numeric keys are popped first.
        -:    6://
        -:    7:// Design
        -:    8:// - Key "key" is bucketed by (key >> WSPQ_KEY_SHIFT).
        -:    9:// - A per-worker bitmask tracks which buckets are non-empty.
        -:   10:// - Local pop takes the lowest-index non-empty bucket (best key).
        -:   11:// - Single-threaded pop uses FIFO order within a bucket for determinism.
        -:   12:// - Steal prefers lower-key work and can be restricted to shallower buckets.
        -:   13://
        -:   14:// Notes
        -:   15:// - Tasks are u64 values; key is an 8-bit hint.
        -:   16:// - Not a general multi-producer queue: each worker pushes to its own bank.
        -:   17:// - wsq buffers are fixed size; push spins if a bucket is temporarily full.
        -:   18:
        -:   19:#include <stdatomic.h>
        -:   20:#include <stdbool.h>
        -:   21:#include <stddef.h>
        -:   22:
        -:   23:// Number of key buckets (must be <= 64 for the bitmask).
        -:   24:#ifndef WSPQ_BRACKETS
        -:   25:#define WSPQ_BRACKETS 64u
        -:   26:#endif
        -:   27:
        -:   28:// Key right shift to map key -> bucket index.
        -:   29:#ifndef WSPQ_KEY_SHIFT
        -:   30:#define WSPQ_KEY_SHIFT 0u
        -:   31:#endif
        -:   32:
        -:   33:// Per-bucket deque capacity (log2).
        -:   34:#ifndef WSPQ_CAP_POW2
        -:   35:#define WSPQ_CAP_POW2 21u
        -:   36:#endif
        -:   37:
        -:   38:// Number of victim attempts per steal call.
        -:   39:#ifndef WSPQ_STEAL_ATTEMPTS
        -:   40:#define WSPQ_STEAL_ATTEMPTS 2u
        -:   41:#endif
        -:   42:
        -:   43:// Per-worker bank of key deques plus a non-empty bucket mask.
        -:   44:typedef struct __attribute__((aligned(256))) {
        -:   45:  WsDeque q[WSPQ_BRACKETS];
        -:   46:  _Atomic u64 nonempty;
        -:   47:} WspqBank;
        -:   48:
        -:   49:// Work-stealing key queue state for all workers.
        -:   50:typedef struct {
        -:   51:  WspqBank bank[MAX_THREADS];
        -:   52:  u32 n;
        -:   53:} Wspq;
        -:   54:
        -:   55:// Return index of least-significant set bit (undefined for m == 0).
    #####:   56:static inline u32 wspq_lsb64(u64 m) {
    #####:   57:  return (u32)__builtin_ctzll(m);
        -:   58:}
        -:   59:
        -:   60:// Mark a bucket as non-empty in the owner's mask.
    #####:   61:static inline void wspq_mask_set(Wspq *ws, u32 tid, u32 b) {
    #####:   62:  atomic_fetch_or_explicit(&ws->bank[tid].nonempty, (1ull << b), memory_order_relaxed);
    #####:   63:}
        -:   64:
        -:   65:// Clear a bucket in the owner's mask (used after observing it empty).
    #####:   66:static inline void wspq_mask_clear_owner(Wspq *ws, u32 tid, u32 b) {
    #####:   67:  atomic_fetch_and_explicit(&ws->bank[tid].nonempty, ~(1ull << b), memory_order_relaxed);
    #####:   68:}
        -:   69:
        -:   70:// Map a key value to a bucket index.
    #####:   71:static inline u8 wspq_key_bucket(u32 key) {
    #####:   72:  u32 bucket = key >> WSPQ_KEY_SHIFT;
    #####:   73:  if (bucket >= WSPQ_BRACKETS) {
    #####:   74:    return (u8)(WSPQ_BRACKETS - 1u);
        -:   75:  }
    #####:   76:  return (u8)bucket;
        -:   77:}
        -:   78:
        -:   79:// Initialize all per-worker bucket queues.
        -:   80:static inline bool wspq_init(Wspq *ws, u32 nthreads) {
        -:   81:  ws->n = nthreads;
        -:   82:
        -:   83:  for (u32 t = 0; t < nthreads; ++t) {
        -:   84:    atomic_store_explicit(&ws->bank[t].nonempty, 0ull, memory_order_relaxed);
        -:   85:    for (u32 b = 0; b < WSPQ_BRACKETS; ++b) {
        -:   86:      if (!wsq_init(&ws->bank[t].q[b], WSPQ_CAP_POW2)) {
        -:   87:        for (u32 t2 = 0; t2 <= t; ++t2) {
        -:   88:          u32 bmax = WSPQ_BRACKETS;
        -:   89:          if (t2 == t) {
        -:   90:            bmax = b;
        -:   91:          }
        -:   92:          for (u32 b2 = 0; b2 < bmax; ++b2) {
        -:   93:            wsq_free(&ws->bank[t2].q[b2]);
        -:   94:          }
        -:   95:        }
        -:   96:        return false;
        -:   97:      }
        -:   98:    }
        -:   99:  }
        -:  100:  return true;
        -:  101:}
        -:  102:
        -:  103:// Free all per-worker bucket queues.
        -:  104:static inline void wspq_free(Wspq *ws) {
        -:  105:  for (u32 t = 0; t < ws->n; ++t) {
        -:  106:    for (u32 b = 0; b < WSPQ_BRACKETS; ++b) {
        -:  107:      wsq_free(&ws->bank[t].q[b]);
        -:  108:    }
        -:  109:  }
        -:  110:}
        -:  111:
        -:  112:// Push a task into the owner's bucket; spins until the bucket accepts it.
    #####:  113:static inline void wspq_push(Wspq *ws, u32 tid, u8 key, u64 task) {
    #####:  114:  if (task == 0) {
    #####:  115:    return;
        -:  116:  }
    #####:  117:  u8 bucket = wspq_key_bucket(key);
    #####:  118:  WsDeque *q = &ws->bank[tid].q[bucket];
    #####:  119:  while (!wsq_push(q, task)) {
    #####:  120:    cpu_relax();
        -:  121:  }
    #####:  122:  wspq_mask_set(ws, tid, bucket);
        -:  123:}
        -:  124:
        -:  125:// Pop the best-key local task; returns false if none are available.
    #####:  126:static inline bool wspq_pop(Wspq *ws, u32 tid, u8 *key, u64 *task) {
    #####:  127:  u64 m = atomic_load_explicit(&ws->bank[tid].nonempty, memory_order_relaxed);
    #####:  128:  if (m == 0ull) {
    #####:  129:    return false;
        -:  130:  }
    #####:  131:  bool fifo = (ws->n == 1);
    #####:  132:  while (m) {
    #####:  133:    u32 b = wspq_lsb64(m);
    #####:  134:    u64 x = 0;
    #####:  135:    if (fifo ? wsq_steal(&ws->bank[tid].q[b], &x) : wsq_pop(&ws->bank[tid].q[b], &x)) {
    #####:  136:      *key = (u8)(b << WSPQ_KEY_SHIFT);
    #####:  137:      *task = x;
    #####:  138:      return true;
        -:  139:    }
    #####:  140:    wspq_mask_clear_owner(ws, tid, b);
    #####:  141:    m &= (m - 1ull);
        -:  142:  }
    #####:  143:  return false;
        -:  144:}
        -:  145:
        -:  146:// Steal up to max_batch tasks from other workers, favoring lower keys.
    #####:  147:static inline u32 wspq_steal_some(
        -:  148:  Wspq *ws,
        -:  149:  u32     me,
        -:  150:  u32     max_batch,
        -:  151:  bool    restrict_deeper,
        -:  152:  u32    *cursor
        -:  153:) {
    #####:  154:  u32 n = ws->n;
    #####:  155:  if (n <= 1) {
    #####:  156:    return 0u;
        -:  157:  }
        -:  158:
    #####:  159:  u64 my_mask = atomic_load_explicit(&ws->bank[me].nonempty, memory_order_relaxed);
    #####:  160:  u32 my_min = WSPQ_BRACKETS;
    #####:  161:  if (my_mask != 0ull) {
    #####:  162:    my_min = wspq_lsb64(my_mask);
        -:  163:  }
        -:  164:
    #####:  165:  u32 b_limit = WSPQ_BRACKETS;
    #####:  166:  if (restrict_deeper && my_min < b_limit) {
    #####:  167:    b_limit = my_min;
        -:  168:  }
        -:  169:
    #####:  170:  u64 allowed_mask = ~0ull;
    #####:  171:  if (b_limit < WSPQ_BRACKETS) {
    #####:  172:    allowed_mask = (1ull << b_limit) - 1ull;
        -:  173:  }
        -:  174:
    #####:  175:  u32 start = *cursor;
    #####:  176:  for (u32 k = 0; k < WSPQ_STEAL_ATTEMPTS; ++k) {
    #####:  177:    u32 v = (start + k) % n;
    #####:  178:    if (v == me) {
    #####:  179:      continue;
        -:  180:    }
    #####:  181:    u64 nm = atomic_load_explicit(&ws->bank[v].nonempty, memory_order_relaxed);
    #####:  182:    nm &= allowed_mask;
    #####:  183:    if (nm == 0ull) {
    #####:  184:      continue;
        -:  185:    }
    #####:  186:    u32 b = wspq_lsb64(nm);
    #####:  187:    u32 got = 0;
    #####:  188:    u64 x = 0;
    #####:  189:    if (!wsq_steal(&ws->bank[v].q[b], &x)) {
    #####:  190:      continue;
        -:  191:    }
    #####:  192:    wspq_push(ws, me, (u8)(b << WSPQ_KEY_SHIFT), x);
    #####:  193:    got += 1u;
    #####:  194:    for (; got < max_batch; ++got) {
    #####:  195:      if (!wsq_steal(&ws->bank[v].q[b], &x)) {
    #####:  196:        break;
        -:  197:      }
    #####:  198:      wspq_push(ws, me, (u8)(b << WSPQ_KEY_SHIFT), x);
        -:  199:    }
    #####:  200:    *cursor = v + 1;
    #####:  201:    return got;
        -:  202:  }
    #####:  203:  *cursor = start + WSPQ_STEAL_ATTEMPTS;
    #####:  204:  return 0u;
        -:  205:}
