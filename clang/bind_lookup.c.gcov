        -:    0:Source:../hvm4/clang/parse/bind_lookup.c
        -:    0:Graph:main-cov-main.gcno
        -:    0:Data:main-cov-main.gcda
        -:    0:Runs:9
    29880:    1:fn void parse_bind_lookup(u32 name, u32 depth, int *lvl, u32 *lab, u32 *kind, u32 *cloned) {
        -:    2:  (void)depth;
    91998:    3:  for (int i = PARSE_BINDS_LEN - 1; i >= 0; i--) {
    91998:    4:    if (PARSE_BINDS[i].name == name) {
    29880:    5:      *lvl = (int)PARSE_BINDS[i].depth + 1;
    29880:    6:      *lab = PARSE_BINDS[i].lab;
    29880:    7:      *kind = PARSE_BINDS[i].kind;
    29880:    8:      *cloned = PARSE_BINDS[i].cloned;
    29880:    9:      PARSE_BINDS[i].uses++;
    29880:   10:      return;
        -:   11:    }
        -:   12:  }
    #####:   13:  *lvl = -1;
    #####:   14:  *lab = 0;
    #####:   15:  *kind = 0;
    #####:   16:  *cloned = 0;
        -:   17:}
        -:   18:
        -:   19:// Lookup skipping dup bindings, for bare variable access that should fall through to outer scope
        -:   20:// Returns 1 if found, 0 if not found
    #####:   21:fn int parse_bind_lookup_skip_dup(u32 name, u32 depth, int *lvl, u32 *lab, u32 *kind, u32 *cloned) {
        -:   22:  (void)depth;
    #####:   23:  for (int i = PARSE_BINDS_LEN - 1; i >= 0; i--) {
    #####:   24:    if (PARSE_BINDS[i].name == name) {
        -:   25:      // Skip dup bindings (kind == PBIND_DUP)
    #####:   26:      if (PARSE_BINDS[i].kind == PBIND_DUP) {
    #####:   27:        continue;
        -:   28:      }
        -:   29:      // Found a non-dup binding - check if it has capacity
    #####:   30:      if (!PARSE_BINDS[i].cloned && PARSE_BINDS[i].uses >= 1) {
        -:   31:        // No capacity left
    #####:   32:        return 0;
        -:   33:      }
    #####:   34:      *lvl = (int)PARSE_BINDS[i].depth + 1;
    #####:   35:      *lab = PARSE_BINDS[i].lab;
    #####:   36:      *kind = PARSE_BINDS[i].kind;
    #####:   37:      *cloned = PARSE_BINDS[i].cloned;
    #####:   38:      PARSE_BINDS[i].uses++;
    #####:   39:      return 1;
        -:   40:    }
        -:   41:  }
    #####:   42:  return 0;
        -:   43:}
        -:   44:
        -:   45:// Increment per-side use count and return previous count
    #####:   46:fn u32 parse_bind_inc_side(u32 name, int side) {
    #####:   47:  for (int i = PARSE_BINDS_LEN - 1; i >= 0; i--) {
    #####:   48:    if (PARSE_BINDS[i].name == name) {
    #####:   49:      if (side == 0) {
    #####:   50:        return PARSE_BINDS[i].uses0++;
        -:   51:      } else {
    #####:   52:        return PARSE_BINDS[i].uses1++;
        -:   53:      }
        -:   54:    }
        -:   55:  }
    #####:   56:  return 0;
        -:   57:}
        -:   58:
    25020:   59:fn u32 parse_bind_get_uses(void) {
    25020:   60:  if (PARSE_BINDS_LEN > 0) {
    25020:   61:    return PARSE_BINDS[PARSE_BINDS_LEN - 1].uses;
        -:   62:  }
    #####:   63:  return 0;
        -:   64:}
        -:   65:
        -:   66:fn u32 parse_bind_get_uses0(void) {
        -:   67:  if (PARSE_BINDS_LEN > 0) {
        -:   68:    return PARSE_BINDS[PARSE_BINDS_LEN - 1].uses0;
        -:   69:  }
        -:   70:  return 0;
        -:   71:}
        -:   72:
        -:   73:fn u32 parse_bind_get_uses1(void) {
        -:   74:  if (PARSE_BINDS_LEN > 0) {
        -:   75:    return PARSE_BINDS[PARSE_BINDS_LEN - 1].uses1;
        -:   76:  }
        -:   77:  return 0;
        -:   78:}
        -:   79:
        -:   80:fn u32 parse_bind_is_cloned(void) {
        -:   81:  if (PARSE_BINDS_LEN > 0) {
        -:   82:    return PARSE_BINDS[PARSE_BINDS_LEN - 1].cloned;
        -:   83:  }
        -:   84:  return 0;
        -:   85:}
