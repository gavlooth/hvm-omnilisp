        -:    0:Source:../hvm4/clang/print/term.c
        -:    0:Graph:main-cov-main.gcno
        -:    0:Data:main-cov-main.gcda
        -:    0:Runs:17
        -:    1:// Pretty-printer overview
        -:    2:// - Dynamic links: LAM/VAR, DP0/DP1, and GOT point to heap locations; DUP/MOV are
        -:    3://   syntactic binders; they yield DUP/MOV nodes (DP0/DP1 and GOT share expr locs).
        -:    4:// - Static terms (inside ALO) are immutable and use BJV/BJ0/BJ1/BJM de Bruijn levels.
        -:    5:// - NAM is a literal stuck name (^x), unrelated to binders.
        -:    6:// - Dynamic printing assigns globally unique names to each LAM body location.
        -:    7:// - Dup/mov names are keyed by their node expr locations and printed after the term.
        -:    8:// - Static printing renders quoted/book terms and applies ALO substitutions.
        -:    9:// - Substitutions live in heap slots with the SUB bit set; these must be
        -:   10://   unmarked before printing, and print_term_at asserts this invariant.
        -:   11:// - Lambda names: lowercase (a, b, ..., aa, ab, ...), dup names: uppercase.
        -:   12:// - Quoted lambdas are tagged by LAM.ext = depth + 1 (linked LAM.ext = 0).
        -:   13:// - Name tables are fixed-size (PRINT_NAME_MAX) to keep the printer simple.
        -:   14:
        -:   15:typedef struct {
        -:   16:  u32 loc;
        -:   17:  u32 name;
        -:   18:} LamBind;
        -:   19:
        -:   20:// DupBind records a DUP node keyed by its expr location.
        -:   21:typedef struct {
        -:   22:  u32 loc;
        -:   23:  u32 name;
        -:   24:  u32 lab;
        -:   25:} DupBind;
        -:   26:
        -:   27:typedef struct {
        -:   28:  u32 loc;
        -:   29:  u32 name;
        -:   30:} MovBind;
        -:   31:
        -:   32:// PrintState keeps naming tables and ALO printing mode.
        -:   33:// - quoted/subst/subst_len: current printing mode, bind list head, and length.
        -:   34:// Fixed-size tables: keep naming simple and bounded.
        -:   35:#define PRINT_NAME_MAX 65536
        -:   36:static LamBind PRINT_LAMS[PRINT_NAME_MAX];
        -:   37:static DupBind PRINT_DUPS[PRINT_NAME_MAX];
        -:   38:static MovBind PRINT_MOVS[PRINT_NAME_MAX];
        -:   39:
        -:   40:typedef struct {
        -:   41:  u32 lam_len;
        -:   42:  u32 dup_len;
        -:   43:  u32 dup_print;
        -:   44:  u32 mov_len;
        -:   45:  u32 mov_print;
        -:   46:  u32 next_lam;
        -:   47:  u32 next_dup;
        -:   48:  u32 next_mov;
        -:   49:  u8  quoted;
        -:   50:  u32 subst;
        -:   51:  u32 subst_len;
        -:   52:} PrintState;
        -:   53:
        -:   54:// Core recursive printer; always called through print_term_at.
        -:   55:fn void print_term_go(FILE *f, Term term, u32 depth, PrintState *st);
        -:   56:// Guards against printing a term with the SUB bit set.
       57:   57:fn void print_term_at(FILE *f, Term term, u32 depth, PrintState *st) {
      57*:   58:  assert(!term_sub_get(term));
       57:   59:  print_term_go(f, term, depth, st);
       57:   60:}
        -:   61:
        -:   62:// Temporarily switches print mode (quoted + subst) for nested ALO rendering.
    #####:   63:fn void print_term_mode(FILE *f, Term term, u32 depth, u8 quoted, u32 subst, u32 subst_len, PrintState *st) {
    #####:   64:  u8  old_quoted = st->quoted;
    #####:   65:  u32 old_subst  = st->subst;
    #####:   66:  u32 old_len    = st->subst_len;
    #####:   67:  st->quoted = quoted;
    #####:   68:  st->subst  = subst;
    #####:   69:  st->subst_len = quoted ? subst_len : 0;
    #####:   70:  print_term_at(f, term, depth, st);
    #####:   71:  st->quoted = old_quoted;
    #####:   72:  st->subst  = old_subst;
    #####:   73:  st->subst_len = old_len;
    #####:   74:}
        -:   75:
        -:   76:// Base-26 alpha printer: 1->a, 26->z, 27->aa. 0 prints '_' for unscoped vars.
    #####:   77:fn void print_alpha_name(FILE *f, u32 n, char base) {
    #####:   78:  if (n == 0) {
    #####:   79:    fputc('_', f);
    #####:   80:    return;
        -:   81:  }
        -:   82:  char buf[32];
    #####:   83:  u32  len = 0;
    #####:   84:  while (n > 0) {
    #####:   85:    n--;
    #####:   86:    buf[len++] = (char)(base + (n % 26));
    #####:   87:    n /= 26;
        -:   88:  }
    #####:   89:  for (u32 i = 0; i < len; i++) {
    #####:   90:    fputc(buf[len - 1 - i], f);
        -:   91:  }
        -:   92:}
        -:   93:
        -:   94:// Emits a lambda name (lowercase alpha).
    #####:   95:fn void print_lam_name(FILE *f, u32 name) {
    #####:   96:  print_alpha_name(f, name, 'a');
    #####:   97:}
        -:   98:
        -:   99:// Emits a dup name (uppercase alpha).
    #####:  100:fn void print_dup_name(FILE *f, u32 name) {
    #####:  101:  print_alpha_name(f, name, 'A');
    #####:  102:}
        -:  103:
        -:  104:// Emits a mov name (uppercase alpha).
    #####:  105:fn void print_mov_name(FILE *f, u32 name) {
    #####:  106:  print_alpha_name(f, name, 'A');
    #####:  107:}
        -:  108:
        -:  109:// Initializes the printer state and name counters.
       15:  110:fn void print_state_init(PrintState *st) {
       15:  111:  memset(st, 0, sizeof(*st));
       15:  112:  st->next_lam    = 1;
       15:  113:  st->next_dup    = 1;
       15:  114:  st->next_mov    = 1;
       15:  115:}
        -:  116:
        -:  117:// No-op for fixed tables; kept for symmetry with print_state_init.
       15:  118:fn void print_state_free(PrintState *st) {
        -:  119:  (void)st;
       15:  120:}
        -:  121:
        -:  122:// Returns the global name for a lambda body location, allocating if needed.
    #####:  123:fn u32 print_state_lam(PrintState *st, u32 loc) {
    #####:  124:  for (u32 i = 0; i < st->lam_len; i++) {
    #####:  125:    if (PRINT_LAMS[i].loc == loc) {
    #####:  126:      return PRINT_LAMS[i].name;
        -:  127:    }
        -:  128:  }
    #####:  129:  if (st->lam_len >= PRINT_NAME_MAX) {
    #####:  130:    fprintf(stderr, "print_state: too many lambdas\n");
    #####:  131:    exit(1);
        -:  132:  }
    #####:  133:  u32 name = st->next_lam++;
    #####:  134:  PRINT_LAMS[st->lam_len] = (LamBind){.loc = loc, .name = name};
    #####:  135:  st->lam_len++;
    #####:  136:  return name;
        -:  137:}
        -:  138:
        -:  139:// Returns the global name for a DUP node keyed by its expr location.
    #####:  140:fn u32 print_state_dup(PrintState *st, u32 loc, u32 lab) {
    #####:  141:  for (u32 i = 0; i < st->dup_len; i++) {
    #####:  142:    if (PRINT_DUPS[i].loc == loc) {
    #####:  143:      return PRINT_DUPS[i].name;
        -:  144:    }
        -:  145:  }
    #####:  146:  if (st->dup_len >= PRINT_NAME_MAX) {
    #####:  147:    fprintf(stderr, "print_state: too many dups\n");
    #####:  148:    exit(1);
        -:  149:  }
    #####:  150:  u32 name = st->next_dup++;
    #####:  151:  PRINT_DUPS[st->dup_len] = (DupBind){.loc = loc, .name = name, .lab = lab};
    #####:  152:  st->dup_len++;
    #####:  153:  return name;
        -:  154:}
        -:  155:
        -:  156:// Returns the global name for a MOV node keyed by its expr location.
    #####:  157:fn u32 print_state_mov(PrintState *st, u32 loc) {
    #####:  158:  for (u32 i = 0; i < st->mov_len; i++) {
    #####:  159:    if (PRINT_MOVS[i].loc == loc) {
    #####:  160:      return PRINT_MOVS[i].name;
        -:  161:    }
        -:  162:  }
    #####:  163:  if (st->mov_len >= PRINT_NAME_MAX) {
    #####:  164:    fprintf(stderr, "print_state: too many movs\n");
    #####:  165:    exit(1);
        -:  166:  }
    #####:  167:  u32 name = st->next_mov++;
    #####:  168:  PRINT_MOVS[st->mov_len] = (MovBind){.loc = loc, .name = name};
    #####:  169:  st->mov_len++;
    #####:  170:  return name;
        -:  171:}
        -:  172:
        -:  173:// Looks up an ALO bind list entry by index (0 = innermost), returning a dynamic loc.
    #####:  174:fn u32 alo_subst_get(u32 ls_loc, u32 idx) {
    #####:  175:  u32 ls = ls_loc;
    #####:  176:  for (u32 i = 0; i < idx && ls != 0; i++) {
    #####:  177:    ls = (u32)(HEAP[ls] & 0xFFFFFFFF);
        -:  178:  }
    #####:  179:  return ls != 0 ? (u32)(HEAP[ls] >> 32) : 0;
        -:  180:}
        -:  181:
        -:  182:
        -:  183:// Prints match constructor labels with special sugar for nat/list forms.
    #####:  184:fn void print_mat_name(FILE *f, u32 nam) {
    #####:  185:  if (nam == NAM_ZER) {
    #####:  186:    fputs("0n", f);
    #####:  187:  } else if (nam == NAM_SUC) {
    #####:  188:    fputs("1n+", f);
    #####:  189:  } else if (nam == NAM_NIL) {
    #####:  190:    fputs("[]", f);
    #####:  191:  } else if (nam == NAM_CON) {
    #####:  192:    fputs("<>", f);
        -:  193:  } else {
    #####:  194:    fputc('#', f);
    #####:  195:    print_name(f, nam);
        -:  196:  }
    #####:  197:}
        -:  198:
        -:  199:// Prints APP/DRY spines as f(x,y,...) with a parenthesis around lambdas.
    #####:  200:fn void print_app(FILE *f, Term term, u32 depth, PrintState *st) {
        -:  201:  Term spine[256];
    #####:  202:  u32  len  = 0;
    #####:  203:  Term curr = term;
    #####:  204:  while ((term_tag(curr) == APP || term_tag(curr) == DRY) && len < 256) {
    #####:  205:    u32 loc = term_val(curr);
    #####:  206:    spine[len++] = HEAP[loc + 1];
    #####:  207:    curr = HEAP[loc];
        -:  208:  }
    #####:  209:  if (term_tag(curr) == LAM) {
    #####:  210:    fputc('(', f);
    #####:  211:    print_term_at(f, curr, depth, st);
    #####:  212:    fputc(')', f);
        -:  213:  } else {
    #####:  214:    print_term_at(f, curr, depth, st);
        -:  215:  }
    #####:  216:  fputc('(', f);
    #####:  217:  for (u32 i = 0; i < len; i++) {
    #####:  218:    if (i > 0) {
    #####:  219:      fputc(',', f);
        -:  220:    }
    #####:  221:    print_term_at(f, spine[len - 1 - i], depth, st);
        -:  222:  }
    #####:  223:  fputc(')', f);
    #####:  224:}
        -:  225:
        -:  226:// Prints constructors, with sugar for nat, char, string, and list forms.
       34:  227:fn void print_ctr(FILE *f, Term t, u32 d, PrintState *st) {
       34:  228:  u32 nam = term_ext(t), loc = term_val(t), ari = term_tag(t) - C00;
        -:  229:  // Nat: count SUCs, print as Nn or Nn+x
       34:  230:  if (nam == NAM_ZER || nam == NAM_SUC) {
    #####:  231:    u32 n = 0;
    #####:  232:    while (term_tag(t) == C01 && term_ext(t) == NAM_SUC) {
    #####:  233:      n++;
    #####:  234:      t = HEAP[term_val(t)];
        -:  235:    }
    #####:  236:    fprintf(f, "%un", n);
    #####:  237:    if (!(term_tag(t) == C00 && term_ext(t) == NAM_ZER)) {
    #####:  238:      fputc('+', f);
    #####:  239:      print_term_at(f, t, d, st);
        -:  240:    }
    #####:  241:    return;
        -:  242:  }
        -:  243:  // Char: 'x' or 'λ'
      34*:  244:  if (nam == NAM_CHR && ari == 1 && term_tag(HEAP[loc]) == NUM) {
    #####:  245:    u32 c = term_val(HEAP[loc]);
    #####:  246:    if (c >= 32 && c != 127) {
    #####:  247:      fputc('\'', f);
    #####:  248:      print_utf8(f, c);
    #####:  249:      fputc('\'', f);
    #####:  250:      return;
        -:  251:    }
        -:  252:  }
        -:  253:  // List/String
       34:  254:  if (nam == NAM_NIL || nam == NAM_CON) {
        -:  255:    // Check if string (non-empty, all printable chars including Unicode)
        5:  256:    int is_str = (nam == NAM_CON);
       5*:  257:    for (Term x = t; term_tag(x) == C02 && term_ext(x) == NAM_CON; x = HEAP[term_val(x) + 1]) {
        3:  258:      Term h = HEAP[term_val(x)];
        3:  259:      if (!(term_tag(h) == C01 && term_ext(h) == NAM_CHR)) {
        3:  260:        is_str = 0;
        3:  261:        break;
        -:  262:      }
    #####:  263:      if (term_tag(HEAP[term_val(h)]) != NUM) {
    #####:  264:        is_str = 0;
    #####:  265:        break;
        -:  266:      }
    #####:  267:      u32 c = term_val(HEAP[term_val(h)]);
    #####:  268:      if (c < 32 || c == 127) {
    #####:  269:        is_str = 0;
    #####:  270:        break;
        -:  271:      }
        -:  272:    }
        5:  273:    Term end = t;
       16:  274:    while (term_tag(end) == C02 && term_ext(end) == NAM_CON) {
       11:  275:      end = HEAP[term_val(end) + 1];
        -:  276:    }
       5*:  277:    if (is_str && term_tag(end) == C00 && term_ext(end) == NAM_NIL) {
    #####:  278:      fputc('"', f);
    #####:  279:      for (Term x = t; term_tag(x) == C02; x = HEAP[term_val(x) + 1]) {
    #####:  280:        print_utf8(f, term_val(HEAP[term_val(HEAP[term_val(x)])]));
        -:  281:      }
    #####:  282:      fputc('"', f);
    #####:  283:      return;
        -:  284:    }
        -:  285:    // Proper list: [a,b,c]
        5:  286:    if (term_tag(end) == C00 && term_ext(end) == NAM_NIL) {
        5:  287:      fputc('[', f);
       16:  288:      for (Term x = t; term_tag(x) == C02; x = HEAP[term_val(x) + 1]) {
       11:  289:        if (x != t) {
        8:  290:          fputc(',', f);
        -:  291:        }
       11:  292:        print_term_at(f, HEAP[term_val(x)], d, st);
        -:  293:      }
        5:  294:      fputc(']', f);
        5:  295:      return;
        -:  296:    }
        -:  297:    // Improper list: h<>t
    #####:  298:    if (nam == NAM_CON) {
    #####:  299:      print_term_at(f, HEAP[loc], d, st);
    #####:  300:      fputs("<>", f);
    #####:  301:      print_term_at(f, HEAP[loc + 1], d, st);
    #####:  302:      return;
        -:  303:    }
        -:  304:  }
        -:  305:  // Default CTR
       29:  306:  fputc('#', f);
       29:  307:  print_name(f, nam);
       29:  308:  fputc('{', f);
       60:  309:  for (u32 i = 0; i < ari; i++) {
       31:  310:    if (i) {
        4:  311:      fputc(',', f);
        -:  312:    }
       31:  313:    print_term_at(f, HEAP[loc + i], d, st);
        -:  314:  }
       29:  315:  fputc('}', f);
        -:  316:}
        -:  317:
        -:  318:// Recursive printer that handles both dynamic (linked) and quoted (book) terms.
       57:  319:fn void print_term_go(FILE *f, Term term, u32 depth, PrintState *st) {
       57:  320:  u8  quoted = st->quoted;
       57:  321:  u32 subst  = st->subst;
       57:  322:  switch (term_tag(term)) {
    #####:  323:    case NAM: {
        -:  324:      // Literal stuck name (^x).
    #####:  325:      print_name(f, term_ext(term));
    #####:  326:      break;
        -:  327:    }
    #####:  328:    case DRY: {
        -:  329:      // Stuck application ^(f x) rendered as f(x).
    #####:  330:      print_app(f, term, depth, st);
    #####:  331:      break;
        -:  332:    }
    #####:  333:    case BJV: {
        -:  334:      // Quoted VAR: val is de Bruijn level; try ALO substitution.
    #####:  335:      u32 lvl  = term_val(term);
    #####:  336:      u32 bind = 0;
    #####:  337:      if (quoted && lvl > 0 && lvl <= st->subst_len) {
    #####:  338:        bind = alo_subst_get(subst, st->subst_len - lvl);
        -:  339:      }
    #####:  340:      if (bind != 0) {
    #####:  341:        Term val = HEAP[bind];
    #####:  342:        if (term_sub_get(val)) {
    #####:  343:          val = term_sub_set(val, 0);
    #####:  344:          print_term_mode(f, val, depth, 0, 0, 0, st);
        -:  345:        } else {
    #####:  346:          print_term_mode(f, term_new_var(bind), depth, 0, 0, 0, st);
        -:  347:        }
        -:  348:      } else {
    #####:  349:        u32 nam = (lvl > st->subst_len) ? (lvl - st->subst_len) : 0;
    #####:  350:        if (nam > depth) {
    #####:  351:          nam = 0;
        -:  352:        }
    #####:  353:        print_alpha_name(f, nam, 'a');
        -:  354:      }
    #####:  355:      break;
        -:  356:    }
    #####:  357:    case BJM: {
        -:  358:      // Quoted MOV var: val is de Bruijn level; try ALO substitution.
    #####:  359:      u32 lvl  = term_val(term);
    #####:  360:      u32 bind = 0;
    #####:  361:      if (quoted && lvl > 0 && lvl <= st->subst_len) {
    #####:  362:        bind = alo_subst_get(subst, st->subst_len - lvl);
        -:  363:      }
    #####:  364:      if (bind != 0) {
    #####:  365:        Term val = HEAP[bind];
    #####:  366:        if (term_sub_get(val)) {
    #####:  367:          val = term_sub_set(val, 0);
    #####:  368:          print_term_mode(f, val, depth, 0, 0, 0, st);
        -:  369:        } else {
    #####:  370:          print_term_mode(f, term_new_got(bind), depth, 0, 0, 0, st);
        -:  371:        }
        -:  372:      } else {
    #####:  373:        u32 nam = (lvl > st->subst_len) ? (lvl - st->subst_len) : 0;
    #####:  374:        if (nam > depth) {
    #####:  375:          nam = 0;
        -:  376:        }
    #####:  377:        print_mov_name(f, nam);
        -:  378:      }
    #####:  379:      break;
        -:  380:    }
       23:  381:    case NUM: {
       23:  382:      fprintf(f, "%u", term_val(term));
       23:  383:      break;
        -:  384:    }
    #####:  385:    case REF: {
    #####:  386:      fputc('@', f);
    #####:  387:      char *name = table_get(term_ext(term));
    #####:  388:      if (name != NULL) {
    #####:  389:        fputs(name, f);
        -:  390:      } else {
    #####:  391:        print_name(f, term_ext(term));
        -:  392:      }
    #####:  393:      break;
        -:  394:    }
    #####:  395:    case ERA: {
    #####:  396:      fputs("&{}", f);
    #####:  397:      break;
        -:  398:    }
    #####:  399:    case ANY: {
    #####:  400:      fputc('*', f);
    #####:  401:      break;
        -:  402:    }
    #####:  403:    case BJ0:
        -:  404:    case BJ1: {
        -:  405:      // Quoted BJ_: val is de Bruijn level; try ALO substitution.
    #####:  406:      u32 lvl  = term_val(term);
    #####:  407:      u32 bind = 0;
    #####:  408:      if (quoted && lvl > 0 && lvl <= st->subst_len) {
    #####:  409:        bind = alo_subst_get(subst, st->subst_len - lvl);
        -:  410:      }
    #####:  411:      if (bind != 0) {
    #####:  412:        Term val = HEAP[bind];
    #####:  413:        if (term_sub_get(val)) {
    #####:  414:          val = term_sub_set(val, 0);
    #####:  415:          print_term_mode(f, val, depth, 0, 0, 0, st);
        -:  416:        } else {
    #####:  417:          u8  tag = term_tag(term) == BJ0 ? DP0 : DP1;
    #####:  418:          u32 lab = term_ext(term);
    #####:  419:          print_term_mode(f, term_new(0, tag, lab, bind), depth, 0, 0, 0, st);
        -:  420:        }
        -:  421:      } else {
    #####:  422:        u32 nam = (lvl > st->subst_len) ? (lvl - st->subst_len) : 0;
    #####:  423:        if (nam > depth) {
    #####:  424:          nam = 0;
        -:  425:        }
    #####:  426:        if (nam == 0) {
    #####:  427:          fputc('_', f);
        -:  428:        } else {
    #####:  429:          print_alpha_name(f, nam, 'A');
        -:  430:        }
    #####:  431:        fputs(term_tag(term) == BJ0 ? "₀" : "₁", f);
        -:  432:      }
    #####:  433:      break;
        -:  434:    }
    #####:  435:    case VAR: {
        -:  436:      // Runtime VAR: val is binding lam body location.
    #####:  437:      u32 loc = term_val(term);
    #####:  438:      if (loc != 0 && term_sub_get(HEAP[loc])) {
    #####:  439:        print_term_mode(f, term_sub_set(HEAP[loc], 0), depth, 0, 0, 0, st);
        -:  440:      } else {
    #####:  441:        u32 nam = print_state_lam(st, loc);
    #####:  442:        print_lam_name(f, nam);
        -:  443:      }
    #####:  444:      break;
        -:  445:    }
    #####:  446:    case DP0:
        -:  447:    case DP1: {
        -:  448:      // Runtime DP_: val is a DUP node expr location.
    #####:  449:      u32 loc = term_val(term);
    #####:  450:      if (loc != 0 && term_sub_get(HEAP[loc])) {
    #####:  451:        print_term_mode(f, term_sub_set(HEAP[loc], 0), depth, 0, 0, 0, st);
        -:  452:      } else {
    #####:  453:        u32 nam = print_state_dup(st, loc, term_ext(term));
    #####:  454:        print_dup_name(f, nam);
    #####:  455:        fputs(term_tag(term) == DP0 ? "₀" : "₁", f);
        -:  456:      }
    #####:  457:      break;
        -:  458:    }
    #####:  459:    case GOT: {
        -:  460:      // Runtime GOT: val is a MOV node expr location.
    #####:  461:      u32 loc = term_val(term);
    #####:  462:      if (loc != 0 && term_sub_get(HEAP[loc])) {
    #####:  463:        print_term_mode(f, term_sub_set(HEAP[loc], 0), depth, 0, 0, 0, st);
        -:  464:      } else {
    #####:  465:        u32 nam = print_state_mov(st, loc);
    #####:  466:        print_mov_name(f, nam);
        -:  467:      }
    #####:  468:      break;
        -:  469:    }
    #####:  470:    case LAM: {
        -:  471:      // Quoted mode uses depth-based names; dynamic mode uses global naming.
    #####:  472:      u32 loc = term_val(term);
    #####:  473:      fputs("λ", f);
    #####:  474:      if (quoted) {
    #####:  475:        print_alpha_name(f, depth + 1, 'a');
    #####:  476:        fputc('.', f);
    #####:  477:        print_term_at(f, HEAP[loc], depth + 1, st);
        -:  478:      } else {
    #####:  479:        u32 nam = print_state_lam(st, loc);
    #####:  480:        print_lam_name(f, nam);
    #####:  481:        fputc('.', f);
    #####:  482:        print_term_at(f, HEAP[loc], depth + 1, st);
        -:  483:      }
    #####:  484:      break;
        -:  485:    }
    #####:  486:    case APP: {
    #####:  487:      print_app(f, term, depth, st);
    #####:  488:      break;
        -:  489:    }
    #####:  490:    case SUP: {
    #####:  491:      u32 loc = term_val(term);
    #####:  492:      fputc('&', f);
    #####:  493:      print_name(f, term_ext(term));
    #####:  494:      fputc('{', f);
    #####:  495:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  496:      fputc(',', f);
    #####:  497:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  498:      fputc('}', f);
    #####:  499:      break;
        -:  500:    }
    #####:  501:    case DUP: {
        -:  502:      // DUP term is a syntactic binder; dynamic mode queues its DUP node and prints the body.
    #####:  503:      u32 loc = term_val(term);
    #####:  504:      if (quoted) {
    #####:  505:        fputc('!', f);
    #####:  506:        print_alpha_name(f, depth + 1, 'A');
    #####:  507:        fputc('&', f);
    #####:  508:        print_name(f, term_ext(term));
    #####:  509:        fputc('=', f);
    #####:  510:        print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  511:        fputc(';', f);
    #####:  512:        print_term_at(f, HEAP[loc + 1], depth + 1, st);
        -:  513:      } else {
    #####:  514:        print_state_dup(st, loc, term_ext(term));
    #####:  515:        print_term_at(f, HEAP[loc + 1], depth, st);
        -:  516:      }
    #####:  517:      break;
        -:  518:    }
    #####:  519:    case MOV: {
        -:  520:      // MOV term is a syntactic binder; dynamic mode prints the body.
    #####:  521:      u32 loc = term_val(term);
    #####:  522:      if (quoted) {
    #####:  523:        fputc('%', f);
    #####:  524:        print_alpha_name(f, depth + 1, 'A');
    #####:  525:        fputc('=', f);
    #####:  526:        print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  527:        fputc(';', f);
    #####:  528:        print_term_at(f, HEAP[loc + 1], depth + 1, st);
        -:  529:      } else {
    #####:  530:        print_term_at(f, HEAP[loc + 1], depth, st);
        -:  531:      }
    #####:  532:      break;
        -:  533:    }
    #####:  534:    case MAT:
        -:  535:    case SWI: {
    #####:  536:      fputs("λ{", f);
    #####:  537:      Term cur = term;
    #####:  538:      while (term_tag(cur) == MAT || term_tag(cur) == SWI) {
    #####:  539:        u32 loc = term_val(cur);
    #####:  540:        if (term_tag(cur) == SWI) {
    #####:  541:          fprintf(f, "%u", term_ext(cur));
        -:  542:        } else {
    #####:  543:          print_mat_name(f, term_ext(cur));
        -:  544:        }
    #####:  545:        fputc(':', f);
    #####:  546:        print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  547:        Term next = HEAP[loc + 1];
    #####:  548:        if (term_tag(next) == MAT || term_tag(next) == SWI) {
    #####:  549:          fputc(';', f);
        -:  550:        }
    #####:  551:        cur = next;
        -:  552:      }
        -:  553:      // Handle tail: NUM(0) = empty, USE = wrapped default, other = default.
    #####:  554:      if (term_tag(cur) == NUM && term_val(cur) == 0) {
        -:  555:        // empty default - just close
    #####:  556:      } else if (term_tag(cur) == USE) {
    #####:  557:        fputc(';', f);
    #####:  558:        print_term_at(f, HEAP[term_val(cur)], depth, st);
        -:  559:      } else {
    #####:  560:        fputc(';', f);
    #####:  561:        print_term_at(f, cur, depth, st);
        -:  562:      }
    #####:  563:      fputc('}', f);
    #####:  564:      break;
        -:  565:    }
    #####:  566:    case USE: {
    #####:  567:      u32 loc = term_val(term);
    #####:  568:      fputs("λ{", f);
    #####:  569:      print_term_at(f, HEAP[loc], depth, st);
    #####:  570:      fputc('}', f);
    #####:  571:      break;
        -:  572:    }
       34:  573:    case C00 ... C16: {
       34:  574:      print_ctr(f, term, depth, st);
       34:  575:      break;
        -:  576:    }
    #####:  577:    case OP2: {
    #####:  578:      u32 opr = term_ext(term);
    #####:  579:      u32 loc = term_val(term);
        -:  580:      static const char *op_syms[] = {
        -:  581:        "+", "-", "*", "/", "%", "&&", "||", "^", "<<", ">>",
        -:  582:        "~", "==", "!=", "<", "<=", ">", ">="
        -:  583:      };
    #####:  584:      fputc('(', f);
    #####:  585:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  586:      fputc(' ', f);
    #####:  587:      if (opr < 17) {
    #####:  588:        fputs(op_syms[opr], f);
        -:  589:      } else {
    #####:  590:        fprintf(f, "?%u", opr);
        -:  591:      }
    #####:  592:      fputc(' ', f);
    #####:  593:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  594:      fputc(')', f);
    #####:  595:      break;
        -:  596:    }
    #####:  597:    case DSU: {
    #####:  598:      u32 loc = term_val(term);
    #####:  599:      fputs("&(", f);
    #####:  600:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  601:      fputs("){", f);
    #####:  602:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  603:      fputc(',', f);
    #####:  604:      print_term_at(f, HEAP[loc + 2], depth, st);
    #####:  605:      fputc('}', f);
    #####:  606:      break;
        -:  607:    }
    #####:  608:    case DDU: {
    #####:  609:      u32 loc = term_val(term);
    #####:  610:      fputs("!(", f);
    #####:  611:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  612:      fputs(")=", f);
    #####:  613:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  614:      fputc(';', f);
    #####:  615:      print_term_at(f, HEAP[loc + 2], depth, st);
    #####:  616:      break;
        -:  617:    }
    #####:  618:    case ALO: {
        -:  619:      // ALO prints as @{book_term}, applying ALO substitutions to book vars.
    #####:  620:      u32 alo_loc = term_val(term);
    #####:  621:      u64 pair    = HEAP[alo_loc];
    #####:  622:      u32 tm_loc  = (u32)(pair & 0xFFFFFFFF);
    #####:  623:      u32 ls_loc  = (u32)(pair >> 32);
    #####:  624:      fputs("@{", f);
    #####:  625:      print_term_mode(f, HEAP[tm_loc], 0, 1, ls_loc, term_ext(term), st);
    #####:  626:      fputc('}', f);
    #####:  627:      break;
        -:  628:    }
    #####:  629:    case RED: {
    #####:  630:      u32 loc = term_val(term);
    #####:  631:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  632:      fputs(" ~> ", f);
    #####:  633:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  634:      break;
        -:  635:    }
    #####:  636:    case EQL: {
    #####:  637:      u32 loc = term_val(term);
    #####:  638:      fputc('(', f);
    #####:  639:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  640:      fputs(" === ", f);
    #####:  641:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  642:      fputc(')', f);
    #####:  643:      break;
        -:  644:    }
    #####:  645:    case AND: {
    #####:  646:      u32 loc = term_val(term);
    #####:  647:      fputc('(', f);
    #####:  648:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  649:      fputs(" .&. ", f);
    #####:  650:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  651:      fputc(')', f);
    #####:  652:      break;
        -:  653:    }
    #####:  654:    case OR: {
    #####:  655:      u32 loc = term_val(term);
    #####:  656:      fputc('(', f);
    #####:  657:      print_term_at(f, HEAP[loc + 0], depth, st);
    #####:  658:      fputs(" .|. ", f);
    #####:  659:      print_term_at(f, HEAP[loc + 1], depth, st);
    #####:  660:      fputc(')', f);
    #####:  661:      break;
        -:  662:    }
    #####:  663:    case UNS: {
        -:  664:      // UNS binds an unscoped lam/var pair; show them with global names.
    #####:  665:      u32 loc   = term_val(term);
    #####:  666:      Term lamf = HEAP[loc];
    #####:  667:      u32 locf  = term_val(lamf);
    #####:  668:      Term lamv = HEAP[locf];
    #####:  669:      u32 locv  = term_val(lamv);
    #####:  670:      u32 namf  = print_state_lam(st, locf);
    #####:  671:      u32 namv  = print_state_lam(st, locv);
    #####:  672:      Term body = HEAP[locv];
    #####:  673:      fputs("! ", f);
    #####:  674:      print_lam_name(f, namf);
    #####:  675:      fputs(" = λ ", f);
    #####:  676:      print_lam_name(f, namv);
    #####:  677:      fputs(" ; ", f);
    #####:  678:      print_term_at(f, body, depth + 2, st);
    #####:  679:      break;
        -:  680:    }
    #####:  681:    case INC: {
    #####:  682:      u32 loc = term_val(term);
    #####:  683:      fputs("↑", f);
    #####:  684:      print_term_at(f, HEAP[loc], depth, st);
    #####:  685:      break;
        -:  686:    }
        -:  687:  }
       57:  688:}
        -:  689:
        -:  690:// Prints all discovered dup/mov definitions after the main term.
       15:  691:fn void print_term_finish(FILE *f, PrintState *st) {
       15:  692:  int need_sep = 1;
    #####:  693:  for (;;) {
       15:  694:    u32 prev_dup_len = st->dup_len;
       15:  695:    u32 prev_mov_len = st->mov_len;
       15:  696:    while (st->dup_print < st->dup_len) {
    #####:  697:      if (need_sep) {
    #####:  698:        fputc(';', f);
    #####:  699:        need_sep = 0;
        -:  700:      }
    #####:  701:      u32 idx = st->dup_print++;
    #####:  702:      u32 loc = PRINT_DUPS[idx].loc;
    #####:  703:      u32 lab = PRINT_DUPS[idx].lab;
    #####:  704:      u32 nam = PRINT_DUPS[idx].name;
    #####:  705:      fputc('!', f);
    #####:  706:      print_dup_name(f, nam);
    #####:  707:      fputc('&', f);
    #####:  708:      print_name(f, lab);
    #####:  709:      fputc('=', f);
    #####:  710:      Term val = HEAP[loc];
    #####:  711:      if (term_sub_get(val)) {
    #####:  712:        val = term_sub_set(val, 0);
        -:  713:      }
    #####:  714:      print_term_at(f, val, 0, st);
    #####:  715:      fputc(';', f);
        -:  716:    }
       15:  717:    while (st->mov_print < st->mov_len) {
    #####:  718:      if (need_sep) {
    #####:  719:        fputc(';', f);
    #####:  720:        need_sep = 0;
        -:  721:      }
    #####:  722:      u32 idx = st->mov_print++;
    #####:  723:      u32 loc = PRINT_MOVS[idx].loc;
    #####:  724:      u32 nam = PRINT_MOVS[idx].name;
    #####:  725:      fputc('%', f);
    #####:  726:      print_mov_name(f, nam);
    #####:  727:      fputc('=', f);
    #####:  728:      Term val = HEAP[loc];
    #####:  729:      if (term_sub_get(val)) {
    #####:  730:        val = term_sub_set(val, 0);
        -:  731:      }
    #####:  732:      print_term_at(f, val, 0, st);
    #####:  733:      fputc(';', f);
        -:  734:    }
       15:  735:    if (st->dup_len == prev_dup_len && st->mov_len == prev_mov_len) {
       15:  736:      break;
        -:  737:    }
        -:  738:  }
       15:  739:}
        -:  740:
        -:  741:// Entry point that sets up state, prints the term, then prints floating dups.
       15:  742:fn void print_term_ex(FILE *f, Term term) {
        -:  743:  PrintState st;
       15:  744:  print_state_init(&st);
       15:  745:  print_term_at(f, term, 0, &st);
       15:  746:  print_term_finish(f, &st);
       15:  747:  print_state_free(&st);
       15:  748:}
        -:  749:
        -:  750:// Prints a dynamic term (linked, global naming, deferred dup printing).
       15:  751:fn void print_term(Term term) {
       15:  752:  print_term_ex(stdout, term);
       15:  753:}
        -:  754:
        -:  755:// Prints a static/quoted term (BJV/BJ0/BJ1/BJM) with depth-based lambda names.
    #####:  756:fn void print_term_quoted(Term term) {
        -:  757:  PrintState st;
    #####:  758:  print_state_init(&st);
    #####:  759:  st.quoted = 1;
    #####:  760:  st.subst  = 0;
    #####:  761:  st.subst_len = 0;
    #####:  762:  print_term_at(stdout, term, 0, &st);
    #####:  763:  print_term_finish(stdout, &st);
    #####:  764:  print_state_free(&st);
    #####:  765:}
